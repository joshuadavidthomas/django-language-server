{"id":"5fpcimiy","parent_id":"tv03enep","name":"Diagnostic rendering engine","description":"Implement a shared diagnostic rendering engine that produces human-readable output with source context snippets and error pointers. This is tracked upstream as issue #397 and is a prerequisite for the check command's text output.\n\n## What\n\nA generic renderer in `djls-source` that takes source-level primitives and produces annotate-snippets-style output:\n\n```rust\nrender_diagnostic(source, span: Span, line_index: &LineIndex, code, message, severity)\n```\n\n## Why\n\n- The check command needs rich terminal output for its `text` format\n- Snapshot tests in `djls-semantic` currently show raw struct output — the renderer in plain mode makes them much more readable\n- `djls-source` already owns `Span`, `LineIndex`, `Offset`, `LineCol` — the renderer is the presentation side of these types\n\n## Approach\n\n1. **Evaluate rendering crates**: `annotate-snippets` (preferred for alignment with Ruff/ty), `miette`, and `ariadne` are candidates. Build a small proof-of-concept with one `ValidationError` variant.\n2. **Implement renderer**: Generic over any diagnostic, not tied to `ValidationError`. Two modes: rich (colors, underlines) for terminal and plain (deterministic) for snapshot files.\n3. **Adopt in snapshot tests**: Update `djls-semantic` snapshot tests to use the renderer in plain mode. Run `cargo insta test --accept --unreferenced delete`.\n\n## Placement\n\nLives in `djls-source` — the renderer is generic and `djls-source` already owns the coordinate types. Future: if diagnostics grow beyond rendering, extract to `djls-diagnostic`.\n\n## Acceptance Criteria\n\n- Renderer produces annotate-snippets-style output with source context, error pointers, and diagnostic codes\n- Two modes work: rich (colors) and plain (deterministic)\n- `djls-semantic` snapshot tests updated to use plain mode and are more readable\n- `cargo test -q` passes, `cargo insta test --accept --unreferenced delete` clean","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:53:37.211Z","updated_at":"2026-02-11T17:53:37.211Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":["nrcdb189"],"children":["v6f7la9a","o8q4kj8g","aganrncf"]}
{"id":"aganrncf","parent_id":"5fpcimiy","name":"Adopt renderer in semantic snapshot tests","description":"Update `djls-semantic` snapshot tests to use the new diagnostic renderer in plain mode instead of raw struct output.\n\n## Approach\n\n- At each snapshot test call site, extract span/code/message from `ValidationError` and pass to the renderer's plain mode\n- Run `cargo insta test --accept --unreferenced delete` to regenerate all snapshots\n- Verify new snapshots are more readable: show source context lines, error pointers, and diagnostic codes\n\n## Acceptance Criteria\n\n- All `djls-semantic` snapshot tests use the renderer in plain mode\n- Snapshots show source context with error pointers (not raw struct Debug output)\n- `cargo insta test --accept --unreferenced delete` is clean (no orphan snapshots)\n- `cargo test -q` passes","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:54:08.485Z","updated_at":"2026-02-11T17:54:08.485Z","started_at":null,"completed_at":null,"blockedBy":["o8q4kj8g"],"blocks":[],"children":[]}
{"id":"f4rd8nq1","parent_id":"nrcdb189","name":"Integration test","description":"Add a basic integration test for the `djls check` command.\n\n## Approach\n\nCreate a test that:\n1. Creates a temp directory with template files containing known errors (e.g., unclosed tags for S100, unbalanced structure for S101)\n2. Runs `djls check <dir>` as a subprocess (or invokes the check logic directly if that's simpler)\n3. Asserts exit code is 1 (errors found)\n4. Asserts output contains expected error codes (S100, S101, etc.)\n5. Also test the clean case: a valid template directory → exit code 0\n\n## Placement\n\nAdd to existing test infrastructure. Per AGENTS.md: \"NEVER write standalone test files — always add test cases to existing test modules in the codebase.\" Find the appropriate test module in `crates/djls/` or add an integration test that makes sense for the binary crate.\n\n## Acceptance Criteria\n\n- At least one test for error case (exit code 1, expected error codes in output)\n- At least one test for clean case (exit code 0, no errors)\n- Tests pass in CI: `cargo test -q`","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:55:12.239Z","updated_at":"2026-02-11T17:55:12.239Z","started_at":null,"completed_at":null,"blockedBy":["idbcwda3"],"blocks":[],"children":[]}
{"id":"h655pvnc","parent_id":"nrcdb189","name":"Template file walker","description":"Add a template file walker to `djls-db` (which already depends on `djls-source` for `FileKind`).\n\n## API\n\n```rust\npub fn walk_template_files(paths: &[Utf8PathBuf]) -> Vec<Utf8PathBuf>\n```\n\n## Behavior\n\n- Recursively walk directories, filter by `FileKind::Template` extensions (`.html`, `.htm`, `.djhtml`)\n- For single files, check the extension and include directly\n- Uses `walkdir` or `ignore` crate for efficient directory traversal (add to `[workspace.dependencies]`)\n- Uses `camino::Utf8Path`/`Utf8PathBuf` as canonical path types per project convention\n\n## Acceptance Criteria\n\n- Function walks directories recursively and returns only template files\n- Single file paths are validated and returned if they match template extensions\n- Non-existent paths produce clear errors\n- Unit tests cover: directory walk, single file, mixed paths, non-template files filtered out\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:54:32.600Z","updated_at":"2026-02-11T17:54:32.600Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":["idbcwda3"],"children":[]}
{"id":"idbcwda3","parent_id":"nrcdb189","name":"Check orchestration","description":"Wire up the core check pipeline in `Check::execute()`. This is the main orchestration logic.\n\n## Implementation\n\nIn `Check::execute()`:\n1. Resolve project root (cwd)\n2. Load `Settings::new(root, None)`, merge `--select`/`--ignore` into `DiagnosticsConfig`\n3. Create file system: `Arc::new(djls_workspace::OsFileSystem)` (no overlay needed — reads from disk only)\n4. Create `djls_db::DjangoDatabase::new(fs, settings, project_root)`\n5. Determine files:\n   - If `self.paths` is non-empty → `walk_template_files(&self.paths)`\n   - Else → `template_dirs(db, project)` then walk those\n6. For each file: `db.get_or_create_file(path)`, `parse_template(db, file)`, `validate_nodelist(db, nodelist)`, `collect_diagnostics(db, file, nodelist)`\n7. Convert diagnostics to rendered text via the rendering engine\n8. Print to stdout, return appropriate exit code\n\n## Exit Codes\n\n- `0` — no errors (warnings/hints don't count)\n- `1` — one or more errors found\n- `2` — invocation error (bad args, project not found, etc.)\n\nMap to the existing `Exit` type in `crates/djls/src/exit.rs`.\n\n## Acceptance Criteria\n\n- `djls check templates/` runs the full pipeline and prints diagnostics\n- `djls check` (no args) discovers templates via Django inspector\n- `--select`/`--ignore` correctly filter diagnostic output\n- Exit codes are correct: 0 for clean, 1 for errors, 2 for bad invocation\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:54:53.512Z","updated_at":"2026-02-11T17:54:53.512Z","started_at":null,"completed_at":null,"blockedBy":["h655pvnc","juhz0yg8"],"blocks":["vpxani2s","f4rd8nq1"],"children":[]}
{"id":"juhz0yg8","parent_id":"nrcdb189","name":"CLI arg parsing and command registration","description":"Add the `check` subcommand to the CLI binary.\n\n## Implementation\n\nCreate `crates/djls/src/commands/check.rs`:\n\n```rust\n#[derive(Debug, Parser)]\npub struct Check {\n    /// Files or directories to check. If omitted, discovers from Django template directories.\n    paths: Vec<PathBuf>,\n\n    /// Select specific diagnostic codes to enable\n    #[arg(long)]\n    select: Vec<String>,\n\n    /// Ignore specific diagnostic codes\n    #[arg(long)]\n    ignore: Vec<String>,\n}\n```\n\nRegister in `commands.rs` as `DjlsCommand::Check(check::Check)`.\n\n## Acceptance Criteria\n\n- `djls check --help` shows usage with paths, --select, --ignore\n- `djls check` (no args) is a valid invocation\n- `djls check templates/ --select S100 --ignore S108` parses correctly\n- Command is wired into the existing CLI dispatch but can initially just print \"not implemented\" or similar\n- `cargo build -q` passes","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:54:41.858Z","updated_at":"2026-02-11T17:54:41.858Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":["idbcwda3"],"children":[]}
{"id":"nrcdb189","parent_id":"tv03enep","name":"Implement djls check command","description":"Implement the `djls check` CLI command that walks template files on disk, runs the parse → validate → collect pipeline, formats diagnostics, and exits with an appropriate code.\n\n## Architecture\n\n```\ncrates/djls/src/commands/check.rs    ← CLI args, orchestration\n                                       Uses DjangoDatabase from djls-db\n                                       Walks files, runs pipeline, formats output\n```\n\n## Flow\n\n1. Parse CLI args (paths, --select, --ignore)\n2. Resolve project root (cwd or explicit)\n3. Load settings (pyproject.toml / djls.toml)\n4. Create DjangoDatabase (with OsFileSystem, settings, project_path)\n5. Determine files to check:\n   a. If paths given → walk and filter by FileKind::Template\n   b. If no paths → query template_dirs via inspector, walk those\n6. For each template file: parse_template → validate_nodelist → collect_diagnostics\n7. Format and print diagnostics via rendering engine\n8. Exit with appropriate code (0=clean, 1=errors, 2=invocation error)\n\n## Key Decisions\n\n- Two discovery modes: explicit paths and auto-discovery via inspector\n- Text output only at launch (uses rendering engine from Phase 2)\n- Stdin support: detect piped input automatically\n- Exit codes follow ruff/ty convention\n\n## Acceptance Criteria\n\n- `djls check templates/` checks all template files in the given directory\n- `djls check` (no args) discovers templates via Django inspector\n- `--select` and `--ignore` filter diagnostic codes\n- Stdin piping works: `echo '{% if %}' | djls check -`\n- Exit code 0 when no errors, 1 when errors found, 2 on invocation error\n- Integration test verifies basic functionality","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:54:23.016Z","updated_at":"2026-02-11T17:54:23.016Z","started_at":null,"completed_at":null,"blockedBy":["5fpcimiy"],"blocks":[],"children":["h655pvnc","juhz0yg8","idbcwda3","vpxani2s","f4rd8nq1"]}
{"id":"o8q4kj8g","parent_id":"5fpcimiy","name":"Implement diagnostic renderer in djls-source","description":"Implement the diagnostic renderer in `crates/djls-source/` using `annotate-snippets` (0.12, selected in prior subtask evaluation).\n\n## API\n\n```rust\nrender_diagnostic(source: &str, span: Span, line_index: &LineIndex, code: &str, message: &str, severity: DiagnosticSeverity) -> String\n```\n\n## Requirements\n\n- Generic over any diagnostic — not tied to `ValidationError` specifically\n- Uses `annotate-snippets` with ASCII decor style (ty/ruff style) as default\n- Two output modes:\n  - **Rich**: `Renderer::styled()` — ANSI colors for terminal display\n  - **Plain**: `Renderer::plain()` — no colors, deterministic for snapshot test files\n- Maps byte offsets from `Span` to line/column via `djls_source::LineIndex` for the `Snippet::line_start()` call\n- `annotate-snippets` handles the rest: source context, `^^^` underlines, `error[CODE]:` headers, line numbers\n- Add `annotate-snippets = { workspace = true }` to `djls-source/Cargo.toml`\n\n## Key annotate-snippets patterns (from evaluation)\n\n```rust\nuse annotate_snippets::{AnnotationKind, Level, Renderer, Snippet};\n\nlet report = &[Level::ERROR\n    .primary_title(\"Unclosed tag: block\")\n    .id(\"S100\")\n    .element(\n        Snippet::source(source)\n            .path(filename)\n            .line_start(1)\n            .annotation(\n                AnnotationKind::Primary\n                    .span(start..end)\n                    .label(\"this block tag is never closed\"),\n            ),\n    )];\n\nlet renderer = Renderer::plain(); // or Renderer::styled()\nlet output = renderer.render(report).to_string();\n```\n\nSupports: single-line spans, multi-annotation same line, multi-annotation different lines, notes/info footer, warning level, long line truncation.\n\n## Acceptance Criteria\n\n- Renderer produces ty-style output with source context lines, `^^^` underlines, and `error[CODE]:` headers\n- Both rich and plain modes produce correct output\n- Unit tests cover representative error shapes (single-line span, two annotations, long line)\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":true,"result":"Implemented DiagnosticRenderer in `crates/djls-source/src/render.rs` using `annotate-snippets` 0.12.\n\n## What was built\n\n- `Diagnostic` struct — collects source, path, code, message, severity, annotations, and notes\n- `DiagnosticRenderer` — `plain()` and `styled()` constructors, `render(&Diagnostic) -> String`\n- `DiagnosticAnnotation` — primary (`^^^`) or context (`---`) span labels\n- `Severity` enum — Error, Warning, Info, Hint (maps to annotate-snippets Level)\n- Builder pattern: `Diagnostic::new(...).annotation(...).note(...)`\n\n## Public API\n\n```rust\npub use djls_source::{Diagnostic, DiagnosticAnnotation, DiagnosticRenderer, Severity};\n```\n\n## Tests (8 passing)\n\n- `single_line_span` — basic error with `^^^` underline\n- `two_annotations_different_lines` — primary + context on separate lines\n- `two_annotations_same_line` — two annotations on same source line\n- `with_note` — `= note:` footer\n- `warning_severity` — `warning[W001]` header\n- `long_line_truncation` — `...` prefix on long lines\n- `styled_produces_ansi` — ANSI escape codes present\n- `plain_no_ansi` — no ANSI escape codes\n\n## Verification\n\n- `cargo build -q` — clean\n- `cargo clippy -q --all-targets --all-features -- -D warnings` — clean\n- `cargo test -q -p djls-source` — 18 tests pass (10 existing + 8 new)\n- All workspace test failures are pre-existing corpus sync issues (same 86 on main)","metadata":{"commit":{"sha":"96d9eee1","message":"Add diagnostic renderer to djls-source","branch":"josh/diagnostic-rendering-engine","timestamp":"2026-02-11T18:28:35.821Z"}},"created_at":"2026-02-11T17:53:54.219Z","updated_at":"2026-02-11T18:28:35.823Z","started_at":"2026-02-11T18:28:35.822Z","completed_at":"2026-02-11T18:28:35.823Z","blockedBy":["v6f7la9a"],"blocks":["aganrncf"],"children":[]}
{"id":"tv03enep","parent_id":null,"name":"djls check — standalone CLI template checker","description":"A standalone CLI command that walks template files on disk, runs the same parse → validate → collect pipeline that the LSP uses, and prints diagnostics to the terminal with an appropriate exit code. Think `ruff check` or `ty check` but for Django templates.\n\n```\ndjls check [PATHS...] [--select S100,S101] [--ignore S108]\n```\n\n## Background\n\nThe validation pipeline is already well-factored across crates. The check command is a new *consumer* of existing infrastructure (parsing, validation, diagnostic collection, severity filtering), not a rewrite. Phase 1 (extracting `djls-db` crate) already landed in PR #402, making the concrete database reusable by both the LSP server and CLI.\n\n## Remaining Work\n\nTwo phases remain:\n1. **Diagnostic rendering engine** (#397) — `annotate-snippets`-style rich terminal output, lives in `djls-source`, used by both snapshot tests and the check command's text formatter.\n2. **`djls check` command** — CLI arg parsing, template file walking, database initialization, pipeline orchestration, exit codes.\n\n## Key Design Decisions\n\n- **Database**: `djls-db` crate (already extracted) sits above all Salsa trait layers\n- **File discovery**: Both explicit paths and auto-discovery via Django inspector\n- **Output format**: `text` only at launch (rich snippets via rendering engine); `concise`, `json`, `github` added later\n- **Exit codes**: 0 (clean), 1 (errors), 2 (invocation error) — ruff/ty convention\n- **Inspector**: Default full inspector for project-aware discovery; explicit paths bypass template dir discovery\n\n## Reference\n\n- RESEARCH.md — complete chain analysis of template validation pipeline\n- PLAN.md — full design plan with architecture, flow, and implementation details\n- PR #402 — Phase 1 (djls-db extraction) already landed\n- Issue #397 — diagnostic rendering engine tracking issue","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:53:21.660Z","updated_at":"2026-02-11T17:53:21.660Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":["5fpcimiy","nrcdb189"]}
{"id":"v6f7la9a","parent_id":"5fpcimiy","name":"Evaluate and select rendering crate","description":"Evaluate `annotate-snippets`, `miette`, and `ariadne` for diagnostic rendering. Build a small proof-of-concept with one `ValidationError` variant (e.g., S100 UnclosedTag) to compare output quality, API ergonomics, and integration effort.\n\n`annotate-snippets` is preferred for alignment with Ruff/ty. Select the crate and add it to `[workspace.dependencies]` in root `Cargo.toml`.\n\n## Acceptance Criteria\n\n- Proof-of-concept renders at least one `ValidationError` variant with source context\n- Decision documented (even if just in the dex result)\n- Chosen crate added to workspace dependencies","priority":1,"completed":true,"result":"Evaluated annotate-snippets (0.12.11), miette (7.6.0), and ariadne (0.5.1) by building proof-of-concept renderings of real ValidationError variants.\n\n## Decision: annotate-snippets\n\n### Why annotate-snippets wins\n\n1. **Lightest dependency tree** — 2 deps (anstyle, unicode-width) vs miette's 11 (backtrace, proc-macro, terminal_size, etc.) vs ariadne's 2 (unicode-width, yansi)\n2. **Matches ty/ruff output** — the project's target audience uses Python tooling from Astral; matching their diagnostic style creates familiarity\n3. **Used by rustc** — being adopted as the official Rust compiler diagnostic renderer, actively maintained by Rust project members\n4. **Built-in plain/styled modes** — `Renderer::plain()` for snapshot tests, `Renderer::styled()` for terminal, plus `testing-colors` feature for deterministic colored test output\n5. **Functional API taking primitives** — `Level::ERROR.primary_title().id().element(Snippet::source().annotation())` — exactly fits the generic renderer design (takes source + span + code + message, not tied to error types)\n6. **DecorStyle** — `Ascii` (default, ty-style) and `Unicode` options; `term_width()` for wrapping; `anonymize_line_numbers()` for test determinism\n\n### Why not the others\n\n- **miette**: Heavy deps, derive-macro approach couples error types to rendering (opposite of our generic renderer goal), global state for color control, different visual style\n- **ariadne**: Light deps but writes to `impl Write` (buffer management), requires `Cache` trait for source lookup, different visual style from ty/ruff\n\n### What was tested\n\nBuilt 12 scenarios covering all major ValidationError shapes:\n- Single-line spans (S100, S108, S111, S115, S116, S120)\n- Two annotations same line (S114 — `and and` with context + primary)\n- Two annotations different lines (S103, S122, W001, S101)\n- Multi-line spans (S109 crispy form)\n- Notes/info footer (S109 load hint)\n- Warning level (W001)\n- Long line truncation with `...` prefix\n- Multiple files stacked\n\nAlso compared ASCII vs Unicode decor styles, and a hand-rolled Python SyntaxError style. ASCII mode (ty-style) was selected as the default.\n\n### Added to workspace\n\n`annotate-snippets = \"0.12\"` added to `[workspace.dependencies]` in root `Cargo.toml`.","metadata":null,"created_at":"2026-02-11T17:53:44.152Z","updated_at":"2026-02-11T18:22:46.435Z","started_at":"2026-02-11T18:22:46.434Z","completed_at":"2026-02-11T18:22:46.435Z","blockedBy":[],"blocks":["o8q4kj8g"],"children":[]}
{"id":"vpxani2s","parent_id":"nrcdb189","name":"Stdin support","description":"Add support for piping template content via stdin.\n\n## Behavior\n\nDetect `!std::io::stdin().is_terminal()`:\n- Read all of stdin into a string\n- Create an in-memory file (use a synthetic path like `<stdin>`)\n- Run through the same parse → validate → collect pipeline\n- Print diagnostics and exit\n\nNo explicit flag needed — stdin is detected automatically. This should be integrated into the file discovery step of `Check::execute()`: if stdin is not a terminal, read it as a single template before checking any path arguments.\n\n## Example\n\n```bash\necho '{% if %}' | djls check\ncat template.html | djls check\n```\n\n## Acceptance Criteria\n\n- Piped input is detected and checked as a single template\n- Diagnostics reference `<stdin>` as the file path\n- Exit code reflects whether errors were found in the piped content\n- Non-terminal stdin takes priority over path arguments (or works alongside them — decide during implementation)\n- `cargo build -q` passes","priority":1,"completed":false,"result":null,"metadata":null,"created_at":"2026-02-11T17:55:02.335Z","updated_at":"2026-02-11T17:55:02.335Z","started_at":null,"completed_at":null,"blockedBy":["idbcwda3"],"blocks":[],"children":[]}
