{"id":"0juup8cz","parent_id":null,"name":"Add dedicated Development section to README","description":"Keep the section in Contributing, but trim it down to the wants and point to the new section. It should have basics of how to get setup, architecture, maybe design decisions, areas that need help.","priority":1,"completed":true,"result":"Covered by #438 â€” added ARCHITECTURE.md and updated CONTRIBUTING.md with development setup and architecture details.","metadata":{"commit":{"sha":"a20ebc82","message":"Add ARCHITECTURE.md and update CONTRIBUTING.md (#438)","branch":"main","timestamp":"2026-02-13T16:01:57.967Z"},"github":{"issueNumber":38,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/38","repo":"joshuadavidthomas/django-language-server","state":"closed"}},"created_at":"2026-02-11T18:47:12.310Z","updated_at":"2026-02-13T16:02:00.634Z","started_at":"2026-02-13T16:01:57.970Z","completed_at":"2026-02-13T16:01:57.972Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"1uowqy9w","parent_id":null,"name":"Document Python and Django version support policy","description":"The version support policy exists implicitly but isn't written down anywhere as a policy. Currently just one sentence in docs/installation.md: 'aims to support all actively maintained versions of Python and Django.'\n\nThe actual policy is:\n\n- Support all actively maintained Django versions (including LTS)\n- Support all actively maintained Python versions\n- The intersection of both: we support Django versions that are still maintained, AND Python versions that are still maintained\n- We do NOT support EOL Python versions even if a maintained Django version still supports them (e.g., Django 4.2 LTS supports Python 3.8, but 3.8 is EOL so we don't)\n\nThis should be documented somewhere visible â€” probably docs/installation.md or a dedicated support policy page. The CONTRIBUTING.md Version Updates sections reference noxfile.py as the source of truth for what's supported, but don't explain the policy for deciding what goes in that list.","priority":1,"completed":true,"result":"Documented in docs/versioning.md with full support policy.","metadata":{"commit":{"sha":"0bba8af9","message":"Document Python and Django version support policy","branch":"docs/version-support-policy","timestamp":"2026-02-13T16:07:30.173Z"},"github":{"issueNumber":439,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/439","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-13T08:28:07.454Z","updated_at":"2026-02-13T16:07:31.815Z","started_at":"2026-02-13T16:07:30.181Z","completed_at":"2026-02-13T16:07:30.185Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"345qt6ov","parent_id":null,"name":"Set up local flamegraph profiling for benchmarks","description":"## Goal\n\nGenerate collapsed-stack flamegraph profiles from djls-bench benchmarks locally, producing text-based output that can be analyzed in-session (not just CodSpeed's web-only flamegraphs).\n\n## Current State\n\n- `flamegraph` (0.6.9) and `perf` (6.18) are installed\n- `perf_event_paranoid=2` â€” userspace profiling works\n- Bench binaries are at `target/release/deps/{name}-{hash}`\n- divan filters are positional args: `./bench-binary \"filter_name\"`\n- No `[profile.bench]` in Cargo.toml â€” need `CARGO_PROFILE_BENCH_DEBUG=2` env var for symbols (without it, stacks show `[unknown]`)\n- Quick test confirmed: building with debug info produces `[optimized + debuginfo]`, perf record works\n\n## Approach\n\n1. **Add a `just profile` recipe** that:\n   - Builds the specified bench with debug info (`CARGO_PROFILE_BENCH_DEBUG=2`)\n   - Runs `perf record -g --call-graph dwarf` on the bench binary with an optional filter\n   - Converts to collapsed stacks via `perf script | inferno-collapse-perf` (or `flamegraph`'s internal pipeline)\n   - Outputs both the collapsed stacks text file AND an SVG flamegraph\n   - Stores results in a gitignored `profiles/` directory\n\n2. **Install `inferno`** (`cargo install inferno`) for the `inferno-collapse-perf` tool to produce collapsed stacks text from perf data â€” this is the key format for text-based analysis\n\n3. **Add `profiles/` to .gitignore**\n\n4. **Add `[profile.bench]` to Cargo.toml** with `debug = 2` so we don't need the env var trick every time (or decide against this if it bloats CI)\n\n## Acceptance Criteria\n\n- `just profile parser parse_template` (or similar) produces:\n  - `profiles/parser-parse_template.collapsed` â€” text file of collapsed stacks\n  - `profiles/parser-parse_template.svg` â€” flamegraph SVG\n- Collapsed stacks file is readable text like `main;run_check;parse_template;tokenize 4500`\n- Works on Linux with perf_event_paranoid=2\n- `profiles/` is gitignored\n- Documented in justfile comments","priority":1,"completed":true,"result":"Implemented local flamegraph profiling:\n\n- Added `.just/profiling.just` with `just prof profile <bench> [filter]` recipe\n- Recipe builds bench with debug info, runs `perf record -g --call-graph dwarf`, pipes through `inferno-collapse-perf` and `inferno-flamegraph`\n- Produces `profiles/<label>.collapsed` (text) and `profiles/<label>.svg` (flamegraph)\n- Cleans up intermediate `perf.data` automatically\n- Added `just prof clean` to remove all profiling artifacts\n- Added `[profile.bench] debug = 2` to root `Cargo.toml` for symbolized stacks\n- Added `profiles/` to `.gitignore`\n- Dependency check (`_ensure-deps`) validates `perf`, `inferno-collapse-perf`, and `jq` are available\n\nVerified: `just prof profile parser parse_template` produces both collapsed stacks and SVG with resolved Rust symbols (e.g. `djls_templates::quotes::split_on_whitespace`).","metadata":{"commit":{"sha":"6c32c017","message":"Add local flamegraph profiling for benchmarks","branch":"feat/flamegraph-profiling","timestamp":"2026-02-12T19:39:34.302Z"},"github":{"issueNumber":416,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/416","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-12T02:13:34.276Z","updated_at":"2026-02-12T19:39:35.732Z","started_at":"2026-02-12T19:39:34.307Z","completed_at":"2026-02-12T19:39:34.308Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"5fpcimiy","parent_id":"tv03enep","name":"Diagnostic rendering engine","description":"Implement a shared diagnostic rendering engine that produces human-readable output with source context snippets and error pointers. This is tracked upstream as issue #397 and is a prerequisite for the check command's text output.\n\n## What\n\nA generic renderer in `djls-source` that takes source-level primitives and produces annotate-snippets-style output:\n\n```rust\nrender_diagnostic(source, span: Span, line_index: &LineIndex, code, message, severity)\n```\n\n## Why\n\n- The check command needs rich terminal output for its `text` format\n- Snapshot tests in `djls-semantic` currently show raw struct output â€” the renderer in plain mode makes them much more readable\n- `djls-source` already owns `Span`, `LineIndex`, `Offset`, `LineCol` â€” the renderer is the presentation side of these types\n\n## Approach\n\n1. **Evaluate rendering crates**: `annotate-snippets` (preferred for alignment with Ruff/ty), `miette`, and `ariadne` are candidates. Build a small proof-of-concept with one `ValidationError` variant.\n2. **Implement renderer**: Generic over any diagnostic, not tied to `ValidationError`. Two modes: rich (colors, underlines) for terminal and plain (deterministic) for snapshot files.\n3. **Adopt in snapshot tests**: Update `djls-semantic` snapshot tests to use the renderer in plain mode. Run `cargo insta test --accept --unreferenced delete`.\n\n## Placement\n\nLives in `djls-source` â€” the renderer is generic and `djls-source` already owns the coordinate types. Future: if diagnostics grow beyond rendering, extract to `djls-diagnostic`.\n\n## Acceptance Criteria\n\n- Renderer produces annotate-snippets-style output with source context, error pointers, and diagnostic codes\n- Two modes work: rich (colors) and plain (deterministic)\n- `djls-semantic` snapshot tests updated to use plain mode and are more readable\n- `cargo test -q` passes, `cargo insta test --accept --unreferenced delete` clean","priority":1,"completed":true,"result":"Diagnostic rendering engine complete: selected annotate-snippets, implemented DiagnosticRenderer in djls-source with plain/styled modes, and adopted renderer in all semantic snapshot tests.","metadata":null,"created_at":"2026-02-11T17:53:37.211Z","updated_at":"2026-02-11T18:35:50.552Z","started_at":"2026-02-11T18:35:50.551Z","completed_at":"2026-02-11T18:35:50.552Z","blockedBy":[],"blocks":["nrcdb189"],"children":["v6f7la9a","o8q4kj8g","aganrncf"]}
{"id":"5lww6xft","parent_id":null,"name":"Merge discovery parsing with extraction to avoid double-parsing templatetag files","description":"## What\n\nCombine the filesystem discovery pass (`discover_template_libraries`) with the rule extraction pass (`extract_external_rules`) so each external templatetag Python file is parsed once instead of twice.\n\n## Why\n\nCurrently, external templatetag files are parsed twice during startup:\n\n1. `discover_template_libraries` â†’ `extract_symbols_from_module_file` â†’ `collect_registrations_from_source` â€” parses each file's AST to find tag/filter registration names (for library discovery)\n2. `extract_external_rules` â†’ `extract_rules` â†’ parses the **same files again** with Ruff to extract validation rules (argument constraints, block specs, filter arities)\n\nBoth use `ruff_python_parser::parse_module` on the same source text. The first pass only collects `RegistrationInfo` (names + kinds), the second does full rule extraction.\n\nFor vanilla Django (12 files, ~80KB total), this wastes ~5-10ms. For a big project with 30+ templatetag modules (e.g., wagtail + django-cms + allauth), ~20-40ms. Not a bottleneck, but it's free performance left on the table.\n\n## Approach\n\nThe key insight: `extract_rules_from_body` in `djls-python/src/lib.rs` already calls `collect_registrations_from_body` internally â€” extraction is a superset of discovery. The work is:\n\n1. Have `discover_template_libraries` return both the `Vec<TemplateLibrary>` (discovery results) **and** the `ExtractionResult` for each module, by calling `extract_rules` instead of just `collect_registrations_from_source`.\n\n2. Or: have discovery return the parsed AST / registration info so extraction can reuse it without re-parsing.\n\n3. Update the startup path in `djls-db/src/inspector.rs` and `djls-server/src/server.rs` to thread the extraction results from discovery into the Salsa inputs, avoiding the separate `extract_external_rules` call for files that were already processed during discovery.\n\n### Considerations\n\n- Workspace modules are already handled separately via Salsa tracked queries (`extract_module`) â€” this optimization is only for external (site-packages) modules.\n- The current split between \"discovery\" (knows about library names, app modules, file paths) and \"extraction\" (knows about tag rules, filter arities, block specs) is a clean separation. Merging them means discovery would need to depend on `djls-python`'s extraction types, which it already does transitively.\n- `collect_registrations_from_body` is `pub(crate)` and `extract_rules_from_body` is also `pub(crate)` â€” both take `&[Stmt]`, so sharing the parsed AST between them is straightforward.\n\n## Estimated impact\n\n~5-40ms depending on project size. Low priority but clean win.","priority":1,"completed":true,"result":"Obsoleted by #433 â€” filesystem discovery was removed entirely, eliminating the double-parse.","metadata":{"commit":{"sha":"2cbe4d78","message":"Remove filesystem discovery, simplify to inspector-only startup (#433)","branch":"main","timestamp":"2026-02-13T16:01:08.146Z"},"github":{"issueNumber":430,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/430","repo":"joshuadavidthomas/django-language-server","state":"closed"}},"created_at":"2026-02-12T22:50:15.315Z","updated_at":"2026-02-13T16:01:10.957Z","started_at":"2026-02-13T16:01:08.152Z","completed_at":"2026-02-13T16:01:08.154Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"7u77rrja","parent_id":null,"name":"Add rg-style file filtering flags to CLI commands","description":"## What\n\nAdd file filtering flags to `djls check` (and eventually `djls format`) matching ripgrep's CLI conventions. The `ignore` crate's `WalkBuilder` already supports all of this â€” we just need to wire it up.\n\n## Why\n\nCurrently `djls check` only has `--hidden`. Users can't exclude paths by glob, disable .gitignore respect, follow symlinks, or limit recursion depth. These are table-stakes for any CLI tool that walks directories.\n\n## Implementation\n\n### 1. `WalkOptions` struct in `djls-workspace`\n\nReplace the bare `hidden: bool` parameter on `walk_files` with a `WalkOptions` struct:\n\n- `hidden: bool` (default: false)\n- `globs: Vec<String>` (default: empty) â€” gitignore-style globs, `!` prefix to negate\n- `no_ignore: bool` (default: false) â€” disable all ignore files\n- `follow_links: bool` (default: false) â€” follow symlinks\n- `max_depth: Option<usize>` (default: None) â€” limit recursion\n\nThread these into `WalkBuilder` methods: `.hidden()`, `.overrides()` (via `OverrideBuilder`), `.follow_links()`, `.standard_filters()` (for no_ignore), `.max_depth()`.\n\n### 2. CLI flags on `djls check`\n\n```\n-g, --glob <GLOB>       Include or exclude files matching glob (repeatable, ! to negate)\n    --no-ignore         Don't respect .gitignore/.ignore files\n-L, --follow            Follow symbolic links\n-d, --max-depth <NUM>   Limit directory recursion depth\n    --color <WHEN>      When to use colors: always, auto, never (default: auto)\n-q, --quiet             Suppress output, only set exit code\n```\n\n### 3. Output control\n\n- `--color`: Replace `pick_renderer()` auto-detect with explicit flag. `always`/`auto`/`never`.\n- `--quiet`: Suppress all output, exit 0 (clean) or 1 (errors found). Useful for CI.\n\n## Acceptance Criteria\n\n- [ ] `-g/--glob` filters files by glob pattern, `!` prefix excludes\n- [ ] `--no-ignore` disables .gitignore/.ignore respect\n- [ ] `-L/--follow` follows symlinks during traversal\n- [ ] `-d/--max-depth` limits recursion depth\n- [ ] `--color always|auto|never` controls output coloring\n- [ ] `-q/--quiet` suppresses output, exit code only\n- [ ] `walk_files` uses `WalkOptions` struct (shared with future `djls format`)\n- [ ] Existing `--hidden` flag still works\n- [ ] Tests for glob include/exclude, no-ignore, symlink following, max-depth","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":447,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/447","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-14T06:34:24.735Z","updated_at":"2026-02-14T06:34:25.733Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"9i6yacml","parent_id":null,"name":"Separate StructuralError from ValidationError","description":"Structural errors (unclosed tags, orphaned intermediates, mismatched block names) and validation errors (unknown tag, wrong argument count, bad filter arity) are currently all variants of `ValidationError` going through the same `ValidationErrorAccumulator`. They come from different stages and mean different things â€” structural errors are about template *shape* (built during `build_block_tree`), validation errors are about template *content* (produced by `TemplateValidator`).\n\nIntroduce a `StructuralError` type and `StructuralErrorAccumulator` for the block tree builder. This would:\n- Make the domain model more accurate\n- Allow collecting/filtering structural vs validation errors independently\n- Potentially allow skipping validation when structure is too broken\n- Make a future accumulator-to-return-value migration easier (smaller, more focused types)\n\nAffected areas:\n- `crates/djls-semantic/src/errors.rs` â€” split relevant variants out\n- `crates/djls-semantic/src/structure/builder.rs` â€” use new accumulator\n- `crates/djls-semantic/src/db.rs` â€” new accumulator definition\n- `crates/djls-ide/src/diagnostics.rs` â€” collect from both accumulators\n- Test helpers and snapshot updates","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":437,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/437","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-13T07:38:50.603Z","updated_at":"2026-02-13T07:38:51.564Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"aganrncf","parent_id":"5fpcimiy","name":"Adopt renderer in semantic snapshot tests","description":"Update `djls-semantic` snapshot tests to use the new diagnostic renderer in plain mode instead of raw struct output.\n\n## Approach\n\n- At each snapshot test call site, extract span/code/message from `ValidationError` and pass to the renderer's plain mode\n- Run `cargo insta test --accept --unreferenced delete` to regenerate all snapshots\n- Verify new snapshots are more readable: show source context lines, error pointers, and diagnostic codes\n\n## Acceptance Criteria\n\n- All `djls-semantic` snapshot tests use the renderer in plain mode\n- Snapshots show source context with error pointers (not raw struct Debug output)\n- `cargo insta test --accept --unreferenced delete` is clean (no orphan snapshots)\n- `cargo test -q` passes","priority":1,"completed":true,"result":"Replaced hand-rolled diagnostic rendering with DiagnosticRenderer::plain() from djls-source. Removed primary_span, error_kind, error_detail_lines helpers. Snapshots now use annotate-snippets format with error codes, source context, and caret pointers. All 112 non-corpus tests pass, clippy clean.","metadata":null,"created_at":"2026-02-11T17:54:08.485Z","updated_at":"2026-02-11T18:35:45.768Z","started_at":"2026-02-11T18:35:45.767Z","completed_at":"2026-02-11T18:35:45.768Z","blockedBy":["o8q4kj8g"],"blocks":[],"children":[]}
{"id":"d4cmwfgd","parent_id":null,"name":"Add diagnostic code pages to documentation","description":"This came up in #339 but the diagnostic codes are not documented anywhere, you have to look in the source to see them:\n\nhttps://github.com/joshuadavidthomas/django-language-server/blob/d5d43ad395f8771a7386d7c970ec78ba16e6ab66/crates/djls-ide/src/diagnostics.rs#L70-L81\n\nThere should be either a page with all of them listed (like djlint has for it's codes), or maybe like ruff a dedicated page for each code. Dedicated pages would be a bit more work, but probably worth it in the long run? Linkability and being able to provide examples -- though I suppose you could achieve that with a single page too, so ðŸ¤·.","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":343,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/343","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:11.650Z","updated_at":"2026-02-11T20:55:02.334Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"f4rd8nq1","parent_id":"nrcdb189","name":"Integration test","description":"Add a basic integration test for the `djls check` command.\n\n## Approach\n\nCreate a test that:\n1. Creates a temp directory with template files containing known errors (e.g., unclosed tags for S100, unbalanced structure for S101)\n2. Runs `djls check <dir>` as a subprocess (or invokes the check logic directly if that's simpler)\n3. Asserts exit code is 1 (errors found)\n4. Asserts output contains expected error codes (S100, S101, etc.)\n5. Also test the clean case: a valid template directory â†’ exit code 0\n\n## Placement\n\nAdd to existing test infrastructure. Per AGENTS.md: \"NEVER write standalone test files â€” always add test cases to existing test modules in the codebase.\" Find the appropriate test module in `crates/djls/` or add an integration test that makes sense for the binary crate.\n\n## Acceptance Criteria\n\n- At least one test for error case (exit code 1, expected error codes in output)\n- At least one test for clean case (exit code 0, no errors)\n- Tests pass in CI: `cargo test -q`","priority":1,"completed":true,"result":"5 integration tests: clean exit, broken exit, --ignore, stdin, empty dir","metadata":null,"created_at":"2026-02-11T17:55:12.239Z","updated_at":"2026-02-11T19:20:50.381Z","started_at":"2026-02-11T19:20:50.379Z","completed_at":"2026-02-11T19:20:50.381Z","blockedBy":["idbcwda3"],"blocks":[],"children":[]}
{"id":"h655pvnc","parent_id":"nrcdb189","name":"Template file walker","description":"Add a template file walker to `djls-db` (which already depends on `djls-source` for `FileKind`).\n\n## API\n\n```rust\npub fn walk_template_files(paths: &[Utf8PathBuf]) -> Vec<Utf8PathBuf>\n```\n\n## Behavior\n\n- Recursively walk directories, filter by `FileKind::Template` extensions (`.html`, `.htm`, `.djhtml`)\n- For single files, check the extension and include directly\n- Uses `walkdir` or `ignore` crate for efficient directory traversal (add to `[workspace.dependencies]`)\n- Uses `camino::Utf8Path`/`Utf8PathBuf` as canonical path types per project convention\n\n## Acceptance Criteria\n\n- Function walks directories recursively and returns only template files\n- Single file paths are validated and returned if they match template extensions\n- Non-existent paths produce clear errors\n- Unit tests cover: directory walk, single file, mixed paths, non-template files filtered out\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":true,"result":"Implemented walk_template_files in djls-db/src/walk.rs with walkdir, FileKind filtering, hidden dir skipping, dedup","metadata":null,"created_at":"2026-02-11T17:54:32.600Z","updated_at":"2026-02-11T19:19:33.874Z","started_at":"2026-02-11T19:19:33.872Z","completed_at":"2026-02-11T19:19:33.874Z","blockedBy":[],"blocks":["idbcwda3"],"children":[]}
{"id":"idbcwda3","parent_id":"nrcdb189","name":"Check orchestration","description":"Wire up the core check pipeline in `Check::execute()`. This is the main orchestration logic.\n\n## Implementation\n\nIn `Check::execute()`:\n1. Resolve project root (cwd)\n2. Load `Settings::new(root, None)`, merge `--select`/`--ignore` into `DiagnosticsConfig`\n3. Create file system: `Arc::new(djls_workspace::OsFileSystem)` (no overlay needed â€” reads from disk only)\n4. Create `djls_db::DjangoDatabase::new(fs, settings, project_root)`\n5. Determine files:\n   - If `self.paths` is non-empty â†’ `walk_template_files(&self.paths)`\n   - Else â†’ `template_dirs(db, project)` then walk those\n6. For each file: `db.get_or_create_file(path)`, `parse_template(db, file)`, `validate_nodelist(db, nodelist)`, `collect_diagnostics(db, file, nodelist)`\n7. Convert diagnostics to rendered text via the rendering engine\n8. Print to stdout, return appropriate exit code\n\n## Exit Codes\n\n- `0` â€” no errors (warnings/hints don't count)\n- `1` â€” one or more errors found\n- `2` â€” invocation error (bad args, project not found, etc.)\n\nMap to the existing `Exit` type in `crates/djls/src/exit.rs`.\n\n## Acceptance Criteria\n\n- `djls check templates/` runs the full pipeline and prints diagnostics\n- `djls check` (no args) discovers templates via Django inspector\n- `--select`/`--ignore` correctly filter diagnostic output\n- Exit codes are correct: 0 for clean, 1 for errors, 2 for bad invocation\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":true,"result":"Full orchestration: resolve project root, load settings, create DjangoDatabase, walk files, parse+validate+render diagnostics, exit codes","metadata":null,"created_at":"2026-02-11T17:54:53.512Z","updated_at":"2026-02-11T19:19:34.127Z","started_at":"2026-02-11T19:19:34.126Z","completed_at":"2026-02-11T19:19:34.127Z","blockedBy":["h655pvnc","juhz0yg8"],"blocks":["vpxani2s","f4rd8nq1"],"children":[]}
{"id":"iyh1yvx1","parent_id":null,"name":"Adopt unified Markdown format for all snapshot tests","description":"Many unit tests in `djls-semantic` (specifically in `filters/validation.rs` and `loads/validation.rs`) currently rely on hand-written `matches!` assertions. This makes tests difficult to maintain and provides poor visibility into what the error actually looks like to a user. We should migrate these to a unified snapshot format that renders the input template and the resulting diagnostics together.\n\n### Goals\n- Improve test readability and maintainability.\n- Provide \"visual\" confirmation of diagnostic placement in templates.\n\n### Requirements\n- **Markdown Format:** The snapshot should use a Markdown-friendly format.\n  - Section 1: The input Django template (as a code block).\n  - Section 2: The rendered diagnostics (generated by the renderer from Issue #397).\n- **Test Helper:** Implement a `snapshot_validate(source: &str)` helper in `crates/djls-semantic/src/testing.rs` that encapsulates the parsing, validation, rendering, and `insta::assert_snapshot!` call.\n- **Migration:**\n  - Convert `crates/djls-semantic/src/lib.rs` corpus tests.\n  - Convert `crates/djls-semantic/src/filters/validation.rs` tests.\n  - Convert `crates/djls-semantic/src/loads/validation.rs` tests.\n\n### Dependency\nThis issue depends on the implementation of the diagnostic renderer (#397).\n\n> Braindump by @joshuadavidthomas, issue captured and created by Gemini 3 Flash","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":398,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/398","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:44:53.615Z","updated_at":"2026-02-11T20:55:03.351Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"juhz0yg8","parent_id":"nrcdb189","name":"CLI arg parsing and command registration","description":"Add the `check` subcommand to the CLI binary.\n\n## Implementation\n\nCreate `crates/djls/src/commands/check.rs`:\n\n```rust\n#[derive(Debug, Parser)]\npub struct Check {\n    /// Files or directories to check. If omitted, discovers from Django template directories.\n    paths: Vec<PathBuf>,\n\n    /// Select specific diagnostic codes to enable\n    #[arg(long)]\n    select: Vec<String>,\n\n    /// Ignore specific diagnostic codes\n    #[arg(long)]\n    ignore: Vec<String>,\n}\n```\n\nRegister in `commands.rs` as `DjlsCommand::Check(check::Check)`.\n\n## Acceptance Criteria\n\n- `djls check --help` shows usage with paths, --select, --ignore\n- `djls check` (no args) is a valid invocation\n- `djls check templates/ --select S100 --ignore S108` parses correctly\n- Command is wired into the existing CLI dispatch but can initially just print \"not implemented\" or similar\n- `cargo build -q` passes","priority":1,"completed":true,"result":"Added Check struct with clap args (paths, --select, --ignore) and registered in DjlsCommand enum","metadata":null,"created_at":"2026-02-11T17:54:41.858Z","updated_at":"2026-02-11T19:19:33.619Z","started_at":"2026-02-11T19:19:33.617Z","completed_at":"2026-02-11T19:19:33.619Z","blockedBy":[],"blocks":["idbcwda3"],"children":[]}
{"id":"nrcdb189","parent_id":"tv03enep","name":"Implement djls check command","description":"Implement the `djls check` CLI command that walks template files on disk, runs the parse â†’ validate â†’ collect pipeline, formats diagnostics, and exits with an appropriate code.\n\n## Architecture\n\n```\ncrates/djls/src/commands/check.rs    â† CLI args, orchestration\n                                       Uses DjangoDatabase from djls-db\n                                       Walks files, runs pipeline, formats output\n```\n\n## Flow\n\n1. Parse CLI args (paths, --select, --ignore)\n2. Resolve project root (cwd or explicit)\n3. Load settings (pyproject.toml / djls.toml)\n4. Create DjangoDatabase (with OsFileSystem, settings, project_path)\n5. Determine files to check:\n   a. If paths given â†’ walk and filter by FileKind::Template\n   b. If no paths â†’ query template_dirs via inspector, walk those\n6. For each template file: parse_template â†’ validate_nodelist â†’ collect_diagnostics\n7. Format and print diagnostics via rendering engine\n8. Exit with appropriate code (0=clean, 1=errors, 2=invocation error)\n\n## Key Decisions\n\n- Two discovery modes: explicit paths and auto-discovery via inspector\n- Text output only at launch (uses rendering engine from Phase 2)\n- Stdin support: detect piped input automatically\n- Exit codes follow ruff/ty convention\n\n## Acceptance Criteria\n\n- `djls check templates/` checks all template files in the given directory\n- `djls check` (no args) discovers templates via Django inspector\n- `--select` and `--ignore` filter diagnostic codes\n- Stdin piping works: `echo '{% if %}' | djls check -`\n- Exit code 0 when no errors, 1 when errors found, 2 on invocation error\n- Integration test verifies basic functionality","priority":1,"completed":true,"result":"All subtasks complete: CLI, walker, orchestration, stdin, integration tests","metadata":null,"created_at":"2026-02-11T17:54:23.016Z","updated_at":"2026-02-11T19:20:50.635Z","started_at":"2026-02-11T19:20:50.633Z","completed_at":"2026-02-11T19:20:50.635Z","blockedBy":["5fpcimiy"],"blocks":[],"children":["h655pvnc","juhz0yg8","idbcwda3","vpxani2s","f4rd8nq1"]}
{"id":"o8q4kj8g","parent_id":"5fpcimiy","name":"Implement diagnostic renderer in djls-source","description":"Implement the diagnostic renderer in `crates/djls-source/` using `annotate-snippets` (0.12, selected in prior subtask evaluation).\n\n## API\n\n```rust\nrender_diagnostic(source: &str, span: Span, line_index: &LineIndex, code: &str, message: &str, severity: DiagnosticSeverity) -> String\n```\n\n## Requirements\n\n- Generic over any diagnostic â€” not tied to `ValidationError` specifically\n- Uses `annotate-snippets` with ASCII decor style (ty/ruff style) as default\n- Two output modes:\n  - **Rich**: `Renderer::styled()` â€” ANSI colors for terminal display\n  - **Plain**: `Renderer::plain()` â€” no colors, deterministic for snapshot test files\n- Maps byte offsets from `Span` to line/column via `djls_source::LineIndex` for the `Snippet::line_start()` call\n- `annotate-snippets` handles the rest: source context, `^^^` underlines, `error[CODE]:` headers, line numbers\n- Add `annotate-snippets = { workspace = true }` to `djls-source/Cargo.toml`\n\n## Key annotate-snippets patterns (from evaluation)\n\n```rust\nuse annotate_snippets::{AnnotationKind, Level, Renderer, Snippet};\n\nlet report = &[Level::ERROR\n    .primary_title(\"Unclosed tag: block\")\n    .id(\"S100\")\n    .element(\n        Snippet::source(source)\n            .path(filename)\n            .line_start(1)\n            .annotation(\n                AnnotationKind::Primary\n                    .span(start..end)\n                    .label(\"this block tag is never closed\"),\n            ),\n    )];\n\nlet renderer = Renderer::plain(); // or Renderer::styled()\nlet output = renderer.render(report).to_string();\n```\n\nSupports: single-line spans, multi-annotation same line, multi-annotation different lines, notes/info footer, warning level, long line truncation.\n\n## Acceptance Criteria\n\n- Renderer produces ty-style output with source context lines, `^^^` underlines, and `error[CODE]:` headers\n- Both rich and plain modes produce correct output\n- Unit tests cover representative error shapes (single-line span, two annotations, long line)\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":true,"result":"Implemented DiagnosticRenderer in `crates/djls-source/src/render.rs` using `annotate-snippets` 0.12.\n\n## What was built\n\n- `Diagnostic` struct â€” collects source, path, code, message, severity, annotations, and notes\n- `DiagnosticRenderer` â€” `plain()` and `styled()` constructors, `render(&Diagnostic) -> String`\n- `DiagnosticAnnotation` â€” primary (`^^^`) or context (`---`) span labels\n- `Severity` enum â€” Error, Warning, Info, Hint (maps to annotate-snippets Level)\n- Builder pattern: `Diagnostic::new(...).annotation(...).note(...)`\n\n## Public API\n\n```rust\npub use djls_source::{Diagnostic, DiagnosticAnnotation, DiagnosticRenderer, Severity};\n```\n\n## Tests (8 passing)\n\n- `single_line_span` â€” basic error with `^^^` underline\n- `two_annotations_different_lines` â€” primary + context on separate lines\n- `two_annotations_same_line` â€” two annotations on same source line\n- `with_note` â€” `= note:` footer\n- `warning_severity` â€” `warning[W001]` header\n- `long_line_truncation` â€” `...` prefix on long lines\n- `styled_produces_ansi` â€” ANSI escape codes present\n- `plain_no_ansi` â€” no ANSI escape codes\n\n## Verification\n\n- `cargo build -q` â€” clean\n- `cargo clippy -q --all-targets --all-features -- -D warnings` â€” clean\n- `cargo test -q -p djls-source` â€” 18 tests pass (10 existing + 8 new)\n- All workspace test failures are pre-existing corpus sync issues (same 86 on main)","metadata":{"commit":{"sha":"96d9eee1","message":"Add diagnostic renderer to djls-source","branch":"josh/diagnostic-rendering-engine","timestamp":"2026-02-11T18:28:35.821Z"}},"created_at":"2026-02-11T17:53:54.219Z","updated_at":"2026-02-11T18:28:35.823Z","started_at":"2026-02-11T18:28:35.822Z","completed_at":"2026-02-11T18:28:35.823Z","blockedBy":["v6f7la9a"],"blocks":["aganrncf"],"children":[]}
{"id":"qjctji25","parent_id":null,"name":"Audit and add tracing instrumentation across the codebase","description":"## What\n\nAudit the codebase for opportunities to add structured tracing instrumentation using `tracing` spans and events. The goal is systematic observability into server behavior â€” startup, request handling, query execution, and background tasks.\n\n## Why\n\nCurrently timing visibility is ad-hoc (manual `Instant::now()` + `elapsed()` in a few places added during the startup parallelization work). The `tracing` crate supports structured spans with automatic duration tracking, but the subscriber isn't configured to render span durations (`FmtSpan::CLOSE` or similar), and most code paths have no instrumentation at all.\n\nGood observability would help with:\n- Diagnosing slow startups or request latency in user environments\n- Identifying which Salsa queries are re-executing vs cached\n- Understanding the cost of inspector subprocess calls, filesystem discovery, and extraction\n- Profiling without needing to attach a profiler\n\n## Approach\n\n1. **Configure the subscriber**: Add `FmtSpan::CLOSE` (or `FmtSpan::NEW | FmtSpan::CLOSE`) to the `fmt` layer in `djls-server/src/logging.rs` so span durations appear in log output. Consider making this configurable or gating behind a `debug` setting to avoid noise in normal operation.\n\n2. **Instrument key operations** with `#[instrument]` or manual `info_span!`:\n   - `refresh_inspector` / `query_inspector_template_libraries` / `extract_external_rules`\n   - `discover_template_libraries` (filesystem walk)\n   - `load_inspector_cache` / `save_inspector_response`\n   - LSP request handlers (`completion`, `diagnostic`, `goto_definition`, `references`)\n   - `parse_template`, `validate_nodelist` (the hot path)\n   - Salsa tracked functions like `compute_tag_specs`, `compute_tag_index`, `extract_module`\n\n3. **Replace manual timing** in `server.rs` `initialized` / `did_change_configuration` with proper spans once the subscriber supports duration rendering.\n\n4. **Add span fields** where useful (e.g., file path on parse/validate, module path on extraction, library count on discovery).\n\n## Notes\n\n- Be careful with `#[instrument]` on functions that take `&dyn Db` or Salsa types â€” you'll need `skip_all` or `skip(db)` to avoid `Debug` bounds issues.\n- For async functions in the server, `#[instrument]` works but creates spans that include `.await` suspension time (which is usually what you want for wall-clock visibility).\n- Consider a `RUST_LOG=djls=debug` or custom env var to control verbosity of span output separately from event logging.","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":429,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/429","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-12T22:49:37.040Z","updated_at":"2026-02-12T22:49:38.038Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"qqc92r00","parent_id":null,"name":"Create `djls-test` crate and implement targeted environment ingestion","description":"Redundancy exists within the current test suite: nearly every module in `djls-semantic` maintains its own ~60-line Salsa `TestDatabase` implementation. Furthermore, to address #398, there is a requirement to test against specific Django versions and third-party apps (e.g., `django-crispy-forms`) without the overhead of syncing entire repositories into a bulk `.corpus`.\n\n## Proposal\nCreate a dedicated `djls-test` crate to serve as the unified infrastructure for all workspace testing. This crate will implement a \"targeted\" environment strategy inspired by the patterns found in `ruff/ty`.\n\n## Technical Requirements\n1.  **Unified `TestDatabase`**:\n    *   A single, robust Salsa database implementation that satisfies all crate-level `Db` traits (`djls_source`, `djls_templates`, `djls_semantic`, `djls_project`).\n    *   Integration with an `InMemoryFileSystem` to allow writing virtual files for unit testing.\n2.  **Venv Ingester (The `uv` Bridge)**:\n    *   Implement logic to execute `uv sync` in a temporary directory based on a provided list of dependencies.\n    *   **Site-Package Ingestion**: Recursively copy the resulting `site-packages` into the Salsa `InMemoryFileSystem`. \n    *   *Optimization*: Only copy `.py` and `.pyi` files (skip binaries and `__pycache__`) to keep the test DB lightweight.\n3.  **Migration**:\n    *   Migrate `djls-semantic` and `djls-python` unit tests to use this shared infrastructure.\n    *   Refactor the corpus \"smoke test\" to be a standard `#[test]` that uses this database to build extraction specs on the fly.\n\n> Braindump by @joshuadavidthomas, issue captured and created by Gemini 3 Flash","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":399,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/399","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:10.258Z","updated_at":"2026-02-11T20:55:04.384Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"r7y9s5n1","parent_id":null,"name":"Environment variables needed by settings loading","description":"## Problem\n\nUsers who set environment variables required by Django settings loading (e.g. `DJANGO_SECRET_KEY = os.environ[\"DJANGO_SECRET_KEY\"]`) have no way to make those variables available to the djls inspector process. The inspector fails with errors like:\n\n```\nInspector query 'django_init' returned ok=false, error=Some(\"'DJANGO_SECRET_KEY'\")\n```\n\n## Wrong direction: `[tool.djls.env]` config\n\nAn initial attempt added an `env` map to Settings so users could write:\n\n```toml\n[tool.djls.env]\nDJANGO_SECRET_KEY = \"my-secret-key\"\n```\n\nThis is the wrong approach for two reasons:\n1. **Security** â€” secrets end up in config files that are often committed to version control.\n2. **Duplication** â€” users already define these variables elsewhere (docker-compose.yml, .env files, shell profiles, etc.). Forcing them to duplicate values defeats the purpose.\n\n## Better directions to explore\n\n- **Pass-through from host environment**: A config option like `env_passthrough = [\"DJANGO_SECRET_KEY\", \"DATABASE_URL\"]` that tells djls to forward specific variables from the host environment to the inspector process. No secrets in config, no duplication.\n- **`.env` file support**: Read a `.env` file (or let users specify a path) and inject those variables into the inspector process. Many Django projects already use `.env` files with `python-dotenv` or similar.\n- **Inherit all env vars**: The simplest option â€” just inherit the parent process environment into the inspector subprocess instead of (or in addition to) the explicit env vars currently set. Need to check if `Command::new()` already does this by default (it does on Unix unless `env_clear()` is called).\n\nThe third option may actually already work â€” need to investigate whether the current `cmd.env(...)` calls are additive (they should be, per Rust std docs) or if something is stripping the inherited environment.","priority":1,"completed":true,"result":"Implemented `env_file` configuration option that loads environment variables from `.env` files into the inspector subprocess. This solves the issue where Django settings that read from `os.environ` fail when the editor process doesn't inherit shell environment variables.\n\nImplementation:\n- Added `env_file` option to `Settings` in `djls-conf` (optional string, path relative to project root)\n- Added `env_vars: Vec<(String, String)>` to `Project` Salsa input, populated by parsing the env file at bootstrap\n- Threaded env vars through the full inspector chain (`Inspector::query` â†’ `InspectorInner::ensure_process` â†’ `InspectorProcess::spawn`)\n- Applied env vars to the subprocess `Command` alongside `PYTHONPATH` and `DJANGO_SETTINGS_MODULE`\n- Inspector process restarts when env vars change\n- Settings reload (`update_project_from_settings`) re-parses the env file\n- Auto-detects `.env` in project root when no `env_file` is configured\n- Used `dotenvy` crate for `.env` file parsing\n\nTests: 6 new tests for env file loading (default .env, custom path, missing file, comments/blank lines, quoted values) plus 1 Settings deserialization test. All 355+ tests pass. Clippy and lint clean.\n\nDocumentation: Added `env_file` section to `docs/configuration/index.md` with usage examples. Updated both changelogs.","metadata":{"commit":{"sha":"b38014b2","message":"Add documentation, changelog, and tests for env_file","branch":"jdt/env-passthrough","timestamp":"2026-02-13T02:21:05.199Z"},"github":{"issueNumber":378,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/378","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:10.967Z","updated_at":"2026-02-13T02:21:06.625Z","started_at":"2026-02-13T02:21:05.203Z","completed_at":"2026-02-13T02:21:05.204Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"tv03enep","parent_id":null,"name":"djls check â€” standalone CLI template checker","description":"A standalone CLI command that walks template files on disk, runs the same parse â†’ validate â†’ collect pipeline that the LSP uses, and prints diagnostics to the terminal with an appropriate exit code. Think `ruff check` or `ty check` but for Django templates.\n\n```\ndjls check [PATHS...] [--select S100,S101] [--ignore S108]\n```\n\n## Background\n\nThe validation pipeline is already well-factored across crates. The check command is a new *consumer* of existing infrastructure (parsing, validation, diagnostic collection, severity filtering), not a rewrite. Phase 1 (extracting `djls-db` crate) already landed in PR #402, making the concrete database reusable by both the LSP server and CLI.\n\n## Remaining Work\n\nTwo phases remain:\n1. **Diagnostic rendering engine** (#397) â€” `annotate-snippets`-style rich terminal output, lives in `djls-source`, used by both snapshot tests and the check command's text formatter.\n2. **`djls check` command** â€” CLI arg parsing, template file walking, database initialization, pipeline orchestration, exit codes.\n\n## Key Design Decisions\n\n- **Database**: `djls-db` crate (already extracted) sits above all Salsa trait layers\n- **File discovery**: Both explicit paths and auto-discovery via Django inspector\n- **Output format**: `text` only at launch (rich snippets via rendering engine); `concise`, `json`, `github` added later\n- **Exit codes**: 0 (clean), 1 (errors), 2 (invocation error) â€” ruff/ty convention\n- **Inspector**: Default full inspector for project-aware discovery; explicit paths bypass template dir discovery\n\n## Reference\n\n- RESEARCH.md â€” complete chain analysis of template validation pipeline\n- PLAN.md â€” full design plan with architecture, flow, and implementation details\n- PR #402 â€” Phase 1 (djls-db extraction) already landed\n- Issue #397 â€” diagnostic rendering engine tracking issue","priority":1,"completed":true,"result":"Phase 3 complete: djls check command implemented with file walking, rendering, stdin, select/ignore, exit codes","metadata":{"github":{"issueNumber":406,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/406","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T17:53:21.660Z","updated_at":"2026-02-11T20:55:06.945Z","started_at":"2026-02-11T19:20:50.886Z","completed_at":"2026-02-11T19:20:50.891Z","blockedBy":[],"blocks":[],"children":["5fpcimiy","nrcdb189"]}
{"id":"u0mt3s3t","parent_id":null,"name":"Suppress diagnostic push notifications during shutdown","description":"On server shutdown, tower-lsp-server tries to push `publishDiagnostics` notifications after the client has already disconnected, producing a flood of `failed to send notification` ERROR logs.\n\nExample from `~/.cache/djls/djls.log.*`:\n\n```\ntower_lsp_server::service::client: failed to send notification\n``` \n\nRepeated 30-50 times per shutdown.\n\nThe root cause is a race: the shutdown/exit sequence tears down the transport, but pending `publish_diagnostics` calls from `republish_open_template_diagnostics` (or the initial diagnostic push on `did_open`) still fire. Since the client channel is closed, every send fails.\n\nOptions:\n1. Guard `publish_diagnostics` with a shutdown flag (`AtomicBool`) â€” skip sends after shutdown received\n2. Drain open documents on shutdown so there's nothing to republish\n3. Catch the send error in `publish_diagnostics` and log at DEBUG instead of letting tower-lsp log at ERROR\n\nOption 1 is simplest and most correct. The flag can be set in `shutdown()` and checked at the top of `publish_diagnostics`.\n\nThis is cosmetic â€” no user-facing impact â€” but the ERROR-level log spam makes real errors hard to spot in the log file.","priority":1,"completed":true,"result":"Merged in #435 (b5b910d1).","metadata":{"commit":{"sha":"b5b910d1","message":"Suppress diagnostic push notifications during shutdown (#435)","branch":"main","timestamp":"2026-02-13T16:01:11.421Z"},"github":{"issueNumber":434,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/434","repo":"joshuadavidthomas/django-language-server","state":"closed"}},"created_at":"2026-02-13T05:33:23.310Z","updated_at":"2026-02-13T16:01:14.347Z","started_at":"2026-02-13T16:01:11.427Z","completed_at":"2026-02-13T16:01:11.429Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"u8nreg2u","parent_id":null,"name":"Replace Python inspector subprocess with static settings extraction","description":"Replace the inspector subprocess â€” which spawns a Python process, runs `django.setup()`, and introspects the live runtime over JSON-over-stdin/stdout â€” with static extraction from files on disk. Parse `settings.py` with Ruff's Python AST (the same approach used for template tag/filter validation rule extraction), resolve apps and template libraries from the filesystem, and eliminate the need for a working Django runtime entirely.\n\n## Motivation\n\nThe inspector is the single biggest source of deployment friction and runtime complexity:\n\n- **Requires a working Python environment** where `import django` succeeds and `django.setup()` completes without error. Missing dependencies, environment variables, or database connections cause silent failures (#378).\n- **Environment variable propagation** is a recurring pain point â€” users must configure their editor to pass `DJANGO_SECRET_KEY` and similar variables through to the LSP binary just to get basic functionality.\n- **Process lifecycle management** adds complexity: long-lived subprocess, stdin/stdout IPC, idle timeouts, graceful shutdown, temp file cleanup for the embedded zipapp.\n- **Build-time Python dependency**: the zipapp is compiled via `python -m zipapp` in `build.rs` and embedded via `include_bytes!`, requiring Python available at `cargo build` time.\n- **All-or-nothing degradation**: if `django.setup()` fails, the inspector returns zero information. There's no partial success.\n\nStatic extraction eliminates all of this. The LSP server becomes a fully self-contained binary that reads files on disk â€” no Python subprocess, no runtime dependency, no environment variable juggling.\n\n## What the inspector currently provides\n\n| Query | Data | Consumer |\n|---|---|---|\n| `django_init` | Whether `django.setup()` succeeded | Gate for other queries |\n| `template_dirs` | Template directories from `settings.TEMPLATES` | File discovery, goto-definition |\n| `template_libraries` | Enabled libraries, builtins, tag/filter symbols with modules and docstrings | Completions, diagnostics, semantic analysis |\n\n`django_init` only exists because the other queries need it. The real value is `template_dirs` and `template_libraries`.\n\n## Approach\n\nThe same pattern that worked for validation rule extraction: parse Python source with Ruff's AST, follow references, assemble the picture. We'd replicate what Django does internally â€” but from the outside looking in.\n\n### What Django does at runtime\n\n1. **App loading**: reads `INSTALLED_APPS`, imports each module, discovers `templatetags/` packages\n2. **Engine initialization**: autodiscovers template libraries from installed apps, applies `OPTIONS.libraries` and `OPTIONS.builtins` from `TEMPLATES` config, prepends Django's default builtins\n3. **Template dirs**: reads `TEMPLATES[*]['DIRS']`, appends `<app>/templates/` for each app when `APP_DIRS` is set\n\n### What we'd do statically\n\n1. **Parse `settings.py`** â€” extract `INSTALLED_APPS` (list of strings), `TEMPLATES` (dict structure) via AST walking. For split settings (`from .base import *` + `INSTALLED_APPS += [...]`), follow the import chain.\n2. **Resolve apps** â€” given each `INSTALLED_APPS` entry, resolve to a directory via existing `resolve_module()`. For `AppConfig` paths, parse `apps.py` to read the `name` attribute.\n3. **Build `TemplateLibraries`** â€” filter existing `discover_template_libraries()` output to apps in `INSTALLED_APPS`, apply explicit `libraries`/`builtins` from settings, add Django's well-known default builtins.\n4. **Compute template dirs** â€” `DIRS` from settings + `<app>/templates/` when `APP_DIRS` is set.\n\nMost of the infrastructure already exists: `discover_template_libraries()`, `resolve_module()`, `build_search_paths()`, `collect_registrations_from_source()`, and the Ruff parser.\n\n### Coverage tiers\n\n| Tier | Pattern | Coverage |\n|---|---|---|\n| 1 | Literal `INSTALLED_APPS`/`TEMPLATES` in a single settings file | ~80% |\n| 2 | Split settings (`from .base import *` + `+=`), `BASE_DIR` resolution, `AppConfig` paths | ~95% |\n| 3 | `django-environ`, `django-split-settings`, fully dynamic | Deferred |\n\nWhen extraction can't determine a value, each field degrades independently:\n- Can't parse `INSTALLED_APPS` â†’ all discovered libraries treated as potentially active\n- Can't parse `TEMPLATES` â†’ use Django's default builtins, no explicit libraries\n- Can't resolve an app â†’ skip it, continue with others\n\nThis is strictly better than the inspector's all-or-nothing failure mode.\n\n## Implementation plan\n\n1. **Settings extraction module** â€” parse `settings.py`, extract `INSTALLED_APPS` and `TEMPLATES` as structured data (Tier 1: literal lists)\n2. **App resolution** â€” resolve `INSTALLED_APPS` entries to directories\n3. **Static `TemplateLibraries` assembly** â€” combine settings + discovery + default builtins\n4. **Wire in as primary path** â€” replace `refresh_inspector()`, keep inspector as temporary fallback\n5. **Tier 2 extraction** â€” split settings, `BASE_DIR`, `AppConfig` paths\n6. **Static template dirs**\n7. **Integration tests** against corpus projects\n8. **Remove inspector** â€” delete subprocess, zipapp, build-time Python dependency\n\nDetailed design: [`PLAN-static-inspector.md`](https://gist.github.com/joshuadavidthomas/2b0da62c56d8aaba240f33cef936b19a)\n\n## Related\n\n- #378 â€” Environment variables needed by settings loading (this is the exact user-facing pain point that static extraction eliminates)\n\n> Braindump by @joshuadavidthomas, issue captured and created by Claude Opus 4.6","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":401,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/401","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:08.849Z","updated_at":"2026-02-11T20:55:08.049Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"v2ltvadc","parent_id":null,"name":"Django template formatter (textDocument/formatting)","description":"## What\n\nBuild a native Rust Django template formatter, exposed both as an LSP formatting provider (`textDocument/formatting`, `textDocument/rangeFormatting`) and as a standalone `djls format` CLI command. This is the most impactful user-facing feature we can ship â€” there is a genuine gap in the Django ecosystem here.\n\n## Why\n\nThe ecosystem has two options, both with significant limitations:\n\n**djade** (Adam Johnson, Rust): Fast (~20ms for 377 files), reliable, follows Django's official template style guide. But zero configurability by design and only formats Django syntax â€” won't touch HTML at all.\n\n**djLint** (Python): Formats both HTML and Django syntax, highly configurable. But slow, buggy (can replace template variables with Python builtins), 150 open issues, actively seeking maintainers.\n\nNobody has built a formatter that is **fast + reliable + configurable + HTML-aware**. A formatter shipping inside the language server means format-on-save just works. A standalone CLI command means it slots into CI pipelines, pre-commit hooks, and editor-agnostic workflows â€” same formatter, same rules, two interfaces.\n\n## Existing Foundation\n\nThe infrastructure is largely built:\n\n- **Lexer** (`crates/djls-templates/src/lexer.rs`): Whitespace-preserving, separates `Whitespace`, `Newline`, `Block`, `Variable`, `Comment`, `Text` tokens. Uses memchr for performance.\n- **Token types** (`tokens.rs`): Full span tracking with `content_span()`, `full_span()`, and `lexeme()` reconstruction. Tokens already know how to rebuild themselves.\n- **Parser** (`parser.rs`): Produces nodes with precise spans. Error recovery means we can format broken templates.\n- **Filter parsing** (`filters.rs`): Filter chains fully parsed â€” `name`, `arg`, `span` per filter.\n- **Quote-aware splitting** (`quotes.rs`): `split_on_whitespace()` handles quoted arguments correctly.\n- **Block tree** (`crates/djls-semantic/src/structure/`): `build_block_tree()` produces hierarchical structure from the flat node list â€” indentation context is already solved.\n- **Visitor pattern** (`visitor.rs`): AST traversal infrastructure ready.\n- **Tag specs** (`crates/djls-semantic/src/templatetags/`): Know which tags are block tags, what their intermediate tags are, argument patterns â€” all useful for formatting decisions.\n- **CLI pattern** (`crates/djls/src/commands/check.rs`): `djls check` already implements file discovery, stdin support, parallel processing via rayon, `djls.toml` config loading, and exit code conventions. `djls format` follows the same pattern.\n\nThe key observation from djade's source: it's ~2300 lines in a single `main.rs`, operating at the token level (lex â†’ mutate tokens â†’ rebuild string). Our lexer already produces richer tokens than djade's. The formatter is a pipeline of token-level transformations, not a complex AST rewrite.\n\n## Approach\n\n### Phase 1: Django syntax formatting (v1)\n\nOperate at the **token level**, similar to djade's architecture but with configurability. The formatter is a pipeline of independent passes over the token stream:\n\n**Core formatting rules:**\n- Normalize whitespace inside `{% %}`, `{{ }}`, `{# #}` delimiters (single space padding)\n- Normalize filter spacing: `{{ value|filter:arg }}` (no spaces around `|` and `:`)\n- Normalize tag argument spacing (single spaces between arguments)\n- Sort `{% load %}` libraries alphabetically (configurable: on/off)\n- Merge consecutive `{% load %}` tags (configurable: on/off)\n- Label `{% endblock %}` tags with block name when not on same line\n- Normalize comment spacing\n\n**Indentation rules (using block tree):**\n- Indent content inside block-level tags (`if`, `for`, `block`, `with`, etc.)\n- Handle intermediate tags (`elif`, `else`, `empty`) at parent indent level\n- Unindent top-level `{% block %}`/`{% endblock %}` in templates that `{% extends %}`\n- Configurable indent width and style (spaces/tabs)\n\n**Configuration** (via `djls.toml`):\n- `formatter.indent_width` (default: 4)\n- `formatter.indent_style` (\"spaces\" | \"tabs\")\n- `formatter.sort_load_libraries` (default: true)\n- `formatter.merge_load_tags` (default: true)\n- `formatter.label_endblocks` (default: true)\n\n**NOT in v1:**\n- HTML tag formatting (preserved as-is)\n- Django version upgrade fixers (djade's territory â€” we're a formatter, not a migrator)\n- CSS/JS formatting\n\n### Phase 2: HTML-aware formatting (v2, future)\n\nExtend the lexer/parser to understand HTML structure within Text nodes. This would make djls the first tool that handles both HTML indentation and Django template indentation correctly together. Scope TBD after v1 ships.\n\n## Implementation\n\nNew crate: `crates/djls-fmt/`\n\nThe formatter operates on the token stream (not the parsed AST), because:\n1. Tokens preserve all whitespace information\n2. Token-level transforms are simpler and compose well\n3. djade validates this architecture at scale\n4. Text nodes in the AST lose their content (only store spans)\n\nPipeline:\n```\nsource â†’ lex() â†’ [token transforms] â†’ rebuild string â†’ compute TextEdits against original\n```\n\n### `djls format` CLI command\n\nFollow the `djls check` pattern in `crates/djls/src/commands/check.rs`:\n\n```\ndjls format [paths...]          # Format files in-place\ndjls format --check [paths...]  # Check formatting, exit 1 if changes needed (CI mode)\ndjls format --diff [paths...]   # Print unified diff of changes\ndjls format -                   # Read stdin, write formatted output to stdout\n```\n\n- File discovery: same `walk_files` + `is_template` logic as `check`\n- Parallel formatting via rayon (clone db per task, same pattern as `check`)\n- `--hidden` flag for dotfiles\n- Stdin support for editor/pipe integration\n- Exit codes: 0 = no changes (or formatted successfully), 1 = changes needed (in `--check` mode)\n- Config loaded from `djls.toml` via `djls_conf::Settings`\n\n### LSP integration\n\nIn `djls-server`:\n- Advertise `documentFormattingProvider` and `documentRangeFormattingProvider`\n- Handler calls formatter, diffs against original, returns `Vec<TextEdit>`\n\n## Acceptance Criteria\n\n- [ ] `djls format` CLI command works with files, directories, and stdin\n- [ ] `djls format --check` exits non-zero when files need formatting (CI mode)\n- [ ] `djls format --diff` prints unified diffs\n- [ ] `textDocument/formatting` works in editors (VS Code, Neovim, etc.)\n- [ ] `textDocument/rangeFormatting` works for selections\n- [ ] Core formatting rules from Phase 1 all implemented\n- [ ] Configuration via `djls.toml` respected\n- [ ] Idempotent: formatting already-formatted output produces no changes\n- [ ] Doesn't break templates: formatting then rendering produces identical output\n- [ ] Handles broken templates gracefully (error recovery)\n- [ ] Snapshot tests for all formatting rules\n- [ ] Corpus test: format all corpus templates, verify no parse errors introduced","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":446,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/446","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-14T06:14:28.440Z","updated_at":"2026-02-14T06:21:45.803Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"v6f7la9a","parent_id":"5fpcimiy","name":"Evaluate and select rendering crate","description":"Evaluate `annotate-snippets`, `miette`, and `ariadne` for diagnostic rendering. Build a small proof-of-concept with one `ValidationError` variant (e.g., S100 UnclosedTag) to compare output quality, API ergonomics, and integration effort.\n\n`annotate-snippets` is preferred for alignment with Ruff/ty. Select the crate and add it to `[workspace.dependencies]` in root `Cargo.toml`.\n\n## Acceptance Criteria\n\n- Proof-of-concept renders at least one `ValidationError` variant with source context\n- Decision documented (even if just in the dex result)\n- Chosen crate added to workspace dependencies","priority":1,"completed":true,"result":"Evaluated annotate-snippets (0.12.11), miette (7.6.0), and ariadne (0.5.1) by building proof-of-concept renderings of real ValidationError variants.\n\n## Decision: annotate-snippets\n\n### Why annotate-snippets wins\n\n1. **Lightest dependency tree** â€” 2 deps (anstyle, unicode-width) vs miette's 11 (backtrace, proc-macro, terminal_size, etc.) vs ariadne's 2 (unicode-width, yansi)\n2. **Matches ty/ruff output** â€” the project's target audience uses Python tooling from Astral; matching their diagnostic style creates familiarity\n3. **Used by rustc** â€” being adopted as the official Rust compiler diagnostic renderer, actively maintained by Rust project members\n4. **Built-in plain/styled modes** â€” `Renderer::plain()` for snapshot tests, `Renderer::styled()` for terminal, plus `testing-colors` feature for deterministic colored test output\n5. **Functional API taking primitives** â€” `Level::ERROR.primary_title().id().element(Snippet::source().annotation())` â€” exactly fits the generic renderer design (takes source + span + code + message, not tied to error types)\n6. **DecorStyle** â€” `Ascii` (default, ty-style) and `Unicode` options; `term_width()` for wrapping; `anonymize_line_numbers()` for test determinism\n\n### Why not the others\n\n- **miette**: Heavy deps, derive-macro approach couples error types to rendering (opposite of our generic renderer goal), global state for color control, different visual style\n- **ariadne**: Light deps but writes to `impl Write` (buffer management), requires `Cache` trait for source lookup, different visual style from ty/ruff\n\n### What was tested\n\nBuilt 12 scenarios covering all major ValidationError shapes:\n- Single-line spans (S100, S108, S111, S115, S116, S120)\n- Two annotations same line (S114 â€” `and and` with context + primary)\n- Two annotations different lines (S103, S122, W001, S101)\n- Multi-line spans (S109 crispy form)\n- Notes/info footer (S109 load hint)\n- Warning level (W001)\n- Long line truncation with `...` prefix\n- Multiple files stacked\n\nAlso compared ASCII vs Unicode decor styles, and a hand-rolled Python SyntaxError style. ASCII mode (ty-style) was selected as the default.\n\n### Added to workspace\n\n`annotate-snippets = \"0.12\"` added to `[workspace.dependencies]` in root `Cargo.toml`.","metadata":null,"created_at":"2026-02-11T17:53:44.152Z","updated_at":"2026-02-11T18:22:46.435Z","started_at":"2026-02-11T18:22:46.434Z","completed_at":"2026-02-11T18:22:46.435Z","blockedBy":[],"blocks":["o8q4kj8g"],"children":[]}
{"id":"vjl204dj","parent_id":null,"name":"Add --hidden flag to djls check","description":"Replace `walkdir` with the `ignore` crate (from ripgrep) for file traversal in `walk_files`, and add a `--hidden` flag to `djls check`.\n\n## Why `ignore` over `walkdir`\n\nThe `ignore` crate (crates.io/crates/ignore) is ripgrep's file walker. It gives us for free:\n- `.gitignore` / `.ignore` / `.rgignore` respect\n- Hidden file/dir exclusion by default (toggle with `.hidden(true)`)\n- Global gitignore support\n- Parallel traversal option (`WalkParallel`)\n- Symlink handling\n- `.git/` directory skipping\n\nRight now we use `walkdir` + hand-rolled `is_hidden` + a caller-provided `skip_dir` predicate. The `ignore` crate handles all of this natively and correctly (edge cases around nested .gitignore, negation patterns, etc.).\n\nripgrep's convention: hidden files excluded by default, `--hidden` opts in. We copy that directly.\n\n## Changes\n\n### `crates/djls-workspace/`\n- Replace `walkdir` dep with `ignore` in Cargo.toml\n- Rewrite `walk_files` to use `ignore::WalkBuilder`\n- Remove the `skip_dir` parameter â€” `ignore` handles hidden dirs natively\n- Add a `hidden: bool` parameter instead (passed through to `WalkBuilder::hidden()`)\n- `.gitignore` respect comes free\n\n### `crates/djls/src/commands/check.rs`\n- Add `--hidden` flag to `Check` struct\n- Remove `is_hidden_dir` helper\n- Pass `self.hidden` through to `walk_files`\n\n### Root `Cargo.toml`\n- Add `ignore` to workspace deps, remove `walkdir`\n\n## Acceptance Criteria\n\n- `djls check .` skips hidden dirs and respects .gitignore (improved default)\n- `djls check --hidden .` includes hidden directories\n- Existing tests pass (update walker tests for new API)\n- `walkdir` removed from dependency tree","priority":1,"completed":true,"result":"Replaced walkdir with ignore crate across all crates. walk_files now takes hidden: bool instead of skip_dir closure. djls check respects .gitignore and skips hidden dirs by default, --hidden flag opts in. walkdir removed as direct dep.","metadata":{"github":{"issueNumber":405,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/405","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T20:39:05.077Z","updated_at":"2026-02-11T20:55:09.022Z","started_at":"2026-02-11T20:53:56.978Z","completed_at":"2026-02-11T20:53:56.982Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"vn3vdvhc","parent_id":null,"name":"Adopt inline diagnostic snapshots and curated Scenario testing","description":"The current testing pattern relies heavily on `insta` YAML snapshots. While useful, these can be opaqueâ€”a failure shows a diff in a serialized data structure rather than the relationship between the source code and the resulting error. Following the pattern used in `ruff/ty`, the project should move toward \"Scenario\" tests where the snapshot renders the source and diagnostics together.\n\n## Proposal\nImplement a \"Scenario Runner\" and a diagnostic renderer that produces readable, self-documenting snapshots.\n\n## Technical Requirements\n1.  **Diagnostic Renderer**:\n    *   Create a text renderer (e.g., using `annotate-snippets` or `miette`) that maps `ValidationError` byte offsets back to the source code.\n    *   The output should show the relevant lines of the template or Python file with inline error markers.\n2.  **Scenario Test Helper**:\n    *   Define a `Scenario` struct in `djls-test` that allows declarative test setup:\n        ```rust\n        let scenario = Scenario::new()\n            .with_file(\"app/tags.py\", python_source)\n            .with_file(\"app/index.html\", \"{% load tags %}\")\n            .with_dependencies(&[\"django==5.1\"]);\n        \n        insta::assert_snapshot!(scenario.run_validation());\n        ```\n3.  **\"Golden\" Snippet Migration**:\n    *   Transition away from \"bulk snapshots\" for the corpus. The corpus should be used primarily for \"panic/smoke\" testing.\n    *   Extract the most complex or regression-prone templatetags from the ecosystem (e.g., `sekizai`, `crispy_forms`) into curated, targeted Scenario tests.\n4.  **Markdown Integration**:\n    *   Explore the ability to parse these scenarios directly from Markdown files, allowing for easier contribution of test cases and better readability.\n\n> Braindump by @joshuadavidthomas, issue captured and created by Gemini 3 Flash","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":400,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/400","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:09.557Z","updated_at":"2026-02-11T20:55:09.990Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"vpxani2s","parent_id":"nrcdb189","name":"Stdin support","description":"Add support for piping template content via stdin.\n\n## Behavior\n\nDetect `!std::io::stdin().is_terminal()`:\n- Read all of stdin into a string\n- Create an in-memory file (use a synthetic path like `<stdin>`)\n- Run through the same parse â†’ validate â†’ collect pipeline\n- Print diagnostics and exit\n\nNo explicit flag needed â€” stdin is detected automatically. This should be integrated into the file discovery step of `Check::execute()`: if stdin is not a terminal, read it as a single template before checking any path arguments.\n\n## Example\n\n```bash\necho '{% if %}' | djls check\ncat template.html | djls check\n```\n\n## Acceptance Criteria\n\n- Piped input is detected and checked as a single template\n- Diagnostics reference `<stdin>` as the file path\n- Exit code reflects whether errors were found in the piped content\n- Non-terminal stdin takes priority over path arguments (or works alongside them â€” decide during implementation)\n- `cargo build -q` passes","priority":1,"completed":true,"result":"Stdin support via InMemoryFileSystem when stdin is not a terminal and no paths given","metadata":null,"created_at":"2026-02-11T17:55:02.335Z","updated_at":"2026-02-11T19:19:34.385Z","started_at":"2026-02-11T19:19:34.381Z","completed_at":"2026-02-11T19:19:34.385Z","blockedBy":["idbcwda3"],"blocks":[],"children":[]}
{"id":"wdwd7t2z","parent_id":null,"name":"Widen extraction to catch any uncaught exception in templatetag functions","description":"Currently `djls-python` extraction only looks for `if condition: raise TemplateSyntaxError(...)` guard patterns when extracting validation rules from templatetag compilation functions. But not every templatetag raises `TemplateSyntaxError` â€” at least one corpus entry raises `ValueError` instead.\n\nWe should widen extraction to handle any exception raised and not caught within either a templatetag function or a `Node` class. If the raise is uncaught within the function body, it's effectively a validation constraint, regardless of the exception type.\n\nThis would catch more real-world validation patterns and reduce false negatives in argument checking.","priority":1,"completed":true,"result":"Widened extraction to match any uncaught exception, not just TemplateSyntaxError.\n\nChanges in 3 files:\n- rules.rs: Renamed body_raises_template_syntax_error â†’ body_raises_exception, removed is_template_syntax_error_call, RaiseFinder now matches any Stmt::Raise with exc: Some(_)\n- match_arms.rs: Renamed any_path_raises_template_syntax_error â†’ any_path_raises_exception, same widened matching\n- mutations.rs: Updated call site for option loop else-branch detection\n\nAdded 6 new tests: non_template_syntax_error_extracted, qualified_exception_extracted, type_error_extracted, runtime_error_extracted, bare_raise_not_extracted, mixed_exception_types\n\nAll 675 workspace tests pass, no snapshot changes needed. Clippy, fmt, lint all clean.","metadata":{"commit":{"sha":"53aedfd2","message":"Widen extraction to catch any uncaught exception in templatetag functions","branch":"widen-extraction-uncaught-exceptions","timestamp":"2026-02-13T16:56:28.080Z"},"github":{"issueNumber":436,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/436","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-13T07:07:18.667Z","updated_at":"2026-02-13T16:56:29.875Z","started_at":"2026-02-13T16:56:28.086Z","completed_at":"2026-02-13T16:56:28.088Z","blockedBy":[],"blocks":[],"children":[]}
