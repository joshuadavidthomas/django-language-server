{"id":"0juup8cz","parent_id":null,"name":"Add dedicated Development section to README","description":"Keep the section in Contributing, but trim it down to the wants and point to the new section. It should have basics of how to get setup, architecture, maybe design decisions, areas that need help.","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":38,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/38","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:12.310Z","updated_at":"2026-02-11T20:55:01.274Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"345qt6ov","parent_id":null,"name":"Set up local flamegraph profiling for benchmarks","description":"## Goal\n\nGenerate collapsed-stack flamegraph profiles from djls-bench benchmarks locally, producing text-based output that can be analyzed in-session (not just CodSpeed's web-only flamegraphs).\n\n## Current State\n\n- `flamegraph` (0.6.9) and `perf` (6.18) are installed\n- `perf_event_paranoid=2` â€” userspace profiling works\n- Bench binaries are at `target/release/deps/{name}-{hash}`\n- divan filters are positional args: `./bench-binary \"filter_name\"`\n- No `[profile.bench]` in Cargo.toml â€” need `CARGO_PROFILE_BENCH_DEBUG=2` env var for symbols (without it, stacks show `[unknown]`)\n- Quick test confirmed: building with debug info produces `[optimized + debuginfo]`, perf record works\n\n## Approach\n\n1. **Add a `just profile` recipe** that:\n   - Builds the specified bench with debug info (`CARGO_PROFILE_BENCH_DEBUG=2`)\n   - Runs `perf record -g --call-graph dwarf` on the bench binary with an optional filter\n   - Converts to collapsed stacks via `perf script | inferno-collapse-perf` (or `flamegraph`'s internal pipeline)\n   - Outputs both the collapsed stacks text file AND an SVG flamegraph\n   - Stores results in a gitignored `profiles/` directory\n\n2. **Install `inferno`** (`cargo install inferno`) for the `inferno-collapse-perf` tool to produce collapsed stacks text from perf data â€” this is the key format for text-based analysis\n\n3. **Add `profiles/` to .gitignore**\n\n4. **Add `[profile.bench]` to Cargo.toml** with `debug = 2` so we don't need the env var trick every time (or decide against this if it bloats CI)\n\n## Acceptance Criteria\n\n- `just profile parser parse_template` (or similar) produces:\n  - `profiles/parser-parse_template.collapsed` â€” text file of collapsed stacks\n  - `profiles/parser-parse_template.svg` â€” flamegraph SVG\n- Collapsed stacks file is readable text like `main;run_check;parse_template;tokenize 4500`\n- Works on Linux with perf_event_paranoid=2\n- `profiles/` is gitignored\n- Documented in justfile comments","priority":1,"completed":true,"result":"Implemented local flamegraph profiling:\n\n- Added `.just/profiling.just` with `just prof profile <bench> [filter]` recipe\n- Recipe builds bench with debug info, runs `perf record -g --call-graph dwarf`, pipes through `inferno-collapse-perf` and `inferno-flamegraph`\n- Produces `profiles/<label>.collapsed` (text) and `profiles/<label>.svg` (flamegraph)\n- Cleans up intermediate `perf.data` automatically\n- Added `just prof clean` to remove all profiling artifacts\n- Added `[profile.bench] debug = 2` to root `Cargo.toml` for symbolized stacks\n- Added `profiles/` to `.gitignore`\n- Dependency check (`_ensure-deps`) validates `perf`, `inferno-collapse-perf`, and `jq` are available\n\nVerified: `just prof profile parser parse_template` produces both collapsed stacks and SVG with resolved Rust symbols (e.g. `djls_templates::quotes::split_on_whitespace`).","metadata":{"commit":{"sha":"6c32c017","message":"Add local flamegraph profiling for benchmarks","branch":"feat/flamegraph-profiling","timestamp":"2026-02-12T19:39:34.302Z"},"github":{"issueNumber":416,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/416","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-12T02:13:34.276Z","updated_at":"2026-02-12T19:39:35.732Z","started_at":"2026-02-12T19:39:34.307Z","completed_at":"2026-02-12T19:39:34.308Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"5fpcimiy","parent_id":"tv03enep","name":"Diagnostic rendering engine","description":"Implement a shared diagnostic rendering engine that produces human-readable output with source context snippets and error pointers. This is tracked upstream as issue #397 and is a prerequisite for the check command's text output.\n\n## What\n\nA generic renderer in `djls-source` that takes source-level primitives and produces annotate-snippets-style output:\n\n```rust\nrender_diagnostic(source, span: Span, line_index: &LineIndex, code, message, severity)\n```\n\n## Why\n\n- The check command needs rich terminal output for its `text` format\n- Snapshot tests in `djls-semantic` currently show raw struct output â€” the renderer in plain mode makes them much more readable\n- `djls-source` already owns `Span`, `LineIndex`, `Offset`, `LineCol` â€” the renderer is the presentation side of these types\n\n## Approach\n\n1. **Evaluate rendering crates**: `annotate-snippets` (preferred for alignment with Ruff/ty), `miette`, and `ariadne` are candidates. Build a small proof-of-concept with one `ValidationError` variant.\n2. **Implement renderer**: Generic over any diagnostic, not tied to `ValidationError`. Two modes: rich (colors, underlines) for terminal and plain (deterministic) for snapshot files.\n3. **Adopt in snapshot tests**: Update `djls-semantic` snapshot tests to use the renderer in plain mode. Run `cargo insta test --accept --unreferenced delete`.\n\n## Placement\n\nLives in `djls-source` â€” the renderer is generic and `djls-source` already owns the coordinate types. Future: if diagnostics grow beyond rendering, extract to `djls-diagnostic`.\n\n## Acceptance Criteria\n\n- Renderer produces annotate-snippets-style output with source context, error pointers, and diagnostic codes\n- Two modes work: rich (colors) and plain (deterministic)\n- `djls-semantic` snapshot tests updated to use plain mode and are more readable\n- `cargo test -q` passes, `cargo insta test --accept --unreferenced delete` clean","priority":1,"completed":true,"result":"Diagnostic rendering engine complete: selected annotate-snippets, implemented DiagnosticRenderer in djls-source with plain/styled modes, and adopted renderer in all semantic snapshot tests.","metadata":null,"created_at":"2026-02-11T17:53:37.211Z","updated_at":"2026-02-11T18:35:50.552Z","started_at":"2026-02-11T18:35:50.551Z","completed_at":"2026-02-11T18:35:50.552Z","blockedBy":[],"blocks":["nrcdb189"],"children":["v6f7la9a","o8q4kj8g","aganrncf"]}
{"id":"aganrncf","parent_id":"5fpcimiy","name":"Adopt renderer in semantic snapshot tests","description":"Update `djls-semantic` snapshot tests to use the new diagnostic renderer in plain mode instead of raw struct output.\n\n## Approach\n\n- At each snapshot test call site, extract span/code/message from `ValidationError` and pass to the renderer's plain mode\n- Run `cargo insta test --accept --unreferenced delete` to regenerate all snapshots\n- Verify new snapshots are more readable: show source context lines, error pointers, and diagnostic codes\n\n## Acceptance Criteria\n\n- All `djls-semantic` snapshot tests use the renderer in plain mode\n- Snapshots show source context with error pointers (not raw struct Debug output)\n- `cargo insta test --accept --unreferenced delete` is clean (no orphan snapshots)\n- `cargo test -q` passes","priority":1,"completed":true,"result":"Replaced hand-rolled diagnostic rendering with DiagnosticRenderer::plain() from djls-source. Removed primary_span, error_kind, error_detail_lines helpers. Snapshots now use annotate-snippets format with error codes, source context, and caret pointers. All 112 non-corpus tests pass, clippy clean.","metadata":null,"created_at":"2026-02-11T17:54:08.485Z","updated_at":"2026-02-11T18:35:45.768Z","started_at":"2026-02-11T18:35:45.767Z","completed_at":"2026-02-11T18:35:45.768Z","blockedBy":["o8q4kj8g"],"blocks":[],"children":[]}
{"id":"d4cmwfgd","parent_id":null,"name":"Add diagnostic code pages to documentation","description":"This came up in #339 but the diagnostic codes are not documented anywhere, you have to look in the source to see them:\n\nhttps://github.com/joshuadavidthomas/django-language-server/blob/d5d43ad395f8771a7386d7c970ec78ba16e6ab66/crates/djls-ide/src/diagnostics.rs#L70-L81\n\nThere should be either a page with all of them listed (like djlint has for it's codes), or maybe like ruff a dedicated page for each code. Dedicated pages would be a bit more work, but probably worth it in the long run? Linkability and being able to provide examples -- though I suppose you could achieve that with a single page too, so ðŸ¤·.","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":343,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/343","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:11.650Z","updated_at":"2026-02-11T20:55:02.334Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"f4rd8nq1","parent_id":"nrcdb189","name":"Integration test","description":"Add a basic integration test for the `djls check` command.\n\n## Approach\n\nCreate a test that:\n1. Creates a temp directory with template files containing known errors (e.g., unclosed tags for S100, unbalanced structure for S101)\n2. Runs `djls check <dir>` as a subprocess (or invokes the check logic directly if that's simpler)\n3. Asserts exit code is 1 (errors found)\n4. Asserts output contains expected error codes (S100, S101, etc.)\n5. Also test the clean case: a valid template directory â†’ exit code 0\n\n## Placement\n\nAdd to existing test infrastructure. Per AGENTS.md: \"NEVER write standalone test files â€” always add test cases to existing test modules in the codebase.\" Find the appropriate test module in `crates/djls/` or add an integration test that makes sense for the binary crate.\n\n## Acceptance Criteria\n\n- At least one test for error case (exit code 1, expected error codes in output)\n- At least one test for clean case (exit code 0, no errors)\n- Tests pass in CI: `cargo test -q`","priority":1,"completed":true,"result":"5 integration tests: clean exit, broken exit, --ignore, stdin, empty dir","metadata":null,"created_at":"2026-02-11T17:55:12.239Z","updated_at":"2026-02-11T19:20:50.381Z","started_at":"2026-02-11T19:20:50.379Z","completed_at":"2026-02-11T19:20:50.381Z","blockedBy":["idbcwda3"],"blocks":[],"children":[]}
{"id":"h655pvnc","parent_id":"nrcdb189","name":"Template file walker","description":"Add a template file walker to `djls-db` (which already depends on `djls-source` for `FileKind`).\n\n## API\n\n```rust\npub fn walk_template_files(paths: &[Utf8PathBuf]) -> Vec<Utf8PathBuf>\n```\n\n## Behavior\n\n- Recursively walk directories, filter by `FileKind::Template` extensions (`.html`, `.htm`, `.djhtml`)\n- For single files, check the extension and include directly\n- Uses `walkdir` or `ignore` crate for efficient directory traversal (add to `[workspace.dependencies]`)\n- Uses `camino::Utf8Path`/`Utf8PathBuf` as canonical path types per project convention\n\n## Acceptance Criteria\n\n- Function walks directories recursively and returns only template files\n- Single file paths are validated and returned if they match template extensions\n- Non-existent paths produce clear errors\n- Unit tests cover: directory walk, single file, mixed paths, non-template files filtered out\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":true,"result":"Implemented walk_template_files in djls-db/src/walk.rs with walkdir, FileKind filtering, hidden dir skipping, dedup","metadata":null,"created_at":"2026-02-11T17:54:32.600Z","updated_at":"2026-02-11T19:19:33.874Z","started_at":"2026-02-11T19:19:33.872Z","completed_at":"2026-02-11T19:19:33.874Z","blockedBy":[],"blocks":["idbcwda3"],"children":[]}
{"id":"idbcwda3","parent_id":"nrcdb189","name":"Check orchestration","description":"Wire up the core check pipeline in `Check::execute()`. This is the main orchestration logic.\n\n## Implementation\n\nIn `Check::execute()`:\n1. Resolve project root (cwd)\n2. Load `Settings::new(root, None)`, merge `--select`/`--ignore` into `DiagnosticsConfig`\n3. Create file system: `Arc::new(djls_workspace::OsFileSystem)` (no overlay needed â€” reads from disk only)\n4. Create `djls_db::DjangoDatabase::new(fs, settings, project_root)`\n5. Determine files:\n   - If `self.paths` is non-empty â†’ `walk_template_files(&self.paths)`\n   - Else â†’ `template_dirs(db, project)` then walk those\n6. For each file: `db.get_or_create_file(path)`, `parse_template(db, file)`, `validate_nodelist(db, nodelist)`, `collect_diagnostics(db, file, nodelist)`\n7. Convert diagnostics to rendered text via the rendering engine\n8. Print to stdout, return appropriate exit code\n\n## Exit Codes\n\n- `0` â€” no errors (warnings/hints don't count)\n- `1` â€” one or more errors found\n- `2` â€” invocation error (bad args, project not found, etc.)\n\nMap to the existing `Exit` type in `crates/djls/src/exit.rs`.\n\n## Acceptance Criteria\n\n- `djls check templates/` runs the full pipeline and prints diagnostics\n- `djls check` (no args) discovers templates via Django inspector\n- `--select`/`--ignore` correctly filter diagnostic output\n- Exit codes are correct: 0 for clean, 1 for errors, 2 for bad invocation\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":true,"result":"Full orchestration: resolve project root, load settings, create DjangoDatabase, walk files, parse+validate+render diagnostics, exit codes","metadata":null,"created_at":"2026-02-11T17:54:53.512Z","updated_at":"2026-02-11T19:19:34.127Z","started_at":"2026-02-11T19:19:34.126Z","completed_at":"2026-02-11T19:19:34.127Z","blockedBy":["h655pvnc","juhz0yg8"],"blocks":["vpxani2s","f4rd8nq1"],"children":[]}
{"id":"iyh1yvx1","parent_id":null,"name":"Adopt unified Markdown format for all snapshot tests","description":"Many unit tests in `djls-semantic` (specifically in `filters/validation.rs` and `loads/validation.rs`) currently rely on hand-written `matches!` assertions. This makes tests difficult to maintain and provides poor visibility into what the error actually looks like to a user. We should migrate these to a unified snapshot format that renders the input template and the resulting diagnostics together.\n\n### Goals\n- Improve test readability and maintainability.\n- Provide \"visual\" confirmation of diagnostic placement in templates.\n\n### Requirements\n- **Markdown Format:** The snapshot should use a Markdown-friendly format.\n  - Section 1: The input Django template (as a code block).\n  - Section 2: The rendered diagnostics (generated by the renderer from Issue #397).\n- **Test Helper:** Implement a `snapshot_validate(source: &str)` helper in `crates/djls-semantic/src/testing.rs` that encapsulates the parsing, validation, rendering, and `insta::assert_snapshot!` call.\n- **Migration:**\n  - Convert `crates/djls-semantic/src/lib.rs` corpus tests.\n  - Convert `crates/djls-semantic/src/filters/validation.rs` tests.\n  - Convert `crates/djls-semantic/src/loads/validation.rs` tests.\n\n### Dependency\nThis issue depends on the implementation of the diagnostic renderer (#397).\n\n> Braindump by @joshuadavidthomas, issue captured and created by Gemini 3 Flash","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":398,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/398","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:44:53.615Z","updated_at":"2026-02-11T20:55:03.351Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"juhz0yg8","parent_id":"nrcdb189","name":"CLI arg parsing and command registration","description":"Add the `check` subcommand to the CLI binary.\n\n## Implementation\n\nCreate `crates/djls/src/commands/check.rs`:\n\n```rust\n#[derive(Debug, Parser)]\npub struct Check {\n    /// Files or directories to check. If omitted, discovers from Django template directories.\n    paths: Vec<PathBuf>,\n\n    /// Select specific diagnostic codes to enable\n    #[arg(long)]\n    select: Vec<String>,\n\n    /// Ignore specific diagnostic codes\n    #[arg(long)]\n    ignore: Vec<String>,\n}\n```\n\nRegister in `commands.rs` as `DjlsCommand::Check(check::Check)`.\n\n## Acceptance Criteria\n\n- `djls check --help` shows usage with paths, --select, --ignore\n- `djls check` (no args) is a valid invocation\n- `djls check templates/ --select S100 --ignore S108` parses correctly\n- Command is wired into the existing CLI dispatch but can initially just print \"not implemented\" or similar\n- `cargo build -q` passes","priority":1,"completed":true,"result":"Added Check struct with clap args (paths, --select, --ignore) and registered in DjlsCommand enum","metadata":null,"created_at":"2026-02-11T17:54:41.858Z","updated_at":"2026-02-11T19:19:33.619Z","started_at":"2026-02-11T19:19:33.617Z","completed_at":"2026-02-11T19:19:33.619Z","blockedBy":[],"blocks":["idbcwda3"],"children":[]}
{"id":"nrcdb189","parent_id":"tv03enep","name":"Implement djls check command","description":"Implement the `djls check` CLI command that walks template files on disk, runs the parse â†’ validate â†’ collect pipeline, formats diagnostics, and exits with an appropriate code.\n\n## Architecture\n\n```\ncrates/djls/src/commands/check.rs    â† CLI args, orchestration\n                                       Uses DjangoDatabase from djls-db\n                                       Walks files, runs pipeline, formats output\n```\n\n## Flow\n\n1. Parse CLI args (paths, --select, --ignore)\n2. Resolve project root (cwd or explicit)\n3. Load settings (pyproject.toml / djls.toml)\n4. Create DjangoDatabase (with OsFileSystem, settings, project_path)\n5. Determine files to check:\n   a. If paths given â†’ walk and filter by FileKind::Template\n   b. If no paths â†’ query template_dirs via inspector, walk those\n6. For each template file: parse_template â†’ validate_nodelist â†’ collect_diagnostics\n7. Format and print diagnostics via rendering engine\n8. Exit with appropriate code (0=clean, 1=errors, 2=invocation error)\n\n## Key Decisions\n\n- Two discovery modes: explicit paths and auto-discovery via inspector\n- Text output only at launch (uses rendering engine from Phase 2)\n- Stdin support: detect piped input automatically\n- Exit codes follow ruff/ty convention\n\n## Acceptance Criteria\n\n- `djls check templates/` checks all template files in the given directory\n- `djls check` (no args) discovers templates via Django inspector\n- `--select` and `--ignore` filter diagnostic codes\n- Stdin piping works: `echo '{% if %}' | djls check -`\n- Exit code 0 when no errors, 1 when errors found, 2 on invocation error\n- Integration test verifies basic functionality","priority":1,"completed":true,"result":"All subtasks complete: CLI, walker, orchestration, stdin, integration tests","metadata":null,"created_at":"2026-02-11T17:54:23.016Z","updated_at":"2026-02-11T19:20:50.635Z","started_at":"2026-02-11T19:20:50.633Z","completed_at":"2026-02-11T19:20:50.635Z","blockedBy":["5fpcimiy"],"blocks":[],"children":["h655pvnc","juhz0yg8","idbcwda3","vpxani2s","f4rd8nq1"]}
{"id":"o8q4kj8g","parent_id":"5fpcimiy","name":"Implement diagnostic renderer in djls-source","description":"Implement the diagnostic renderer in `crates/djls-source/` using `annotate-snippets` (0.12, selected in prior subtask evaluation).\n\n## API\n\n```rust\nrender_diagnostic(source: &str, span: Span, line_index: &LineIndex, code: &str, message: &str, severity: DiagnosticSeverity) -> String\n```\n\n## Requirements\n\n- Generic over any diagnostic â€” not tied to `ValidationError` specifically\n- Uses `annotate-snippets` with ASCII decor style (ty/ruff style) as default\n- Two output modes:\n  - **Rich**: `Renderer::styled()` â€” ANSI colors for terminal display\n  - **Plain**: `Renderer::plain()` â€” no colors, deterministic for snapshot test files\n- Maps byte offsets from `Span` to line/column via `djls_source::LineIndex` for the `Snippet::line_start()` call\n- `annotate-snippets` handles the rest: source context, `^^^` underlines, `error[CODE]:` headers, line numbers\n- Add `annotate-snippets = { workspace = true }` to `djls-source/Cargo.toml`\n\n## Key annotate-snippets patterns (from evaluation)\n\n```rust\nuse annotate_snippets::{AnnotationKind, Level, Renderer, Snippet};\n\nlet report = &[Level::ERROR\n    .primary_title(\"Unclosed tag: block\")\n    .id(\"S100\")\n    .element(\n        Snippet::source(source)\n            .path(filename)\n            .line_start(1)\n            .annotation(\n                AnnotationKind::Primary\n                    .span(start..end)\n                    .label(\"this block tag is never closed\"),\n            ),\n    )];\n\nlet renderer = Renderer::plain(); // or Renderer::styled()\nlet output = renderer.render(report).to_string();\n```\n\nSupports: single-line spans, multi-annotation same line, multi-annotation different lines, notes/info footer, warning level, long line truncation.\n\n## Acceptance Criteria\n\n- Renderer produces ty-style output with source context lines, `^^^` underlines, and `error[CODE]:` headers\n- Both rich and plain modes produce correct output\n- Unit tests cover representative error shapes (single-line span, two annotations, long line)\n- `cargo build -q` and `cargo test -q` pass","priority":1,"completed":true,"result":"Implemented DiagnosticRenderer in `crates/djls-source/src/render.rs` using `annotate-snippets` 0.12.\n\n## What was built\n\n- `Diagnostic` struct â€” collects source, path, code, message, severity, annotations, and notes\n- `DiagnosticRenderer` â€” `plain()` and `styled()` constructors, `render(&Diagnostic) -> String`\n- `DiagnosticAnnotation` â€” primary (`^^^`) or context (`---`) span labels\n- `Severity` enum â€” Error, Warning, Info, Hint (maps to annotate-snippets Level)\n- Builder pattern: `Diagnostic::new(...).annotation(...).note(...)`\n\n## Public API\n\n```rust\npub use djls_source::{Diagnostic, DiagnosticAnnotation, DiagnosticRenderer, Severity};\n```\n\n## Tests (8 passing)\n\n- `single_line_span` â€” basic error with `^^^` underline\n- `two_annotations_different_lines` â€” primary + context on separate lines\n- `two_annotations_same_line` â€” two annotations on same source line\n- `with_note` â€” `= note:` footer\n- `warning_severity` â€” `warning[W001]` header\n- `long_line_truncation` â€” `...` prefix on long lines\n- `styled_produces_ansi` â€” ANSI escape codes present\n- `plain_no_ansi` â€” no ANSI escape codes\n\n## Verification\n\n- `cargo build -q` â€” clean\n- `cargo clippy -q --all-targets --all-features -- -D warnings` â€” clean\n- `cargo test -q -p djls-source` â€” 18 tests pass (10 existing + 8 new)\n- All workspace test failures are pre-existing corpus sync issues (same 86 on main)","metadata":{"commit":{"sha":"96d9eee1","message":"Add diagnostic renderer to djls-source","branch":"josh/diagnostic-rendering-engine","timestamp":"2026-02-11T18:28:35.821Z"}},"created_at":"2026-02-11T17:53:54.219Z","updated_at":"2026-02-11T18:28:35.823Z","started_at":"2026-02-11T18:28:35.822Z","completed_at":"2026-02-11T18:28:35.823Z","blockedBy":["v6f7la9a"],"blocks":["aganrncf"],"children":[]}
{"id":"qqc92r00","parent_id":null,"name":"Create `djls-test` crate and implement targeted environment ingestion","description":"Redundancy exists within the current test suite: nearly every module in `djls-semantic` maintains its own ~60-line Salsa `TestDatabase` implementation. Furthermore, to address #398, there is a requirement to test against specific Django versions and third-party apps (e.g., `django-crispy-forms`) without the overhead of syncing entire repositories into a bulk `.corpus`.\n\n## Proposal\nCreate a dedicated `djls-test` crate to serve as the unified infrastructure for all workspace testing. This crate will implement a \"targeted\" environment strategy inspired by the patterns found in `ruff/ty`.\n\n## Technical Requirements\n1.  **Unified `TestDatabase`**:\n    *   A single, robust Salsa database implementation that satisfies all crate-level `Db` traits (`djls_source`, `djls_templates`, `djls_semantic`, `djls_project`).\n    *   Integration with an `InMemoryFileSystem` to allow writing virtual files for unit testing.\n2.  **Venv Ingester (The `uv` Bridge)**:\n    *   Implement logic to execute `uv sync` in a temporary directory based on a provided list of dependencies.\n    *   **Site-Package Ingestion**: Recursively copy the resulting `site-packages` into the Salsa `InMemoryFileSystem`. \n    *   *Optimization*: Only copy `.py` and `.pyi` files (skip binaries and `__pycache__`) to keep the test DB lightweight.\n3.  **Migration**:\n    *   Migrate `djls-semantic` and `djls-python` unit tests to use this shared infrastructure.\n    *   Refactor the corpus \"smoke test\" to be a standard `#[test]` that uses this database to build extraction specs on the fly.\n\n> Braindump by @joshuadavidthomas, issue captured and created by Gemini 3 Flash","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":399,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/399","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:10.258Z","updated_at":"2026-02-11T20:55:04.384Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"r7y9s5n1","parent_id":null,"name":"Environment variables needed by settings loading","description":"I'm new to LSP, having previously used editors without it, and am having some issues with using django-language-server in Zed via its Django extension. I'm not sure if this is a missing feature or something that I just don't know how to do.\n\nI typically run my Django projects containerized, and specify some environment variables in `docker-compose.yml` to be passed to my Django process inside the container. Among these is `DJANGO_SECRET_KEY`. In my settings file, I use `SECRET_KEY = os.environ[\"DJANGO_SECRET_KEY\"]`. (I mount the code dir from the host to the container, so I can edit it on the host.)\n\nI've got `debug = true` in my `pyproject.toml` under `[tool.djls]`, and in the language server debug logs are these rows (among others):\n\n```\nInspector query 'django_init' returned ok=false, error=Some(\"'DJANGO_SECRET_KEY'\")\ntemplatetags(Id(0)): executing query\nInspector query 'templatetags' returned ok=false, error=Some(\"'DJANGO_SECRET_KEY'\")\ntemplate_dirs(Id(0)): executing query\nInspector query 'template_dirs' returned ok=false, error=Some(\"'DJANGO_SECRET_KEY'\")\n```\n\nWhat I don't understand is how to pass this and any other environment variables needed for settings loading to django-language-server with any mechanism, be it `pyproject.toml` or the `initialization_options` object in Zed's `settings.json`. Is it possible? I've looked at the docs for Zed, the Django extensions AND django-language-server, but have either missed something, or it's not described there.","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":378,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/378","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:10.967Z","updated_at":"2026-02-11T20:55:05.510Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"tv03enep","parent_id":null,"name":"djls check â€” standalone CLI template checker","description":"A standalone CLI command that walks template files on disk, runs the same parse â†’ validate â†’ collect pipeline that the LSP uses, and prints diagnostics to the terminal with an appropriate exit code. Think `ruff check` or `ty check` but for Django templates.\n\n```\ndjls check [PATHS...] [--select S100,S101] [--ignore S108]\n```\n\n## Background\n\nThe validation pipeline is already well-factored across crates. The check command is a new *consumer* of existing infrastructure (parsing, validation, diagnostic collection, severity filtering), not a rewrite. Phase 1 (extracting `djls-db` crate) already landed in PR #402, making the concrete database reusable by both the LSP server and CLI.\n\n## Remaining Work\n\nTwo phases remain:\n1. **Diagnostic rendering engine** (#397) â€” `annotate-snippets`-style rich terminal output, lives in `djls-source`, used by both snapshot tests and the check command's text formatter.\n2. **`djls check` command** â€” CLI arg parsing, template file walking, database initialization, pipeline orchestration, exit codes.\n\n## Key Design Decisions\n\n- **Database**: `djls-db` crate (already extracted) sits above all Salsa trait layers\n- **File discovery**: Both explicit paths and auto-discovery via Django inspector\n- **Output format**: `text` only at launch (rich snippets via rendering engine); `concise`, `json`, `github` added later\n- **Exit codes**: 0 (clean), 1 (errors), 2 (invocation error) â€” ruff/ty convention\n- **Inspector**: Default full inspector for project-aware discovery; explicit paths bypass template dir discovery\n\n## Reference\n\n- RESEARCH.md â€” complete chain analysis of template validation pipeline\n- PLAN.md â€” full design plan with architecture, flow, and implementation details\n- PR #402 â€” Phase 1 (djls-db extraction) already landed\n- Issue #397 â€” diagnostic rendering engine tracking issue","priority":1,"completed":true,"result":"Phase 3 complete: djls check command implemented with file walking, rendering, stdin, select/ignore, exit codes","metadata":{"github":{"issueNumber":406,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/406","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T17:53:21.660Z","updated_at":"2026-02-11T20:55:06.945Z","started_at":"2026-02-11T19:20:50.886Z","completed_at":"2026-02-11T19:20:50.891Z","blockedBy":[],"blocks":[],"children":["5fpcimiy","nrcdb189"]}
{"id":"u8nreg2u","parent_id":null,"name":"Replace Python inspector subprocess with static settings extraction","description":"Replace the inspector subprocess â€” which spawns a Python process, runs `django.setup()`, and introspects the live runtime over JSON-over-stdin/stdout â€” with static extraction from files on disk. Parse `settings.py` with Ruff's Python AST (the same approach used for template tag/filter validation rule extraction), resolve apps and template libraries from the filesystem, and eliminate the need for a working Django runtime entirely.\n\n## Motivation\n\nThe inspector is the single biggest source of deployment friction and runtime complexity:\n\n- **Requires a working Python environment** where `import django` succeeds and `django.setup()` completes without error. Missing dependencies, environment variables, or database connections cause silent failures (#378).\n- **Environment variable propagation** is a recurring pain point â€” users must configure their editor to pass `DJANGO_SECRET_KEY` and similar variables through to the LSP binary just to get basic functionality.\n- **Process lifecycle management** adds complexity: long-lived subprocess, stdin/stdout IPC, idle timeouts, graceful shutdown, temp file cleanup for the embedded zipapp.\n- **Build-time Python dependency**: the zipapp is compiled via `python -m zipapp` in `build.rs` and embedded via `include_bytes!`, requiring Python available at `cargo build` time.\n- **All-or-nothing degradation**: if `django.setup()` fails, the inspector returns zero information. There's no partial success.\n\nStatic extraction eliminates all of this. The LSP server becomes a fully self-contained binary that reads files on disk â€” no Python subprocess, no runtime dependency, no environment variable juggling.\n\n## What the inspector currently provides\n\n| Query | Data | Consumer |\n|---|---|---|\n| `django_init` | Whether `django.setup()` succeeded | Gate for other queries |\n| `template_dirs` | Template directories from `settings.TEMPLATES` | File discovery, goto-definition |\n| `template_libraries` | Enabled libraries, builtins, tag/filter symbols with modules and docstrings | Completions, diagnostics, semantic analysis |\n\n`django_init` only exists because the other queries need it. The real value is `template_dirs` and `template_libraries`.\n\n## Approach\n\nThe same pattern that worked for validation rule extraction: parse Python source with Ruff's AST, follow references, assemble the picture. We'd replicate what Django does internally â€” but from the outside looking in.\n\n### What Django does at runtime\n\n1. **App loading**: reads `INSTALLED_APPS`, imports each module, discovers `templatetags/` packages\n2. **Engine initialization**: autodiscovers template libraries from installed apps, applies `OPTIONS.libraries` and `OPTIONS.builtins` from `TEMPLATES` config, prepends Django's default builtins\n3. **Template dirs**: reads `TEMPLATES[*]['DIRS']`, appends `<app>/templates/` for each app when `APP_DIRS` is set\n\n### What we'd do statically\n\n1. **Parse `settings.py`** â€” extract `INSTALLED_APPS` (list of strings), `TEMPLATES` (dict structure) via AST walking. For split settings (`from .base import *` + `INSTALLED_APPS += [...]`), follow the import chain.\n2. **Resolve apps** â€” given each `INSTALLED_APPS` entry, resolve to a directory via existing `resolve_module()`. For `AppConfig` paths, parse `apps.py` to read the `name` attribute.\n3. **Build `TemplateLibraries`** â€” filter existing `discover_template_libraries()` output to apps in `INSTALLED_APPS`, apply explicit `libraries`/`builtins` from settings, add Django's well-known default builtins.\n4. **Compute template dirs** â€” `DIRS` from settings + `<app>/templates/` when `APP_DIRS` is set.\n\nMost of the infrastructure already exists: `discover_template_libraries()`, `resolve_module()`, `build_search_paths()`, `collect_registrations_from_source()`, and the Ruff parser.\n\n### Coverage tiers\n\n| Tier | Pattern | Coverage |\n|---|---|---|\n| 1 | Literal `INSTALLED_APPS`/`TEMPLATES` in a single settings file | ~80% |\n| 2 | Split settings (`from .base import *` + `+=`), `BASE_DIR` resolution, `AppConfig` paths | ~95% |\n| 3 | `django-environ`, `django-split-settings`, fully dynamic | Deferred |\n\nWhen extraction can't determine a value, each field degrades independently:\n- Can't parse `INSTALLED_APPS` â†’ all discovered libraries treated as potentially active\n- Can't parse `TEMPLATES` â†’ use Django's default builtins, no explicit libraries\n- Can't resolve an app â†’ skip it, continue with others\n\nThis is strictly better than the inspector's all-or-nothing failure mode.\n\n## Implementation plan\n\n1. **Settings extraction module** â€” parse `settings.py`, extract `INSTALLED_APPS` and `TEMPLATES` as structured data (Tier 1: literal lists)\n2. **App resolution** â€” resolve `INSTALLED_APPS` entries to directories\n3. **Static `TemplateLibraries` assembly** â€” combine settings + discovery + default builtins\n4. **Wire in as primary path** â€” replace `refresh_inspector()`, keep inspector as temporary fallback\n5. **Tier 2 extraction** â€” split settings, `BASE_DIR`, `AppConfig` paths\n6. **Static template dirs**\n7. **Integration tests** against corpus projects\n8. **Remove inspector** â€” delete subprocess, zipapp, build-time Python dependency\n\nDetailed design: [`PLAN-static-inspector.md`](https://gist.github.com/joshuadavidthomas/2b0da62c56d8aaba240f33cef936b19a)\n\n## Related\n\n- #378 â€” Environment variables needed by settings loading (this is the exact user-facing pain point that static extraction eliminates)\n\n> Braindump by @joshuadavidthomas, issue captured and created by Claude Opus 4.6","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":401,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/401","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:08.849Z","updated_at":"2026-02-11T20:55:08.049Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"v6f7la9a","parent_id":"5fpcimiy","name":"Evaluate and select rendering crate","description":"Evaluate `annotate-snippets`, `miette`, and `ariadne` for diagnostic rendering. Build a small proof-of-concept with one `ValidationError` variant (e.g., S100 UnclosedTag) to compare output quality, API ergonomics, and integration effort.\n\n`annotate-snippets` is preferred for alignment with Ruff/ty. Select the crate and add it to `[workspace.dependencies]` in root `Cargo.toml`.\n\n## Acceptance Criteria\n\n- Proof-of-concept renders at least one `ValidationError` variant with source context\n- Decision documented (even if just in the dex result)\n- Chosen crate added to workspace dependencies","priority":1,"completed":true,"result":"Evaluated annotate-snippets (0.12.11), miette (7.6.0), and ariadne (0.5.1) by building proof-of-concept renderings of real ValidationError variants.\n\n## Decision: annotate-snippets\n\n### Why annotate-snippets wins\n\n1. **Lightest dependency tree** â€” 2 deps (anstyle, unicode-width) vs miette's 11 (backtrace, proc-macro, terminal_size, etc.) vs ariadne's 2 (unicode-width, yansi)\n2. **Matches ty/ruff output** â€” the project's target audience uses Python tooling from Astral; matching their diagnostic style creates familiarity\n3. **Used by rustc** â€” being adopted as the official Rust compiler diagnostic renderer, actively maintained by Rust project members\n4. **Built-in plain/styled modes** â€” `Renderer::plain()` for snapshot tests, `Renderer::styled()` for terminal, plus `testing-colors` feature for deterministic colored test output\n5. **Functional API taking primitives** â€” `Level::ERROR.primary_title().id().element(Snippet::source().annotation())` â€” exactly fits the generic renderer design (takes source + span + code + message, not tied to error types)\n6. **DecorStyle** â€” `Ascii` (default, ty-style) and `Unicode` options; `term_width()` for wrapping; `anonymize_line_numbers()` for test determinism\n\n### Why not the others\n\n- **miette**: Heavy deps, derive-macro approach couples error types to rendering (opposite of our generic renderer goal), global state for color control, different visual style\n- **ariadne**: Light deps but writes to `impl Write` (buffer management), requires `Cache` trait for source lookup, different visual style from ty/ruff\n\n### What was tested\n\nBuilt 12 scenarios covering all major ValidationError shapes:\n- Single-line spans (S100, S108, S111, S115, S116, S120)\n- Two annotations same line (S114 â€” `and and` with context + primary)\n- Two annotations different lines (S103, S122, W001, S101)\n- Multi-line spans (S109 crispy form)\n- Notes/info footer (S109 load hint)\n- Warning level (W001)\n- Long line truncation with `...` prefix\n- Multiple files stacked\n\nAlso compared ASCII vs Unicode decor styles, and a hand-rolled Python SyntaxError style. ASCII mode (ty-style) was selected as the default.\n\n### Added to workspace\n\n`annotate-snippets = \"0.12\"` added to `[workspace.dependencies]` in root `Cargo.toml`.","metadata":null,"created_at":"2026-02-11T17:53:44.152Z","updated_at":"2026-02-11T18:22:46.435Z","started_at":"2026-02-11T18:22:46.434Z","completed_at":"2026-02-11T18:22:46.435Z","blockedBy":[],"blocks":["o8q4kj8g"],"children":[]}
{"id":"vjl204dj","parent_id":null,"name":"Add --hidden flag to djls check","description":"Replace `walkdir` with the `ignore` crate (from ripgrep) for file traversal in `walk_files`, and add a `--hidden` flag to `djls check`.\n\n## Why `ignore` over `walkdir`\n\nThe `ignore` crate (crates.io/crates/ignore) is ripgrep's file walker. It gives us for free:\n- `.gitignore` / `.ignore` / `.rgignore` respect\n- Hidden file/dir exclusion by default (toggle with `.hidden(true)`)\n- Global gitignore support\n- Parallel traversal option (`WalkParallel`)\n- Symlink handling\n- `.git/` directory skipping\n\nRight now we use `walkdir` + hand-rolled `is_hidden` + a caller-provided `skip_dir` predicate. The `ignore` crate handles all of this natively and correctly (edge cases around nested .gitignore, negation patterns, etc.).\n\nripgrep's convention: hidden files excluded by default, `--hidden` opts in. We copy that directly.\n\n## Changes\n\n### `crates/djls-workspace/`\n- Replace `walkdir` dep with `ignore` in Cargo.toml\n- Rewrite `walk_files` to use `ignore::WalkBuilder`\n- Remove the `skip_dir` parameter â€” `ignore` handles hidden dirs natively\n- Add a `hidden: bool` parameter instead (passed through to `WalkBuilder::hidden()`)\n- `.gitignore` respect comes free\n\n### `crates/djls/src/commands/check.rs`\n- Add `--hidden` flag to `Check` struct\n- Remove `is_hidden_dir` helper\n- Pass `self.hidden` through to `walk_files`\n\n### Root `Cargo.toml`\n- Add `ignore` to workspace deps, remove `walkdir`\n\n## Acceptance Criteria\n\n- `djls check .` skips hidden dirs and respects .gitignore (improved default)\n- `djls check --hidden .` includes hidden directories\n- Existing tests pass (update walker tests for new API)\n- `walkdir` removed from dependency tree","priority":1,"completed":true,"result":"Replaced walkdir with ignore crate across all crates. walk_files now takes hidden: bool instead of skip_dir closure. djls check respects .gitignore and skips hidden dirs by default, --hidden flag opts in. walkdir removed as direct dep.","metadata":{"github":{"issueNumber":405,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/405","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T20:39:05.077Z","updated_at":"2026-02-11T20:55:09.022Z","started_at":"2026-02-11T20:53:56.978Z","completed_at":"2026-02-11T20:53:56.982Z","blockedBy":[],"blocks":[],"children":[]}
{"id":"vn3vdvhc","parent_id":null,"name":"Adopt inline diagnostic snapshots and curated Scenario testing","description":"The current testing pattern relies heavily on `insta` YAML snapshots. While useful, these can be opaqueâ€”a failure shows a diff in a serialized data structure rather than the relationship between the source code and the resulting error. Following the pattern used in `ruff/ty`, the project should move toward \"Scenario\" tests where the snapshot renders the source and diagnostics together.\n\n## Proposal\nImplement a \"Scenario Runner\" and a diagnostic renderer that produces readable, self-documenting snapshots.\n\n## Technical Requirements\n1.  **Diagnostic Renderer**:\n    *   Create a text renderer (e.g., using `annotate-snippets` or `miette`) that maps `ValidationError` byte offsets back to the source code.\n    *   The output should show the relevant lines of the template or Python file with inline error markers.\n2.  **Scenario Test Helper**:\n    *   Define a `Scenario` struct in `djls-test` that allows declarative test setup:\n        ```rust\n        let scenario = Scenario::new()\n            .with_file(\"app/tags.py\", python_source)\n            .with_file(\"app/index.html\", \"{% load tags %}\")\n            .with_dependencies(&[\"django==5.1\"]);\n        \n        insta::assert_snapshot!(scenario.run_validation());\n        ```\n3.  **\"Golden\" Snippet Migration**:\n    *   Transition away from \"bulk snapshots\" for the corpus. The corpus should be used primarily for \"panic/smoke\" testing.\n    *   Extract the most complex or regression-prone templatetags from the ecosystem (e.g., `sekizai`, `crispy_forms`) into curated, targeted Scenario tests.\n4.  **Markdown Integration**:\n    *   Explore the ability to parse these scenarios directly from Markdown files, allowing for easier contribution of test cases and better readability.\n\n> Braindump by @joshuadavidthomas, issue captured and created by Gemini 3 Flash","priority":1,"completed":false,"result":null,"metadata":{"github":{"issueNumber":400,"issueUrl":"https://github.com/joshuadavidthomas/django-language-server/issues/400","repo":"joshuadavidthomas/django-language-server","state":"open"}},"created_at":"2026-02-11T18:47:09.557Z","updated_at":"2026-02-11T20:55:09.990Z","started_at":null,"completed_at":null,"blockedBy":[],"blocks":[],"children":[]}
{"id":"vpxani2s","parent_id":"nrcdb189","name":"Stdin support","description":"Add support for piping template content via stdin.\n\n## Behavior\n\nDetect `!std::io::stdin().is_terminal()`:\n- Read all of stdin into a string\n- Create an in-memory file (use a synthetic path like `<stdin>`)\n- Run through the same parse â†’ validate â†’ collect pipeline\n- Print diagnostics and exit\n\nNo explicit flag needed â€” stdin is detected automatically. This should be integrated into the file discovery step of `Check::execute()`: if stdin is not a terminal, read it as a single template before checking any path arguments.\n\n## Example\n\n```bash\necho '{% if %}' | djls check\ncat template.html | djls check\n```\n\n## Acceptance Criteria\n\n- Piped input is detected and checked as a single template\n- Diagnostics reference `<stdin>` as the file path\n- Exit code reflects whether errors were found in the piped content\n- Non-terminal stdin takes priority over path arguments (or works alongside them â€” decide during implementation)\n- `cargo build -q` passes","priority":1,"completed":true,"result":"Stdin support via InMemoryFileSystem when stdin is not a terminal and no paths given","metadata":null,"created_at":"2026-02-11T17:55:02.335Z","updated_at":"2026-02-11T19:19:34.385Z","started_at":"2026-02-11T19:19:34.381Z","completed_at":"2026-02-11T19:19:34.385Z","blockedBy":["idbcwda3"],"blocks":[],"children":[]}
