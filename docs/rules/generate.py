#!/usr/bin/env python3
"""Generate docs/rules.md from rules.toml and djls check output.

Usage:
    python docs/rules/generate.py
"""
from __future__ import annotations

import re
import subprocess
import sys
from pathlib import Path

try:
    import tomllib
except ImportError:
    import tomli as tomllib  # type: ignore[no-redef]

ROOT = Path(__file__).resolve().parent.parent.parent
RULES_DIR = ROOT / "docs" / "rules"
EXAMPLES_DIR = RULES_DIR / "examples"
OUTPUT = ROOT / "docs" / "rules.md"
DJLS_BIN = ROOT / "target" / "release" / "djls"

HEADER = """\
<!-- WARNING: This file is auto-generated by docs/rules/generate.py. -->
<!-- Edit docs/rules/rules.toml and the example files instead.       -->

# Rules

This page documents every diagnostic rule that djls can report. Each rule has \
a short code (shown in your editor) and a descriptive name.

For an overview of how validation works — the inspector, environment scanner, \
and extraction engine — see [Template Validation](./template-validation.md). \
For configuring severity levels, see \
[Configuration](./configuration/index.md#diagnostics).
"""


def load_rules() -> list[dict]:
    with open(RULES_DIR / "rules.toml", "rb") as f:
        data = tomllib.load(f)
    rules = []
    for key, rule in data.items():
        rule.setdefault("code", key)
        rules.append(rule)
    return rules


def run_djls_check(example_path: Path, select_code: str) -> str | None:
    """Run djls check on an example file and return the plain-text output."""
    if not DJLS_BIN.exists():
        debug_bin = ROOT / "target" / "debug" / "djls"
        if debug_bin.exists():
            bin_path = debug_bin
        else:
            print(
                f"warning: djls binary not found at {DJLS_BIN} or {debug_bin}, "
                "skipping generated output",
                file=sys.stderr,
            )
            return None
    else:
        bin_path = DJLS_BIN

    result = subprocess.run(
        [str(bin_path), "check", "--select", select_code, str(example_path)],
        capture_output=True,
        text=True,
        cwd=str(ROOT),
    )
    output = (result.stdout + result.stderr).strip()
    if not output:
        return None

    # Strip the trailing "Found N error(s)..." summary line
    lines = output.splitlines()
    if lines and re.match(r"^Found \d+ errors?", lines[-1]):
        lines = lines[:-1]
    # Strip trailing blank lines
    while lines and not lines[-1].strip():
        lines.pop()

    return "\n".join(lines) if lines else None


def normalize_path_in_output(output: str) -> str:
    """Replace absolute paths with just the filename for cleaner docs."""
    return re.sub(
        r" --> .+/([^/]+\.html)",
        r" --> \1",
        output,
    )


def read_example(example_filename: str) -> str | None:
    path = EXAMPLES_DIR / example_filename
    if not path.exists():
        return None
    return path.read_text().rstrip("\n")


def generate_toc(rules: list[dict]) -> str:
    lines = []

    # Group into T-series and S-series
    t_rules = [r for r in rules if r["code"].startswith("T")]
    s_rules = [r for r in rules if r["code"].startswith("S")]

    if t_rules:
        lines.append("## Template Errors\n")
        for r in t_rules:
            lines.append(f'- [{r["code"]} `{r["name"]}`](#{r["name"]})')
        lines.append("")

    if s_rules:
        lines.append("## Semantic Errors\n")
        for r in s_rules:
            lines.append(f'- [{r["code"]} `{r["name"]}`](#{r["name"]})')
        lines.append("")

    return "\n".join(lines)


def generate_rule_section(rule: dict) -> str:
    lines = []
    code = rule["code"]
    name = rule["name"]

    lines.append(f"## `{name}`\n")

    # Metadata line
    meta_parts = [code, "Default severity: **error**"]
    if rule.get("requires") == "inspector":
        meta_parts.append(
            "Requires [inspector](./template-validation.md#inspector-availability)"
        )
    lines.append(" · ".join(meta_parts))
    lines.append("")

    # What it does
    lines.append("**What it does**\n")
    lines.append(rule["what"])
    lines.append("")

    # Why is this bad?
    if "why" in rule:
        lines.append("**Why is this bad?**\n")
        lines.append(rule["why"])
        lines.append("")

    # Example
    example_file = rule.get("example")
    if example_file:
        example_source = read_example(example_file)
        if example_source:
            lines.append("**Example**\n")
            lines.append("```htmldjango")
            lines.append(example_source)
            lines.append("```")
            lines.append("")

            # Auto-generated diagnostic output
            if rule.get("generated", False):
                output = run_djls_check(EXAMPLES_DIR / example_file, code)
                if output:
                    output = normalize_path_in_output(output)
                    lines.append("```")
                    lines.append(output)
                    lines.append("```")
                    lines.append("")

    # How to fix / Use instead
    if "fix" in rule:
        lines.append("**How to fix**\n")
        lines.append(rule["fix"])
        lines.append("")

    return "\n".join(lines)


def generate() -> str:
    rules = load_rules()
    parts = [HEADER, generate_toc(rules)]

    for rule in rules:
        parts.append(generate_rule_section(rule))

    return "\n".join(parts)


def main():
    content = generate()
    OUTPUT.write_text(content)
    print(f"Generated: {OUTPUT.relative_to(ROOT)}")


if __name__ == "__main__":
    main()
