use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    // Tell Cargo to rerun this build script if the TOML file changes
    println!("cargo:rerun-if-changed=diagnostics.toml");

    // Read and parse the diagnostics TOML file
    let toml_path = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap())
        .join("diagnostics.toml");

    let toml_content = fs::read_to_string(&toml_path)
        .expect("Failed to read diagnostics.toml");

    let diagnostics: DiagnosticsConfig = toml::from_str(&toml_content)
        .expect("Failed to parse diagnostics.toml");

    // Generate Rust code for diagnostic mappings
    let mut template_error_arms = Vec::new();
    let mut validation_error_arms = Vec::new();

    for rule in &diagnostics.rule {
        let code = &rule.code;
        let error_types = &rule.error_type;

        // Handle multiple error types separated by pipe (|)
        for error_type in error_types.split('|') {
            let error_type = error_type.trim();

            if error_type.starts_with("TemplateError::") {
                let variant = error_type.strip_prefix("TemplateError::").unwrap();
                template_error_arms.push(format!("            TemplateError::{variant}(_) => \"{code}\","));
            } else if error_type.starts_with("ValidationError::") {
                let variant = error_type.strip_prefix("ValidationError::").unwrap();
                validation_error_arms.push(format!("            ValidationError::{variant} {{ .. }} => \"{code}\","));
            }
        }
    }

    let generated_code = format!(
r#"// This file is generated by build.rs from diagnostics.toml
// DO NOT EDIT MANUALLY

impl DiagnosticError for TemplateError {{
    fn span(&self) -> Option<(u32, u32)> {{
        None
    }}

    fn diagnostic_code(&self) -> &'static str {{
        match self {{
{}
        }}
    }}
}}

impl DiagnosticError for ValidationError {{
    fn span(&self) -> Option<(u32, u32)> {{
        match self {{
            ValidationError::UnbalancedStructure {{ opening_span, .. }} => Some(opening_span.into()),
            ValidationError::UnclosedTag {{ span, .. }}
            | ValidationError::OrphanedTag {{ span, .. }}
            | ValidationError::UnmatchedBlockName {{ span, .. }}
            | ValidationError::MissingRequiredArguments {{ span, .. }}
            | ValidationError::TooManyArguments {{ span, .. }}
            | ValidationError::MissingArgument {{ span, .. }}
            | ValidationError::InvalidLiteralArgument {{ span, .. }}
            | ValidationError::InvalidArgumentChoice {{ span, .. }} => Some(span.into()),
        }}
    }}

    fn diagnostic_code(&self) -> &'static str {{
        match self {{
{}
        }}
    }}
}}
"#,
        template_error_arms.join("\n"),
        validation_error_arms.join("\n")
    );

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    fs::write(out_dir.join("diagnostic_impls.rs"), generated_code)
        .expect("Failed to write generated code");

    // Generate markdown documentation
    generate_documentation(&diagnostics);
}

fn generate_documentation(diagnostics: &DiagnosticsConfig) {
    let mut doc = String::new();

    doc.push_str("# Diagnostic Rules Reference\n\n");
    doc.push_str("This document lists all diagnostic rules provided by the Django Language Server.\n\n");
    doc.push_str("> **Note:** This file is automatically generated from `diagnostics.toml`.\n");
    doc.push_str("> Do not edit manually. To update rules, edit the TOML file instead.\n\n");

    // Group by category
    let mut template_rules = Vec::new();
    let mut semantic_rules = Vec::new();

    for rule in &diagnostics.rule {
        if rule.category == "template" {
            template_rules.push(rule);
        } else {
            semantic_rules.push(rule);
        }
    }

    // Write template rules section
    doc.push_str("## Template Parsing Errors (T-series)\n\n");
    doc.push_str("These errors occur during the parsing phase of template processing.\n\n");

    for rule in template_rules {
        write_rule_section(&mut doc, rule);
    }

    // Write semantic rules section
    doc.push_str("## Semantic Validation Errors (S-series)\n\n");
    doc.push_str("These errors are detected during semantic analysis of valid template syntax.\n\n");

    for rule in semantic_rules {
        write_rule_section(&mut doc, rule);
    }

    // Write the documentation to the project docs directory
    let doc_path = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap())
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("docs")
        .join("rules.md");

    // Create docs directory if it doesn't exist
    if let Some(parent) = doc_path.parent() {
        fs::create_dir_all(parent).ok();
    }

    fs::write(&doc_path, doc)
        .expect("Failed to write documentation");
}

fn write_rule_section(doc: &mut String, rule: &Rule) {
    doc.push_str(&format!("### {} - {}\n\n", rule.code, rule.name));
    doc.push_str(&format!("**Description:** {}\n\n", rule.description));

    if let Some(explanation) = &rule.explanation {
        doc.push_str(&explanation.trim());
        doc.push_str("\n\n");
    }

    doc.push_str("---\n\n");
}

// TOML structure definitions
#[derive(serde::Deserialize)]
struct DiagnosticsConfig {
    rule: Vec<Rule>,
}

#[derive(serde::Deserialize)]
struct Rule {
    code: String,
    category: String,
    error_type: String,
    name: String,
    description: String,
    #[allow(dead_code)]
    severity: String,
    explanation: Option<String>,
}
