use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    // Tell Cargo to rerun this build script if the TOML file changes
    println!("cargo:rerun-if-changed=diagnostics.toml");

    // Read and parse the diagnostics TOML file
    let toml_path = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap())
        .join("diagnostics.toml");

    let toml_content = fs::read_to_string(&toml_path)
        .expect("Failed to read diagnostics.toml");

    let diagnostics: DiagnosticsConfig = toml::from_str(&toml_content)
        .expect("Failed to parse diagnostics.toml");

    // Generate a simple lookup map as a const array
    let mut mappings = Vec::new();

    for rule in &diagnostics.rule {
        let code = &rule.code;
        let error_types = &rule.error_type;

        // Handle multiple error types separated by pipe (|)
        for error_type in error_types.split('|') {
            let error_type = error_type.trim();
            mappings.push(format!("    (\"{}\", \"{}\"),", error_type, code));
        }
    }

    let generated_code = format!(
r#"// This file is generated by build.rs from diagnostics.toml
// DO NOT EDIT MANUALLY
//
// This provides a lookup table from error type names to diagnostic codes.
// The actual trait implementations in diagnostics.rs use this data.

pub(crate) const DIAGNOSTIC_CODE_MAPPINGS: &[(&str, &str)] = &[
{}
];
"#,
        mappings.join("\n")
    );

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    fs::write(out_dir.join("diagnostic_codes.rs"), generated_code)
        .expect("Failed to write generated code");

    // Generate markdown documentation
    generate_documentation(&diagnostics);
}

fn generate_documentation(diagnostics: &DiagnosticsConfig) {
    let docs_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap())
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("docs")
        .join("rules");

    // Create rules directory if it doesn't exist
    fs::create_dir_all(&docs_dir).expect("Failed to create docs/rules directory");

    // Group by category for the index
    let mut template_rules = Vec::new();
    let mut semantic_rules = Vec::new();

    for rule in &diagnostics.rule {
        if rule.category == "template" {
            template_rules.push(rule);
        } else {
            semantic_rules.push(rule);
        }

        // Generate individual rule page
        let rule_path = docs_dir.join(format!("{}.md", rule.code));
        let content = generate_rule_page(rule);
        fs::write(&rule_path, content)
            .unwrap_or_else(|_| panic!("Failed to write {}", rule_path.display()));
    }

    // Generate index page
    let mut index = String::new();
    index.push_str("# Diagnostic Rules Reference\n\n");
    index.push_str("<!-- This file is automatically generated from diagnostics.toml -->\n");
    index.push_str("<!-- Do not edit manually. To update rules, edit the TOML file instead. -->\n\n");
    index.push_str("This document lists all diagnostic rules provided by the Django Language Server.\n\n");

    // Template rules section
    index.push_str("## Template Parsing Errors (T-series)\n\n");
    index.push_str("These errors occur during the parsing phase of template processing.\n\n");
    for rule in &template_rules {
        index.push_str(&format!("- [**{}**](./{}.md) - {}\n", rule.code, rule.code, rule.name));
    }
    index.push('\n');

    // Semantic rules section
    index.push_str("## Semantic Validation Errors (S-series)\n\n");
    index.push_str("These errors are detected during semantic analysis of valid template syntax.\n\n");
    for rule in &semantic_rules {
        index.push_str(&format!("- [**{}**](./{}.md) - {}\n", rule.code, rule.code, rule.name));
    }

    let index_path = docs_dir.join("index.md");
    fs::write(&index_path, index)
        .expect("Failed to write index.md");
}

fn generate_rule_page(rule: &Rule) -> String {
    let mut page = String::new();

    page.push_str(&format!("# {} - {}\n\n", rule.code, rule.name));
    page.push_str("<!-- This file is automatically generated from diagnostics.toml -->\n");
    page.push_str("<!-- Do not edit manually. To update this rule, edit the TOML file instead. -->\n\n");

    page.push_str(&format!("**Code:** `{}`  \n", rule.code));
    page.push_str(&format!("**Category:** {}  \n", rule.category));
    page.push_str(&format!("**Severity:** {}  \n\n", rule.severity));

    page.push_str("## Description\n\n");
    page.push_str(&rule.description);
    page.push_str("\n\n");

    if let Some(explanation) = &rule.explanation {
        page.push_str("## Details\n\n");
        page.push_str(explanation.trim());
        page.push_str("\n");
    }

    page
}

// TOML structure definitions
#[derive(serde::Deserialize)]
struct DiagnosticsConfig {
    rule: Vec<Rule>,
}

#[derive(serde::Deserialize)]
struct Rule {
    code: String,
    category: String,
    error_type: String,
    name: String,
    description: String,
    #[allow(dead_code)]
    severity: String,
    explanation: Option<String>,
}
