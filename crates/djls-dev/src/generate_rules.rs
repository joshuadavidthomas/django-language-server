use std::fmt::Write;
use std::path::PathBuf;

use anyhow::Result;
use djls_semantic::all_rule_docs;
use djls_semantic::RuleDoc;

fn generate_toc(t_rules: &[&RuleDoc], s_rules: &[&RuleDoc]) -> String {
    let mut out = String::new();

    if !t_rules.is_empty() {
        writeln!(out, "## Template Errors\n").unwrap();
        for r in t_rules {
            writeln!(out, "- [{} `{}`](#{})", r.code, r.name, r.name).unwrap();
        }
        writeln!(out).unwrap();
    }

    if !s_rules.is_empty() {
        writeln!(out, "## Semantic Errors\n").unwrap();
        for r in s_rules {
            writeln!(out, "- [{} `{}`](#{})", r.code, r.name, r.name).unwrap();
        }
        writeln!(out).unwrap();
    }

    out
}

fn generate_rule_section(rule: &RuleDoc) -> String {
    let mut out = String::new();

    writeln!(out, "## `{}`\n", rule.name).unwrap();

    let mut meta = format!("{} · Default severity: **error**", rule.code);
    if rule.requires_inspector {
        meta.push_str(" · Requires [inspector](./template-validation.md#inspector-availability)");
    }
    writeln!(out, "{meta}\n").unwrap();

    writeln!(out, "**What it does**\n").unwrap();
    writeln!(out, "{}\n", rule.what).unwrap();

    if let Some(why) = rule.why {
        writeln!(out, "**Why is this bad?**\n").unwrap();
        writeln!(out, "{why}\n").unwrap();
    }

    if let Some(example) = rule.example {
        writeln!(out, "**Example**\n").unwrap();
        writeln!(out, "```htmldjango\n{example}\n```\n").unwrap();
    }

    if let Some(fix) = rule.fix {
        writeln!(out, "**How to fix**\n").unwrap();
        writeln!(out, "{fix}\n").unwrap();
    }

    out
}

fn generate() -> String {
    let rules = all_rule_docs();
    let t_rules: Vec<&RuleDoc> = rules.iter().filter(|r| r.code.starts_with('T')).collect();
    let s_rules: Vec<&RuleDoc> = rules.iter().filter(|r| r.code.starts_with('S')).collect();

    let mut out = String::new();

    writeln!(
        out,
        "\
<!-- WARNING: This file is auto-generated by `cargo dev generate-rules`. -->
<!-- Edit crates/djls-semantic/src/rule_docs.rs instead.                 -->

# Rules

This page documents every diagnostic rule that djls can report. Each rule has \
a short code (shown in your editor) and a descriptive name.

For an overview of how validation works — the inspector, environment scanner, \
and extraction engine — see [Template Validation](./template-validation.md). \
For configuring severity levels, see \
[Configuration](./configuration/index.md#diagnostics).
"
    )
    .unwrap();

    out.push_str(&generate_toc(&t_rules, &s_rules));

    for rule in t_rules.iter().chain(s_rules.iter()) {
        out.push_str(&generate_rule_section(rule));
    }

    // Trim trailing whitespace per line, ensure single trailing newline
    out.lines()
        .map(str::trim_end)
        .collect::<Vec<_>>()
        .join("\n")
        .trim_end()
        .to_string()
        + "\n"
}

pub fn run() -> Result<()> {
    let workspace_dir = std::env::var("CARGO_WORKSPACE_DIR").unwrap_or_else(|_| ".".to_string());
    let output_path = PathBuf::from(workspace_dir).join("docs/rules.md");

    let content = generate();
    std::fs::write(&output_path, &content)?;

    println!("Generated: {}", output_path.display());
    Ok(())
}
