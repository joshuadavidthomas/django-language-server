use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, Data, DataEnum, Lit, Meta};

/// Derives the `diagnostic_code()` method for error enums.
///
/// This macro reads `#[diagnostic(code = "...")]` attributes from enum variants
/// and generates a `diagnostic_code()` implementation that returns the appropriate
/// code for each variant.
///
/// # Example
///
/// ```ignore
/// #[derive(Diagnostic)]
/// pub enum ValidationError {
///     #[diagnostic(code = "S105", category = "semantic")]
///     TooManyArguments { tag: String, max: usize },
/// }
/// ```
///
/// This generates:
///
/// ```ignore
/// impl ValidationError {
///     pub fn diagnostic_code(&self) -> &'static str {
///         match self {
///             ValidationError::TooManyArguments { .. } => "S105",
///         }
///     }
/// }
/// ```
#[proc_macro_derive(Diagnostic, attributes(diagnostic))]
pub fn derive_diagnostic(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let enum_name = &input.ident;

    let Data::Enum(DataEnum { variants, .. }) = input.data else {
        return syn::Error::new_spanned(
            enum_name,
            "Diagnostic can only be derived for enums"
        )
        .to_compile_error()
        .into();
    };

    let mut match_arms = Vec::new();

    for variant in variants {
        let variant_name = &variant.ident;

        // Extract the diagnostic code from attributes
        let Some(code) = extract_diagnostic_code(&variant.attrs) else {
            return syn::Error::new_spanned(
                variant_name,
                format!("Variant '{}' is missing #[diagnostic(code = \"...\")] attribute", variant_name)
            )
            .to_compile_error()
            .into();
        };

        // Generate match arm - handle struct, tuple, and unit variants
        let pattern = match &variant.fields {
            syn::Fields::Named(_) => quote! { #enum_name::#variant_name { .. } },
            syn::Fields::Unnamed(_) => quote! { #enum_name::#variant_name(..) },
            syn::Fields::Unit => quote! { #enum_name::#variant_name },
        };

        match_arms.push(quote! {
            #pattern => #code,
        });
    }

    let expanded = quote! {
        impl #enum_name {
            /// Returns the diagnostic code for this error.
            ///
            /// This method is automatically generated by the `Diagnostic` derive macro
            /// based on `#[diagnostic(code = "...")]` attributes.
            pub fn diagnostic_code(&self) -> &'static str {
                match self {
                    #(#match_arms)*
                }
            }
        }
    };

    TokenStream::from(expanded)
}

fn extract_diagnostic_code(attrs: &[syn::Attribute]) -> Option<String> {
    for attr in attrs {
        if attr.path().is_ident("diagnostic") {
            if let Meta::List(meta_list) = &attr.meta {
                let mut code = None;

                let _ = meta_list.parse_nested_meta(|meta| {
                    if meta.path.is_ident("code") {
                        if let Ok(value) = meta.value() {
                            if let Ok(Lit::Str(lit)) = value.parse() {
                                code = Some(lit.value());
                            }
                        }
                    }
                    Ok(())
                });

                if let Some(code) = code {
                    return Some(code);
                }
            }
        }
    }
    None
}
