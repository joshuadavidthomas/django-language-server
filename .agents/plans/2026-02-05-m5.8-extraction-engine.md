# M5: Extraction Engine - Phase 8

> **Parent document**: [M5: Extraction Engine Overview](2026-02-05-m5-extraction-engine.md)

---

## Phase 8: Small Fixture Golden Tests (Tier 1)

### Fixture File

**File**: `crates/djls-extraction/tests/fixtures/defaulttags_subset.py`

```python
"""Subset of django.template.defaulttags for extraction testing.

Note: Uses 'args' instead of 'bits' in autoescape to verify dynamic variable detection.
"""
from django import template
from django.template.base import TemplateSyntaxError

register = template.Library()


@register.tag
def autoescape(parser, token):
    # Using 'args' instead of 'bits' to test variable detection
    args = token.split_contents()
    if len(args) != 2:
        raise TemplateSyntaxError("'autoescape' tag requires exactly one argument.")
    arg = args[1]
    if arg not in ("on", "off"):
        raise TemplateSyntaxError("'autoescape' argument should be 'on' or 'off'")
    nodelist = parser.parse(("endautoescape",))
    parser.delete_first_token()
    return AutoEscapeControlNode((arg == "on"), nodelist)


@register.tag("if")
def do_if(parser, token):
    nodelist = parser.parse(("elif", "else", "endif"))
    tok = parser.next_token()
    if tok.contents == "else":
        nodelist = parser.parse(("endif",))
    return IfNode(nodelist)


@register.tag("for")
def do_for(parser, token):
    parts = token.split_contents()  # Using 'parts' to test variable detection
    if len(parts) < 4:
        raise TemplateSyntaxError("'for' statements should have at least four words")
    if parts[2] != "in":
        raise TemplateSyntaxError("'for' statements should use 'for x in y'")

    nodelist_loop = parser.parse(("empty", "endfor"))
    token = parser.next_token()
    if token.contents == "empty":
        nodelist_empty = parser.parse(("endfor",))
    else:
        nodelist_empty = None
    return ForNode(nodelist_loop, nodelist_empty)


@register.simple_tag
def now(format_string):
    return datetime.now().strftime(format_string)


@register.filter
def title(value):
    return value.title()


@register.filter
def default(value, arg=""):
    return value or arg


@register.filter
def truncatewords(value, arg):
    words = value.split()
    return " ".join(words[:int(arg)])
```

### Golden Tests

**File**: `crates/djls-extraction/tests/golden.rs`

```rust
use djls_extraction::extract_rules;

#[test]
fn test_extract_defaulttags_subset() {
    let source = include_str!("fixtures/defaulttags_subset.py");
    let result = extract_rules(source).unwrap();

    insta::assert_yaml_snapshot!(result, {
        ".tags[].rules[].message" => "[message]",
    });
}

#[test]
fn test_autoescape_with_args_variable() {
    // Verify extraction works with 'args' variable (not 'bits')
    let source = include_str!("fixtures/defaulttags_subset.py");
    let result = extract_rules(source).unwrap();

    let autoescape = result.tags.iter().find(|t| t.name == "autoescape").unwrap();

    // Should still extract rules despite using 'args'
    assert!(!autoescape.rules.is_empty());
    assert!(autoescape.rules.iter().any(|r| {
        matches!(r.condition, djls_extraction::RuleCondition::ExactArgCount { count: 2, .. })
    }));
}

#[test]
fn test_for_tag_with_parts_variable() {
    // Verify extraction works with 'parts' variable
    let source = include_str!("fixtures/defaulttags_subset.py");
    let result = extract_rules(source).unwrap();

    let for_tag = result.tags.iter().find(|t| t.name == "for").unwrap();

    // Should extract rules using 'parts'
    assert!(for_tag.rules.iter().any(|r| {
        matches!(r.condition, djls_extraction::RuleCondition::MinArgCount { .. })
    }));
}
```

### Success Criteria:

- [ ] Golden tests pass: `cargo test -p djls-extraction golden`
- [ ] Tests verify variable name detection works for `args`, `parts`, not just `bits`
- [ ] All snapshots reviewed: `cargo insta review`
