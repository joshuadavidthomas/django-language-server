# M3: Load Scoping - Phase 3

> **Parent document**: [M3: Load Scoping Overview](2026-02-05-m3-load-scoping.md)

---

## Phase 3: Available Symbols Query

### Overview

Add a query that combines inspector inventory with load state to determine what tags are available at a given position.

### Changes Required:

#### 1. Add AvailableSymbols Type and Query

**File**: `crates/djls-semantic/src/load_resolution.rs`
**Changes**: Add after `LoadedLibraries`

```rust
use djls_project::TagProvenance;
use djls_project::TemplateTags;
use rustc_hash::FxHashMap;

/// Result of querying available symbols at a position.
#[derive(Debug, Clone, Default)]
pub struct AvailableSymbols {
    /// Tag names available at this position
    pub tags: FxHashSet<String>,
}

impl AvailableSymbols {
    /// Check if a tag name is available
    pub fn has_tag(&self, name: &str) -> bool {
        self.tags.contains(name)
    }
}

/// Load state at a given position, computed by processing loads in order.
///
/// This uses a state-machine approach to correctly handle the interaction
/// between selective imports and full library loads:
/// - `{% load trans from i18n %}` adds "trans" to selective[i18n]
/// - `{% load i18n %}` adds "i18n" to fully_loaded AND clears selective[i18n]
///
/// This ensures that a later full load overrides earlier selective imports.
#[derive(Debug, Clone, Default)]
struct LoadState {
    /// Libraries that have been fully loaded (all tags available)
    fully_loaded: FxHashSet<String>,
    /// Selectively imported symbols: library → set of symbol names
    /// Only contains entries for libraries NOT in fully_loaded
    selective: FxHashMap<String, FxHashSet<String>>,
}

impl LoadState {
    /// Process a load statement, updating state accordingly.
    fn process(&mut self, stmt: &LoadStatement) {
        match &stmt.kind {
            LoadKind::Libraries(libs) => {
                for lib in libs {
                    // Full load: add to fully_loaded, clear any selective imports
                    self.fully_loaded.insert(lib.clone());
                    self.selective.remove(lib);
                }
            }
            LoadKind::Selective { symbols, library } => {
                // Only add selective imports if library not already fully loaded
                if !self.fully_loaded.contains(library) {
                    let entry = self.selective.entry(library.clone()).or_default();
                    entry.extend(symbols.iter().cloned());
                }
            }
        }
    }

    /// Check if a tag from a library is available.
    fn is_tag_available(&self, tag_name: &str, library: &str) -> bool {
        // Available if library is fully loaded
        if self.fully_loaded.contains(library) {
            return true;
        }
        // Or if specifically imported via selective import
        if let Some(symbols) = self.selective.get(library) {
            return symbols.contains(tag_name);
        }
        false
    }
}

/// Determine which tags are available at a given position in the template.
///
/// This function uses a **state-machine approach** that processes load
/// statements in document order up to `position`:
///
/// 1. For `{% load lib1 lib2 %}`: add libraries to "fully loaded" set
///    and clear any selective imports for those libraries
/// 2. For `{% load sym from lib %}`: if lib not fully loaded, add sym
///    to selective imports for lib
///
/// A library tag is available iff:
/// - Its library is in the fully_loaded set, OR
/// - The tag name is in the selective imports for its library
///
/// This correctly handles `{% load trans from i18n %}` followed by
/// `{% load i18n %}` — after the second load, ALL i18n tags are available.
///
/// # Arguments
/// * `loaded` - The LoadedLibraries computed from the template
/// * `inventory` - The TemplateTags from inspector (M1 shape)
/// * `position` - The byte offset to check availability at
///
/// # Returns
/// The set of tag names available at the position.
pub fn available_tags_at(
    loaded: &LoadedLibraries,
    inventory: &TemplateTags,
    position: u32,
) -> AvailableSymbols {
    let mut available = AvailableSymbols::default();

    // Build load state by processing statements in order up to position
    let mut state = LoadState::default();
    for stmt in loaded.loads() {
        // Only include loads that END before the position
        if stmt.span.end() <= position {
            state.process(stmt);
        }
    }

    // Determine available tags
    for tag in inventory.iter() {
        match tag.provenance() {
            TagProvenance::Builtin { .. } => {
                // Builtins are always available
                available.tags.insert(tag.name().clone());
            }
            TagProvenance::Library { load_name, .. } => {
                if state.is_tag_available(tag.name(), load_name) {
                    available.tags.insert(tag.name().clone());
                }
            }
        }
    }

    available
}
```

**Key correctness property**: The state-machine approach ensures that a full library load (`{% load i18n %}`) overrides any earlier selective imports (`{% load trans from i18n %}`), making all library tags available after the full load.

**Position/Span Units**: All positions in this module are **byte offsets** matching `djls_source::Span` units. The rule `stmt.span.end() <= position` means the load tag must be fully parsed (its closing `%}` must be before the query position). When converting from LSP `Position` (line/character, UTF-16), use `calculate_byte_offset()` in completions.rs to get the correct byte offset.

#### 2. Add Comprehensive Tests

**File**: `crates/djls-semantic/src/load_resolution.rs`
**Changes**: Add more tests

```rust
#[cfg(test)]
mod availability_tests {
    use super::*;
    use std::collections::HashMap;

    fn make_test_inventory() -> TemplateTags {
        // Create a minimal inventory for testing
        // Note: This requires TemplateTags::new() or similar constructor from M1
        TemplateTags::new(
            HashMap::from([
                ("i18n".to_string(), "django.templatetags.i18n".to_string()),
                ("static".to_string(), "django.templatetags.static".to_string()),
            ]),
            vec!["django.template.defaulttags".to_string()],
            vec![
                // Builtin
                djls_project::TemplateTag::new_builtin(
                    "if",
                    "django.template.defaulttags",
                    None,
                ),
                // Library tags
                djls_project::TemplateTag::new_library(
                    "trans",
                    "i18n",
                    "django.templatetags.i18n",
                    None,
                ),
                djls_project::TemplateTag::new_library(
                    "blocktrans",
                    "i18n",
                    "django.templatetags.i18n",
                    None,
                ),
                djls_project::TemplateTag::new_library(
                    "static",
                    "static",
                    "django.templatetags.static",
                    None,
                ),
            ],
        )
    }

    #[test]
    fn test_builtins_always_available() {
        let loaded = LoadedLibraries::new();
        let inventory = make_test_inventory();

        let available = available_tags_at(&loaded, &inventory, 0);

        assert!(available.has_tag("if"), "Builtins should always be available");
        assert!(!available.has_tag("trans"), "Library tags should NOT be available without load");
    }

    #[test]
    fn test_library_tag_after_load() {
        let mut loaded = LoadedLibraries::new();
        loaded.push(LoadStatement {
            span: Span::new(0, 15),  // {% load i18n %}
            kind: LoadKind::Libraries(vec!["i18n".to_string()]),
        });
        let inventory = make_test_inventory();

        // Before the load tag ends
        let before = available_tags_at(&loaded, &inventory, 5);
        assert!(!before.has_tag("trans"), "trans should not be available inside load tag");

        // After the load tag
        let after = available_tags_at(&loaded, &inventory, 20);
        assert!(after.has_tag("trans"), "trans should be available after load");
        assert!(after.has_tag("blocktrans"), "blocktrans should be available after load");
        assert!(!after.has_tag("static"), "static should NOT be available (not loaded)");
    }

    #[test]
    fn test_selective_import() {
        let mut loaded = LoadedLibraries::new();
        loaded.push(LoadStatement {
            span: Span::new(0, 30),  // {% load trans from i18n %}
            kind: LoadKind::Selective {
                symbols: vec!["trans".to_string()],
                library: "i18n".to_string(),
            },
        });
        let inventory = make_test_inventory();

        let available = available_tags_at(&loaded, &inventory, 50);

        assert!(available.has_tag("trans"), "trans should be available (selectively imported)");
        assert!(!available.has_tag("blocktrans"), "blocktrans should NOT be available (not in selective import)");
    }

    #[test]
    fn test_selective_then_full_load() {
        let mut loaded = LoadedLibraries::new();
        // First: {% load trans from i18n %}
        loaded.push(LoadStatement {
            span: Span::new(0, 30),
            kind: LoadKind::Selective {
                symbols: vec!["trans".to_string()],
                library: "i18n".to_string(),
            },
        });
        // Later: {% load i18n %}
        loaded.push(LoadStatement {
            span: Span::new(100, 15),
            kind: LoadKind::Libraries(vec!["i18n".to_string()]),
        });
        let inventory = make_test_inventory();

        // After selective, before full
        let middle = available_tags_at(&loaded, &inventory, 50);
        assert!(middle.has_tag("trans"));
        assert!(!middle.has_tag("blocktrans"));

        // After full load - THIS IS THE KEY TEST
        // The state-machine approach ensures full load clears selective state
        let after = available_tags_at(&loaded, &inventory, 150);
        assert!(after.has_tag("trans"), "trans still available after full load");
        assert!(after.has_tag("blocktrans"), "blocktrans NOW available after full load");
    }

    #[test]
    fn test_full_then_selective_no_effect() {
        let mut loaded = LoadedLibraries::new();
        // First: {% load i18n %}
        loaded.push(LoadStatement {
            span: Span::new(0, 15),
            kind: LoadKind::Libraries(vec!["i18n".to_string()]),
        });
        // Later: {% load trans from i18n %} - should be no-op since lib already loaded
        loaded.push(LoadStatement {
            span: Span::new(100, 30),
            kind: LoadKind::Selective {
                symbols: vec!["trans".to_string()],
                library: "i18n".to_string(),
            },
        });
        let inventory = make_test_inventory();

        // After both loads - all i18n tags should still be available
        let after = available_tags_at(&loaded, &inventory, 200);
        assert!(after.has_tag("trans"));
        assert!(after.has_tag("blocktrans"), "Full load takes precedence");
    }

    #[test]
    fn test_multiple_selective_same_lib() {
        let mut loaded = LoadedLibraries::new();
        // First: {% load trans from i18n %}
        loaded.push(LoadStatement {
            span: Span::new(0, 30),
            kind: LoadKind::Selective {
                symbols: vec!["trans".to_string()],
                library: "i18n".to_string(),
            },
        });
        // Later: {% load blocktrans from i18n %}
        loaded.push(LoadStatement {
            span: Span::new(100, 35),
            kind: LoadKind::Selective {
                symbols: vec!["blocktrans".to_string()],
                library: "i18n".to_string(),
            },
        });
        let inventory = make_test_inventory();

        // After first selective
        let middle = available_tags_at(&loaded, &inventory, 50);
        assert!(middle.has_tag("trans"));
        assert!(!middle.has_tag("blocktrans"));

        // After second selective - both should be available
        let after = available_tags_at(&loaded, &inventory, 200);
        assert!(after.has_tag("trans"));
        assert!(after.has_tag("blocktrans"));
    }
}
```

### Success Criteria:

#### Automated Verification:

- [ ] Cargo build passes: `cargo build -p djls-semantic`
- [ ] All unit tests pass: `cargo test -p djls-semantic`
- [ ] Clippy passes: `cargo clippy -p djls-semantic --all-targets -- -D warnings`

---
