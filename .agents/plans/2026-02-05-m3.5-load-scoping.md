# M3: Load Scoping - Phase 5

> **Parent document**: [M3: Load Scoping Overview](2026-02-05-m3-load-scoping.md)

---

## Phase 5: Completions Integration

### Overview

Update completions to filter tags based on load state at cursor position.

### Changes Required:

#### 1. Update generate_tag_name_completions Signature

**File**: `crates/djls-ide/src/completions.rs` **Changes**: Add loaded_libraries parameter

First, update the function signature:

```rust
/// Generate completions for tag names
#[allow(clippy::too_many_arguments)]
fn generate_tag_name_completions(
    partial: &str,
    needs_space: bool,
    closing: &ClosingBrace,
    template_tags: Option<&TemplateTags>,
    tag_specs: Option<&TagSpecs>,
    loaded_libraries: Option<&LoadedLibraries>,  // NEW
    cursor_byte_offset: u32,                      // NEW
    supports_snippets: bool,
    position: ls_types::Position,
    line_text: &str,
    cursor_offset: usize,
) -> Vec<ls_types::CompletionItem> {
```

#### 2. Update the Function Body

**File**: `crates/djls-ide/src/completions.rs` **Changes**: Add filtering logic

```rust
fn generate_tag_name_completions(
    partial: &str,
    needs_space: bool,
    closing: &ClosingBrace,
    template_tags: Option<&TemplateTags>,
    tag_specs: Option<&TagSpecs>,
    loaded_libraries: Option<&LoadedLibraries>,
    cursor_byte_offset: u32,
    supports_snippets: bool,
    position: ls_types::Position,
    line_text: &str,
    cursor_offset: usize,
) -> Vec<ls_types::CompletionItem> {
    let Some(tags) = template_tags else {
        return Vec::new();
    };

    // Compute available tags at cursor position
    let available = if let Some(loaded) = loaded_libraries {
        Some(djls_semantic::available_tags_at(loaded, tags, cursor_byte_offset))
    } else {
        None  // No load info = show all tags (fallback)
    };

    let mut completions = Vec::new();

    // ... existing end tag completion logic ...

    for tag in tags.iter() {
        // Filter by partial match
        if !tag.name().starts_with(partial) {
            continue;
        }

        // Filter by availability (if we have load info)
        // When inspector unavailable (available = None), show all tags (fallback)
        if let Some(ref avail) = available {
            if !avail.has_tag(tag.name()) {
                // Tag not available at this position - hide it
                // This is the correct behavior: only show what's actually available
                continue;
            }
        }
        // Note: When available = None (inspector unavailable), we show all tags
        // to avoid false negatives. This matches the validation behavior.

        // ... rest of existing completion item creation ...
    }

    completions
}
```

#### 3. Update Call Sites

**File**: `crates/djls-ide/src/completions.rs` **Changes**: Update `generate_template_completions` and `handle_completion`

First, update the main handler signature:

```rust
/// Main entry point for handling completion requests
#[must_use]
pub fn handle_completion(
    document: &TextDocument,
    position: ls_types::Position,
    encoding: PositionEncoding,
    file_kind: FileKind,
    template_tags: Option<&TemplateTags>,
    tag_specs: Option<&TagSpecs>,
    loaded_libraries: Option<&LoadedLibraries>,  // NEW
    supports_snippets: bool,
) -> Vec<ls_types::CompletionItem> {
    // ... existing code ...

    // Calculate byte offset for load scoping
    let byte_offset = calculate_byte_offset(document, position, encoding);

    generate_template_completions(
        &context,
        template_tags,
        tag_specs,
        loaded_libraries,  // NEW
        byte_offset,       // NEW
        supports_snippets,
        position,
        &line_info.text,
        line_info.cursor_offset,
    )
}

/// Calculate byte offset from line/character position
fn calculate_byte_offset(
    document: &TextDocument,
    position: ls_types::Position,
    encoding: PositionEncoding,
) -> u32 {
    let content = document.content();
    let lines: Vec<&str> = content.lines().collect();

    let mut byte_offset: usize = 0;

    // Add bytes for all complete lines before cursor
    for line in lines.iter().take(position.line as usize) {
        byte_offset += line.len() + 1; // +1 for newline
    }

    // Add bytes for characters in the current line up to cursor
    if let Some(line) = lines.get(position.line as usize) {
        let char_offset = match encoding {
            PositionEncoding::Utf16 => {
                // Convert UTF-16 offset to character count
                let mut char_count = 0;
                let mut utf16_count = 0;
                for ch in line.chars() {
                    if utf16_count >= position.character as usize {
                        break;
                    }
                    utf16_count += ch.len_utf16();
                    char_count += 1;
                }
                char_count
            }
            _ => position.character as usize,
        };

        // Convert character offset to byte offset
        byte_offset += line.chars().take(char_offset).map(char::len_utf8).sum::<usize>();
    }

    byte_offset as u32
}
```

Update `generate_template_completions`:

```rust
fn generate_template_completions(
    context: &TemplateCompletionContext,
    template_tags: Option<&TemplateTags>,
    tag_specs: Option<&TagSpecs>,
    loaded_libraries: Option<&LoadedLibraries>,  // NEW
    cursor_byte_offset: u32,                     // NEW
    supports_snippets: bool,
    position: ls_types::Position,
    line_text: &str,
    cursor_offset: usize,
) -> Vec<ls_types::CompletionItem> {
    match context {
        TemplateCompletionContext::TagName {
            partial,
            needs_space,
            closing,
        } => generate_tag_name_completions(
            partial,
            *needs_space,
            closing,
            template_tags,
            tag_specs,
            loaded_libraries,   // NEW
            cursor_byte_offset, // NEW
            supports_snippets,
            position,
            line_text,
            cursor_offset,
        ),
        // ... rest unchanged ...
    }
}
```

#### 4. Update Server Call Site

**File**: `crates/djls-server/src/server.rs` **Changes**: Pass loaded_libraries to completion handler

```rust
async fn completion(&self, params: ls_types::CompletionParams) -> LspResult<...> {
    let response = self.with_session_mut(|session| {
        let db = session.db();

        // ... existing code to get template_tags, tag_specs, etc. ...

        // NEW: Get loaded libraries if we have a parsed nodelist
        let loaded_libraries = file
            .and_then(|f| djls_templates::parse_template(db, f))
            .map(|nodelist| djls_semantic::compute_loaded_libraries(db, nodelist));

        let completions = djls_ide::handle_completion(
            &document,
            position,
            encoding,
            file_kind,
            template_tags.as_ref(),
            Some(&tag_specs),
            loaded_libraries.as_ref(),  // NEW
            supports_snippets,
        );

        // ...
    }).await;
}
```

### Success Criteria:

#### Automated Verification:

- [ ] Cargo build passes: `cargo build`
- [ ] All tests pass: `cargo test`
- [ ] Clippy passes: `cargo clippy --all-targets -- -D warnings`

#### Manual Verification:

- [ ] In a template without any `{% load %}`, verify only builtin tags appear in completions
- [ ] Add `{% load i18n %}` and verify i18n tags now appear in completions AFTER the load
- [ ] Position cursor BEFORE the `{% load i18n %}` and verify i18n tags do NOT appear
- [ ] Test `{% load trans from i18n %}` - verify only `trans` appears, not other i18n tags

**Implementation Note**: After completing this phase, pause for manual confirmation that completions behave correctly at different positions.
