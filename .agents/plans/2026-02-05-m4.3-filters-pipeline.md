# M4: Filters Pipeline - Phase 3

> **Parent document**: [M4: Filters Pipeline Overview](2026-02-05-m4-filters-pipeline.md)

---

## Phase 3: Filter Completions

### Overview

Implement filter completions when user types `{{ variable|` or `{{ variable|part`.

### Changes Required:

#### 1. Update Context Detection

**File**: `crates/djls-ide/src/completions.rs`
**Changes**: Extend `analyze_template_context` to detect `{{ var|` (around line 161)

```rust
/// The closing state for a variable/filter context
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum VariableClosingBrace {
    None,         // No closing at all: `{{ var|`
    Partial,      // Single brace: `{{ var|fil}`
    Full,         // Complete: `{{ var|fil }}`
}

fn analyze_template_context(
    line: &str,
    cursor_offset: usize,
) -> Option<TemplateCompletionContext> {
    let prefix = &line[..cursor_offset];

    // Check for variable context first ({{ ... |)
    if let Some(var_ctx) = analyze_variable_context(prefix) {
        return Some(var_ctx);
    }

    // Existing tag context detection
    let tag_start = prefix.rfind("{%")?;
    // ... rest of existing logic ...
}

/// Detect filter completion context in `{{ var| }}` expressions.
///
/// Returns Some if cursor is after a `|` inside a variable expression.
fn analyze_variable_context(prefix: &str) -> Option<TemplateCompletionContext> {
    // Find the start of the variable expression
    let var_start = prefix.rfind("{{")?;
    let var_content = &prefix[var_start + 2..]; // Content after {{

    // Check if we're inside a filter (after |)
    let pipe_pos = var_content.rfind('|')?;

    // Everything after the last | is the partial filter name
    let after_pipe = &var_content[pipe_pos + 1..];
    let partial = after_pipe.trim().to_string();

    // Determine closing state
    let suffix_after_cursor = ""; // We only have prefix in this function
    let closing = VariableClosingBrace::None; // Simplified - can enhance later

    Some(TemplateCompletionContext::Filter {
        partial,
        closing,
    })
}
```

#### 2. Update Filter Context Enum

**File**: `crates/djls-ide/src/completions.rs`
**Changes**: Update Filter variant (around line 67)

```rust
/// TODO: Future - completing filters after |
Filter {
    /// Partial filter name typed so far
    partial: String,
    /// Closing brace state
    closing: VariableClosingBrace,
},
```

#### 3. Implement Filter Completion Generation

**File**: `crates/djls-ide/src/completions.rs`
**Changes**: Add function after `generate_library_completions`

```rust
/// Generate completions for filter names in `{{ var|` context.
fn generate_filter_completions(
    partial: &str,
    closing: &VariableClosingBrace,
    inventory: Option<&InspectorInventory>,
    loaded_libraries: Option<&LoadedLibraries>,
    cursor_byte_offset: u32,
) -> Vec<ls_types::CompletionItem> {
    let Some(inv) = inventory else {
        return Vec::new();
    };

    // Compute available filters at cursor position (reuse M3 infrastructure)
    let available = if let Some(loaded) = loaded_libraries {
        Some(available_filters_at(loaded, inv, cursor_byte_offset))
    } else {
        None // No load info = show all filters (fallback)
    };

    let mut completions = Vec::new();

    for filter in inv.filters() {
        // Filter by partial match
        if !filter.name().starts_with(partial) {
            continue;
        }

        // Filter by availability (if we have load info)
        if let Some(ref avail) = available {
            if !avail.has_filter(filter.name()) {
                continue;
            }
        }

        let mut insert_text = filter.name().to_string();

        // Add closing if needed
        match closing {
            VariableClosingBrace::None => insert_text.push_str(" }}"),
            VariableClosingBrace::Partial => insert_text.push('}'),
            VariableClosingBrace::Full => {}
        }

        completions.push(ls_types::CompletionItem {
            label: filter.name().to_string(),
            kind: Some(ls_types::CompletionItemKind::FUNCTION),
            detail: Some(if let Some(lib) = filter.library_load_name() {
                format!("Filter from {} ({{% load {} %}})", filter.defining_module(), lib)
            } else {
                format!("Builtin filter from {}", filter.defining_module())
            }),
            documentation: filter.doc().map(|d| {
                ls_types::Documentation::MarkupContent(ls_types::MarkupContent {
                    kind: ls_types::MarkupKind::Markdown,
                    value: d.to_string(),
                })
            }),
            insert_text: Some(insert_text),
            insert_text_format: Some(ls_types::InsertTextFormat::PLAIN_TEXT),
            filter_text: Some(filter.name().to_string()),
            ..Default::default()
        });
    }

    completions
}
```

#### 4. Wire Up in Match Statement

**File**: `crates/djls-ide/src/completions.rs`
**Changes**: Update the match (around line 327)

```rust
TemplateCompletionContext::Filter { partial, closing } => {
    generate_filter_completions(
        &partial,
        &closing,
        inspector_inventory,  // Unified inventory
        loaded_libraries,
        cursor_byte_offset,
    )
}
```

#### 5. Update Handler Signature

**File**: `crates/djls-ide/src/completions.rs`
**Changes**: Use `InspectorInventory` instead of separate types

```rust
use djls_project::InspectorInventory;

#[must_use]
pub fn handle_completion(
    document: &TextDocument,
    position: ls_types::Position,
    encoding: PositionEncoding,
    file_kind: FileKind,
    inspector_inventory: Option<&InspectorInventory>,  // COMBINED - contains both tags and filters
    tag_specs: Option<&TagSpecs>,
    loaded_libraries: Option<&LoadedLibraries>,
    supports_snippets: bool,
) -> Vec<ls_types::CompletionItem> {
    // ... extract tags and filters from inventory as needed
}
```

#### 6. Update Server Call Site

**File**: `crates/djls-server/src/server.rs`
**Changes**: Pass unified inventory from Project

```rust
async fn completion(&self, params: ls_types::CompletionParams) -> LspResult<...> {
    let response = self.with_session_mut(|session| {
        let db = session.db();

        // ... existing code ...

        // Get inspector inventory from Project (M2 pattern - reads Salsa input)
        let inspector_inventory = project
            .and_then(|p| p.inspector_inventory(db).as_ref());

        let completions = djls_ide::handle_completion(
            &document,
            position,
            encoding,
            file_kind,
            inspector_inventory,  // Contains both tags and filters
            Some(&tag_specs),
            loaded_libraries.as_ref(),
            supports_snippets,
        );

        // ...
    }).await;
}
```

### Success Criteria:

#### Automated Verification:

- [ ] Cargo build passes: `cargo build`
- [ ] All tests pass: `cargo test`
- [ ] Clippy passes: `cargo clippy --all-targets -- -D warnings`

#### Manual Verification:

- [ ] Open template, type `{{ value|` - verify filter completions appear
- [ ] Type `{{ value|def` - verify `default` completion appears
- [ ] Verify builtin filters (title, upper, date, etc.) appear without any `{% load %}`
- [ ] Add `{% load i18n %}`, verify i18n-specific filters appear after the load

**Implementation Note**: After completing this phase, pause for manual confirmation that completions work correctly.

---
