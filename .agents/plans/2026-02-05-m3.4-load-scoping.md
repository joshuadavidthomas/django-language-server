# M3: Load Scoping - Phase 4

> **Parent document**: [M3: Load Scoping Overview](2026-02-05-m3-load-scoping.md)

---

## Phase 4: Validation Integration - Unknown Tag Diagnostics

### Overview
Integrate load scoping into tag validation to produce diagnostics for:
1. Unknown tags (not in inventory at all)
2. Unloaded library tags (in inventory but library not loaded)

### Changes Required:

#### 1. Add New Error Variants
**File**: `crates/djls-semantic/src/errors.rs`
**Changes**: Add new variants for load scoping errors

```rust
#[derive(Clone, Debug, Error, PartialEq, Eq, Serialize)]
pub enum ValidationError {
    // ... existing variants ...

    #[error("Unknown tag '{tag}'")]
    UnknownTag { tag: String, span: Span },

    #[error("Tag '{tag}' requires '{{% load {library} %}}'")]
    UnloadedLibraryTag {
        tag: String,
        library: String,
        span: Span,
    },

    #[error("Tag '{tag}' requires one of: {}", libraries.iter().map(|l| format!("{{% load {} %}}", l)).collect::<Vec<_>>().join(", "))]
    AmbiguousUnloadedTag {
        tag: String,
        /// All libraries that define this tag (for disambiguation)
        libraries: Vec<String>,
        span: Span,
    },
}
```

**Note on collision handling**: Per the charter's collision guidance ("don't guess"), when multiple libraries define the same tag name and none are loaded, we emit `AmbiguousUnloadedTag` listing all candidate libraries rather than picking one arbitrarily.

#### 2. Add Diagnostic Codes
**File**: `crates/djls-ide/src/diagnostics.rs`
**Changes**: Add codes for new errors (around line 57-80)

```rust
impl DiagnosticError for ValidationError {
    fn code(&self) -> &'static str {
        match self {
            // ... existing codes S100-S107 ...
            ValidationError::UnknownTag { .. } => "S108",
            ValidationError::UnloadedLibraryTag { .. } => "S109",
            ValidationError::AmbiguousUnloadedTag { .. } => "S110",
        }
    }

    fn span(&self) -> Option<(u32, u32)> {
        match self {
            // ... existing cases ...
            ValidationError::UnknownTag { span, .. }
            | ValidationError::UnloadedLibraryTag { span, .. }
            | ValidationError::AmbiguousUnloadedTag { span, .. } => Some(span.into()),
        }
    }
}
```

#### 3. Update Db Trait
**File**: `crates/djls-semantic/src/db.rs`
**Changes**: Add inspector inventory accessor

```rust
use djls_project::TemplateTags;

#[salsa::db]
pub trait Db: TemplateDb {
    // ... existing methods ...

    /// Get the inspector inventory for load scoping validation.
    /// Returns None if inspector is unavailable.
    fn inspector_inventory(&self) -> Option<TemplateTags>;
}
```

#### 4. Implement in DjangoDatabase
**File**: `crates/djls-server/src/db.rs`
**Changes**: Add implementation

```rust
#[salsa::db]
impl SemanticDb for DjangoDatabase {
    // ... existing methods ...

    fn inspector_inventory(&self) -> Option<djls_project::TemplateTags> {
        self.project()
            .and_then(|project| project.inspector_inventory(self).clone())
    }
}
```

#### 5. Add Tag Scoping Validation
**File**: `crates/djls-semantic/src/load_resolution.rs`
**Changes**: Add validation function

```rust
use crate::ValidationError;
use crate::ValidationErrorAccumulator;
use djls_templates::tokens::TagDelimiter;
use salsa::Accumulator;

/// Entry for a tag in the inventory lookup.
/// 
/// We use Vec<String> for libraries because multiple libraries can define
/// the same tag name (collision). We need all candidates for proper error messages.
#[derive(Debug, Clone)]
enum TagInventoryEntry {
    /// Tag is a builtin (always available)
    Builtin,
    /// Tag requires loading one of these libraries
    Libraries(Vec<String>),
}

/// Build a lookup from tag name to inventory entry.
/// 
/// **IMPORTANT**: This handles the case where multiple libraries define the
/// same tag name by collecting ALL candidate libraries, not just the first one.
/// This is essential for correct error messages.
fn build_tag_inventory(inventory: &TemplateTags) -> FxHashMap<String, TagInventoryEntry> {
    let mut result: FxHashMap<String, TagInventoryEntry> = FxHashMap::default();
    
    for tag in inventory.iter() {
        let name = tag.name().clone();
        match tag.provenance() {
            TagProvenance::Builtin { .. } => {
                // Builtin takes precedence (always available)
                result.insert(name, TagInventoryEntry::Builtin);
            }
            TagProvenance::Library { load_name, .. } => {
                // Add library to list of candidates for this tag
                // Use get_mut + insert pattern for clarity (FxHashMap Entry API works same as std)
                if let Some(entry) = result.get_mut(&name) {
                    // Don't override Builtin
                    if let TagInventoryEntry::Libraries(libs) = entry {
                        if !libs.contains(load_name) {
                            libs.push(load_name.clone());
                        }
                    }
                } else {
                    result.insert(name, TagInventoryEntry::Libraries(vec![load_name.clone()]));
                }
            }
        }
    }
    
    result
}

/// Validate that all tags in the template are either builtins or from loaded libraries.
/// 
/// This function:
/// 1. Computes which libraries are loaded at each position
/// 2. For each tag, checks if it's available at that position
/// 3. Accumulates errors for unknown or unloaded tags
/// 
/// # Behavior
/// - If inventory is None (inspector unavailable), skip validation entirely
/// - Builtins are always valid
/// - Library tags require their library to be loaded before use
/// 
/// # Collision Handling
/// When multiple libraries define the same tag name:
/// - If ONE of them is loaded, the tag is valid (Django resolves at runtime)
/// - If NONE are loaded, emit S110 (AmbiguousUnloadedTag) listing all candidates
///   rather than guessing which library to suggest
/// 
/// # TagSpecs Interaction
/// Tags with structural specs (openers, closers, intermediates) are skipped:
/// - They're validated by block structure (S100-S103) and argument validation (S104-S107)
/// - This prevents emitting S108 for "endif" when inspector doesn't list it
/// - Closers like "endif" derive from opener spec, not inventory
#[salsa::tracked]
pub fn validate_tag_scoping(
    db: &dyn crate::Db,
    nodelist: djls_templates::NodeList<'_>,
) {
    // Get inventory - if unavailable, skip validation
    let Some(inventory) = db.inspector_inventory() else {
        tracing::debug!("Inspector inventory unavailable, skipping tag scoping validation");
        return;
    };

    // Compute load state
    let loaded = compute_loaded_libraries(db, nodelist);
    
    // Build lookup with collision handling
    let tag_inventory = build_tag_inventory(&inventory);

    // Validate each tag
    for node in nodelist.nodelist(db) {
        if let Node::Tag { name, span, .. } = node {
            // Skip the load tag itself
            if name == "load" {
                continue;
            }
            
            // Skip tags that have structural meaning via TagSpecs
            // These are validated by block structure validation (S100-S103) and
            // argument validation (S104-S107), not by load scoping.
            // 
            // This includes:
            // - Opening tags (e.g., "if", "for") → tag_specs.get(name)
            // - Closing tags (e.g., "endif", "endfor") → tag_specs.get_end_spec_for_closer(name)
            // - Intermediate tags (e.g., "else", "elif") → tag_specs.get_intermediate_spec(name)
            //
            // If a tag has a spec, it's "known" structurally even if we don't have
            // inspector inventory. We don't want to emit S108 for "endif" just because
            // the inspector is unavailable or doesn't list it separately.
            let tag_specs = db.tag_specs();
            let has_spec = tag_specs.get(name).is_some()
                || tag_specs.get_end_spec_for_closer(name).is_some()
                || tag_specs.get_intermediate_spec(name).is_some();
            
            let marker_span = span.expand(TagDelimiter::LENGTH_U32, TagDelimiter::LENGTH_U32);
            
            match tag_inventory.get(name) {
                None => {
                    // Tag not in inventory at all
                    if !has_spec {
                        ValidationErrorAccumulator(ValidationError::UnknownTag {
                            tag: name.clone(),
                            span: marker_span,
                        })
                        .accumulate(db);
                    }
                }
                Some(TagInventoryEntry::Builtin) => {
                    // Builtins always valid
                }
                Some(TagInventoryEntry::Libraries(candidate_libs)) => {
                    // Check if tag is available at this position
                    let available = available_tags_at(&loaded, &inventory, span.start());
                    
                    if !available.has_tag(name) {
                        // Tag not available - emit appropriate error
                        if candidate_libs.len() == 1 {
                            // Single library - simple error message
                            ValidationErrorAccumulator(ValidationError::UnloadedLibraryTag {
                                tag: name.clone(),
                                library: candidate_libs[0].clone(),
                                span: marker_span,
                            })
                            .accumulate(db);
                        } else {
                            // Multiple libraries define this tag - ambiguous
                            // Per charter: "don't guess", list all candidates
                            ValidationErrorAccumulator(ValidationError::AmbiguousUnloadedTag {
                                tag: name.clone(),
                                libraries: candidate_libs.clone(),
                                span: marker_span,
                            })
                            .accumulate(db);
                        }
                    }
                    // If available, the tag is valid (even with collisions,
                    // Django resolves at runtime based on load order)
                }
            }
        }
    }
}
```

**Collision handling rationale**: When multiple libraries define the same tag (e.g., both `myapp.templatetags.tags` and `otherapp.templatetags.tags` define `{% mytag %}`), we cannot know which one Django will use at runtime — it depends on the order of `{% load %}` statements. Per the charter's collision guidance, we "don't guess" and instead:
- If ANY of the candidate libraries is loaded, accept the tag as valid
- If NONE are loaded, emit S110 listing all candidates so the user can choose

#### 6. Wire into validate_nodelist
**File**: `crates/djls-semantic/src/lib.rs`
**Changes**: Add call to new validation

```rust
#[salsa::tracked]
pub fn validate_nodelist(db: &dyn Db, nodelist: djls_templates::NodeList<'_>) {
    if nodelist.nodelist(db).is_empty() {
        return;
    }

    let block_tree = build_block_tree(db, nodelist);
    let _forest = build_semantic_forest(db, block_tree, nodelist);
    validate_all_tag_arguments(db, nodelist);
    
    // NEW: Validate tag scoping (load requirements)
    load_resolution::validate_tag_scoping(db, nodelist);
}
```

### Success Criteria:

#### Automated Verification:
- [ ] Cargo build passes: `cargo build`
- [ ] All tests pass: `cargo test`
- [ ] Clippy passes: `cargo clippy --all-targets -- -D warnings`

#### Manual Verification:
- [ ] Create template with `{% trans "hello" %}` without `{% load i18n %}` - verify S109 diagnostic
- [ ] Add `{% load i18n %}` before the tag - verify no diagnostic
- [ ] Use a completely unknown tag `{% nonexistent %}` - verify S108 diagnostic

**Implementation Note**: After completing this phase, pause for manual confirmation that diagnostics appear correctly in the editor.

---

