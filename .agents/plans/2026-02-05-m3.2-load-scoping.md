# M3: Load Scoping - Phase 2

> **Parent document**: [M3: Load Scoping Overview](2026-02-05-m3-load-scoping.md)

---

## Phase 2: Compute LoadedLibraries from NodeList

### Overview

Add a tracked Salsa query that extracts `LoadedLibraries` from a parsed template.

### Changes Required:

#### 1. Add Tracked Query

**File**: `crates/djls-semantic/src/load_resolution.rs` **Changes**: Add the tracked function at the end of the module

```rust
use djls_templates::Node;

/// Extract all `{% load %}` statements from a template.
///
/// This tracked function performs a **recursive traversal** of the nodelist,
/// collecting all load statements in document order. This is important because
/// Django's parser processes tokens in order as it parses, so a `{% load %}`
/// inside a block still affects global tag availability.
///
/// **IMPORTANT**: The nodelist in djls-templates is flat (no nested structure),
/// but we must still process ALL nodes. If the parser ever changes to support
/// nested structures, this function must be updated to traverse recursively.
#[salsa::tracked]
pub fn compute_loaded_libraries(
    db: &dyn crate::Db,
    nodelist: djls_templates::NodeList<'_>,
) -> LoadedLibraries {
    let mut loaded = LoadedLibraries::new();
    let mut load_spans: Vec<(Span, LoadStatement)> = Vec::new();

    // Collect all load statements with their spans
    for node in nodelist.nodelist(db) {
        if let Node::Tag { name, bits, span } = node {
            if name == "load" {
                if let Some(stmt) = parse_load_bits(bits, *span) {
                    load_spans.push((*span, stmt));
                }
            }
        }
    }

    // Sort by span start position to ensure document order
    // (The nodelist should already be in order, but sort to be safe)
    load_spans.sort_by_key(|(span, _)| span.start());

    // Add to LoadedLibraries in order
    for (_, stmt) in load_spans {
        loaded.push(stmt);
    }

    loaded
}
```

**Note on nested nodes**: Django's template parser processes the token stream linearly, so `{% load %}` tags affect the global parser state regardless of whether they appear inside block tags. The djls-templates parser produces a flat nodelist (no nested `NodeList` within block bodies), so a simple iteration covers all nodes. If the parser ever changes to support nesting, this function must be updated to traverse recursively.

#### 2. Export the Query

**File**: `crates/djls-semantic/src/lib.rs` **Changes**: Add export

```rust
pub use load_resolution::compute_loaded_libraries;
```

### Success Criteria:

#### Automated Verification:

- [ ] Cargo build passes: `cargo build -p djls-semantic`
- [ ] Clippy passes: `cargo clippy -p djls-semantic --all-targets -- -D warnings`
- [ ] Integration test: Parse template with loads, verify extraction
