# M5: Extraction Engine - Phase 5

> **Parent document**: [M5: Extraction Engine Overview](2026-02-05-m5-extraction-engine.md)

---

## Phase 5: Implement Block Spec Extraction (Control-Flow Based)

### Overview

Extract block structure from `parser.parse((...))` calls. **Critically**, end tags are inferred from control flow patterns, NOT from string heuristics.

**End-tag inference strategy**:

1. Collect all stop-tag tuples from `parser.parse((...))` calls
2. A stop tag that appears as the **sole element in a singleton tuple** is likely the closer
3. If multiple different singletons exist, or if ambiguous, return `None` for `end_tag`
4. All other stop tags become intermediates

### Changes Required:

#### 1. Implement structural.rs

**File**: `crates/djls-extraction/src/structural.rs`

````rust
//! Block structure extraction from parser.parse() calls.
//!
//! ## End-Tag Inference Strategy
//!
//! **NEVER GUESS.** We do NOT invent end tags from thin air. We only return
//! `end_tag: Some(...)` when the source code provides clear evidence.
//!
//! We apply three strategies in order, stopping at the first match:
//!
//! 1. **Singleton pattern** (HIGH CONFIDENCE): If `parser.parse((<single>,))`
//!    appears with exactly one unique stop tag, that tag is the closer:
//!    ```python
//!    nodelist = parser.parse(("elif", "else", "endif"))  # multiple stops
//!    nodelist = parser.parse(("endif",))                 # singleton → closer
//!    ```
//!
//! 2. **Unique stop tag** (HIGH CONFIDENCE): If only one stop tag is ever
//!    referenced across ALL `parser.parse()` calls, it's the closer.
//!
//! 3. **Django convention fallback** (CONSERVATIVE TIE-BREAKER FOR ALL BLOCK TAGS):
//!    If strategies 1 and 2 fail, AND there are no conflicting signals, check if
//!    `end{tag_name}` appears in the extracted stop-tag literals. This reflects
//!    Django's widespread convention (if→endif, for→endfor, block→endblock):
//!    ```python
//!    @register.tag
//!    def foo(parser, token):
//!        # No singleton, multiple stop tags, but "endfoo" is present
//!        nodelist = parser.parse(("middle", "endfoo"))
//!        return Node(nodelist)
//!    ```
//!    If `endfoo` appears in stop tags, select it as the closer.
//!    **CRITICAL**: This is a tie-breaker, NOT a primary signal. We do NOT invent
//!    `end{tag_name}` — it must actually appear in the source's stop-tag literals.
//!
//! **Note**: `@register.simple_block_tag` has ADDITIONAL decorator-defined semantics:
//! Django hardcodes `end_name = f"end{function_name}"` as the default (library.py:190).
//! This is applied even without stop-tag analysis for that specific decorator.
//!
//! **ALL OTHER CASES → `end_tag: None`**:
//! - Multiple different singleton patterns (ambiguous)
//! - `end{tag_name}` not present in stop-tag literals
//! - Dynamic/computed stop tags (f-strings, variables)
//! - Any competing signals or uncertainty
//!
//! This conservative approach ensures we never emit incorrect block specs.
//! Better to skip extraction than produce wrong validation rules.

use ruff_python_ast::Expr;
use ruff_python_ast::Mod;
use ruff_python_ast::Stmt;

use crate::context::FunctionContext;
use crate::parser::ParsedModule;
use crate::patterns;
use crate::registry::RegistrationInfo;
use crate::types::BlockTagSpec;
use crate::types::IntermediateTagSpec;
use crate::ExtractionError;

/// Extract block specification from a tag function.
///
/// ## Two Distinct Mechanisms for `end{tag}` Closer Selection
///
/// ### 1. Decorator-Defined Default (simple_block_tag ONLY)
///
/// `@register.simple_block_tag` is special: Django's decorator itself hardcodes
/// `end_name = f"end{function_name}"` when not explicitly provided (library.py:190).
/// This is a **Django-defined semantic** for this specific decorator, applied even
/// without analyzing function body. Other decorators don't have this behavior.
///
/// ### 2. Convention Fallback Tie-Breaker (ALL block tags)
///
/// For ALL block tags (including `@register.tag`), after control-flow inference fails,
/// we check if `end{tag_name}` appears in the extracted stop-tag literals. This is
/// Django's **widespread convention** (if→endif, for→endfor, block→endblock), used
/// as a tie-breaker when:
/// - Singleton/unique-stop-tag inference didn't yield a closer
/// - No ambiguity (multiple singletons) exists
/// - `end{tag_name}` is ACTUALLY PRESENT in stop-tag literals
///
/// The convention fallback is NOT a global default — it only selects `end{tag_name}`
/// when the source code contains it. We never invent closers.
///
/// ## Priority Order
///
/// 1. Explicit `end_name` from decorator (highest confidence)
/// 2. Singleton parse pattern (`parser.parse(("end...",))`)
/// 3. Unique stop tag (only one ever mentioned)
/// 4. Django convention fallback (`end{tag}` in stop-tags, tie-breaker)
/// 5. `simple_block_tag` decorator default (Django-defined semantic)
/// 6. None (ambiguous or no signals)
pub fn extract_block_spec(
    parsed: &ParsedModule,
    registration: &RegistrationInfo,
    _ctx: &FunctionContext,
) -> Result<Option<BlockTagSpec>, ExtractionError> {
    // HIGH-CONFIDENCE PATH: explicit end_name from decorator
    // @register.simple_block_tag(end_name="endmytag") → use directly
    if let Some(ref explicit_end) = registration.explicit_end_name {
        return Ok(Some(BlockTagSpec {
            end_tag: Some(explicit_end.clone()),
            intermediate_tags: vec![],  // simple_block_tag doesn't support intermediates
            opaque: false,
        }));
    }

    // DJANGO-DEFINED SEMANTIC DEFAULT (simple_block_tag ONLY):
    // Django's simple_block_tag decorator hardcodes `end_name = f"end{function_name}"`
    // when no explicit end_name is provided (see django/template/library.py:190).
    //
    // This is NOT a generic heuristic — it's Django's documented behavior for this
    // specific decorator. We apply it ONLY to SimpleBlockTag, never to other tag types.
    let django_default_end = if matches!(registration.decorator_kind, DecoratorKind::SimpleBlockTag) {
        Some(format!("end{}", registration.function_name))
    } else {
        None  // Other decorators: no default, use control-flow inference only
    };

    let Mod::Module(module) = parsed.ast() else {
        // If SimpleBlockTag, return Django's default even without function body analysis
        if let Some(default_end) = django_default_end {
            return Ok(Some(BlockTagSpec {
                end_tag: Some(default_end),
                intermediate_tags: vec![],
                opaque: false,
            }));
        }
        return Ok(None);
    };

    let func_def = module.body.iter().find_map(|stmt| {
        if let Stmt::FunctionDef(fd) = stmt {
            if fd.name.as_str() == registration.function_name {
                return Some(fd);
            }
        }
        None
    });

    let Some(func_def) = func_def else {
        // If SimpleBlockTag, return Django's default
        if let Some(default_end) = django_default_end {
            return Ok(Some(BlockTagSpec {
                end_tag: Some(default_end),
                intermediate_tags: vec![],
                opaque: false,
            }));
        }
        return Ok(None);
    };

    // Collect all parser.parse() stop-tag tuples
    let mut parse_calls: Vec<Vec<String>> = Vec::new();
    collect_parse_calls(&func_def.body, &mut parse_calls);

    // For SimpleBlockTag with no parse calls, use Django's default
    if parse_calls.is_empty() {
        if let Some(default_end) = django_default_end {
            return Ok(Some(BlockTagSpec {
                end_tag: Some(default_end),
                intermediate_tags: vec![],
                opaque: false,
            }));
        }
        return Ok(None);
    }

    // Infer end tag from control flow patterns
    // Pass tag name for Django convention fallback (only used if present in stop-tags)
    let end_tag = infer_end_tag_from_control_flow(&parse_calls, &registration.name);

    // Collect all unique stop tags
    let mut all_stop_tags: Vec<String> = Vec::new();
    for stop_tags in &parse_calls {
        for tag in stop_tags {
            if !all_stop_tags.contains(tag) {
                all_stop_tags.push(tag.clone());
            }
        }
    }

    // Intermediate tags = all stop tags except the inferred end tag
    let intermediate_tags: Vec<IntermediateTagSpec> = all_stop_tags
        .into_iter()
        .filter(|t| end_tag.as_ref().map_or(true, |end| end != t))
        .map(|name| IntermediateTagSpec { name, repeatable: false })
        .collect();

    // Detect opaque blocks (verbatim-like): no intermediates, has closer, no compile_filter
    let opaque = intermediate_tags.is_empty()
        && end_tag.is_some()
        && !has_compile_filter_call(&func_def.body);

    if end_tag.is_none() && intermediate_tags.is_empty() {
        return Ok(None);
    }

    Ok(Some(BlockTagSpec {
        end_tag,
        intermediate_tags,
        opaque,
    }))
}

/// Infer the closer (end tag) from control flow patterns.
///
/// **NEVER GUESS.** Returns `Some` ONLY when evidence exists in the source:
/// 1. Singleton pattern: exactly one unique `parser.parse((<single>,))` call
/// 2. Unique stop tag: only one stop tag mentioned across all parse calls
/// 3. Django convention: `end{tag_name}` appears in stop-tag literals (tie-breaker only)
///
/// Returns `None` for ALL other cases — better to skip than guess wrong.
fn infer_end_tag_from_control_flow(
    parse_calls: &[Vec<String>],
    tag_name: &str,
) -> Option<String> {
    // Collect all unique stop tags first (needed for multiple strategies)
    let mut all_tags: Vec<&str> = Vec::new();
    for stop_tags in parse_calls {
        for tag in stop_tags {
            if !all_tags.contains(&tag.as_str()) {
                all_tags.push(tag.as_str());
            }
        }
    }

    // HIGH-CONFIDENCE STRATEGY 1: Singleton parse calls
    // If parser.parse((<single>,)) appears with exactly one unique tag, that's the closer
    let mut singletons: Vec<&str> = Vec::new();
    for stop_tags in parse_calls {
        if stop_tags.len() == 1 {
            let tag = stop_tags[0].as_str();
            if !singletons.contains(&tag) {
                singletons.push(tag);
            }
        }
    }

    // Exactly one unique singleton → high confidence, return it
    if singletons.len() == 1 {
        return Some(singletons[0].to_string());
    }

    // Multiple different singletons → AMBIGUOUS, return None (never guess)
    if singletons.len() > 1 {
        return None;
    }

    // HIGH-CONFIDENCE STRATEGY 2: Only one stop tag exists total
    if all_tags.len() == 1 {
        return Some(all_tags[0].to_string());
    }

    // CONSERVATIVE STRATEGY 3: Django convention fallback (tie-breaker)
    // Only applies if:
    // - Strategies 1 and 2 didn't match
    // - No conflicting signals (no singletons observed at all)
    // - The candidate `end{tag_name}` actually appears in stop-tag literals
    //
    // We do NOT invent the end tag — it must be present in the source.
    if singletons.is_empty() {
        let candidate = format!("end{}", tag_name);
        if all_tags.contains(&candidate.as_str()) {
            return Some(candidate);
        }
    }

    // ANYTHING ELSE → Cannot confidently determine, return None (never guess)
    None
}

fn collect_parse_calls(stmts: &[Stmt], results: &mut Vec<Vec<String>>) {
    for stmt in stmts {
        match stmt {
            Stmt::Expr(expr_stmt) => {
                if let Some(tags) = extract_parse_call_tags(&expr_stmt.value) {
                    results.push(tags);
                }
            }

            Stmt::Assign(assign) => {
                if let Some(tags) = extract_parse_call_tags(&assign.value) {
                    results.push(tags);
                }
            }

            Stmt::If(if_stmt) => {
                collect_parse_calls(&if_stmt.body, results);
                for clause in &if_stmt.elif_else_clauses {
                    collect_parse_calls(&clause.body, results);
                }
            }

            Stmt::While(while_stmt) => {
                collect_parse_calls(&while_stmt.body, results);
            }

            Stmt::For(for_stmt) => {
                collect_parse_calls(&for_stmt.body, results);
            }

            Stmt::Try(try_stmt) => {
                collect_parse_calls(&try_stmt.body, results);
            }

            _ => {}
        }
    }
}

fn extract_parse_call_tags(expr: &Expr) -> Option<Vec<String>> {
    let Expr::Call(call) = expr else { return None };
    let Expr::Attribute(attr) = call.func.as_ref() else { return None };

    if attr.attr.as_str() != "parse" {
        return None;
    }

    let first_arg = call.arguments.args.first()?;

    // Handle tuple: ("endfor", "empty")
    if let Expr::Tuple(tuple) = first_arg {
        let mut tags = Vec::new();
        for elt in &tuple.elts {
            if let Some(s) = patterns::extract_string_literal(elt) {
                tags.push(s);
            }
        }
        if !tags.is_empty() {
            return Some(tags);
        }
    }

    // Handle single string
    if let Some(s) = patterns::extract_string_literal(first_arg) {
        return Some(vec![s]);
    }

    None
}

fn has_compile_filter_call(stmts: &[Stmt]) -> bool {
    for stmt in stmts {
        match stmt {
            Stmt::Expr(expr_stmt) => {
                if is_compile_filter_call(&expr_stmt.value) {
                    return true;
                }
            }
            Stmt::Assign(assign) => {
                if is_compile_filter_call(&assign.value) {
                    return true;
                }
            }
            Stmt::If(if_stmt) => {
                if has_compile_filter_call(&if_stmt.body) {
                    return true;
                }
                for clause in &if_stmt.elif_else_clauses {
                    if has_compile_filter_call(&clause.body) {
                        return true;
                    }
                }
            }
            Stmt::While(while_stmt) => {
                if has_compile_filter_call(&while_stmt.body) {
                    return true;
                }
            }
            _ => {}
        }
    }
    false
}

fn is_compile_filter_call(expr: &Expr) -> bool {
    let Expr::Call(call) = expr else { return false };
    let Expr::Attribute(attr) = call.func.as_ref() else { return false };
    attr.attr.as_str() == "compile_filter"
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::extract_rules;

    #[test]
    fn test_singleton_closer_pattern() {
        // Django 'if' tag: "endif" is found via SINGLETON PATTERN (primary signal),
        // not via end{tag} heuristic. The singleton parser.parse(("endif",)) call
        // provides high-confidence evidence that "endif" is the closer.
        //
        // This demonstrates: even though "endif" matches the end{tag} convention,
        // we infer it from control-flow patterns, not from name matching.
        let source = r#"
@register.tag("if")
def do_if(parser, token):
    nodelist = parser.parse(("elif", "else", "endif"))
    token = parser.next_token()
    if token.contents == "else":
        nodelist = parser.parse(("endif",))
    return IfNode(nodelist)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // "endif" is selected because it appears as a singleton stop-tag,
        // NOT because it matches "end" + "if" naming convention
        assert_eq!(block_spec.end_tag, Some("endif".to_string()));

        // "elif" and "else" are intermediates (they never appear as singletons)
        let names: Vec<_> = block_spec.intermediate_tags.iter().map(|t| t.name.as_str()).collect();
        assert!(names.contains(&"elif"));
        assert!(names.contains(&"else"));
    }

    #[test]
    fn test_single_stop_tag() {
        // UNIQUE STOP-TAG PATTERN: When only one stop tag is ever mentioned,
        // it's the closer. This is a primary signal, not a convention fallback.
        let source = r#"
@register.tag
def my_block(parser, token):
    nodelist = parser.parse(("endmy_block",))
    return MyBlockNode(nodelist)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        assert_eq!(block_spec.end_tag, Some("endmy_block".to_string()));
        assert!(block_spec.intermediate_tags.is_empty());
    }

    #[test]
    fn test_generic_tag_with_non_conventional_closer() {
        // A tag using a closer that DOESN'T match end{tag} convention.
        // Proves we use control-flow inference, not naming heuristics.
        let source = r#"
@register.tag
def mywidget(parser, token):
    nodelist = parser.parse(("else_widget", "finish_widget"))
    if token.contents == "else_widget":
        nodelist2 = parser.parse(("finish_widget",))
    return WidgetNode(nodelist, nodelist2)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // "finish_widget" is the singleton, NOT "endmywidget"
        // This proves we infer from control flow, not name matching
        assert_eq!(block_spec.end_tag, Some("finish_widget".to_string()));
        assert_eq!(block_spec.intermediate_tags.len(), 1);
        assert_eq!(block_spec.intermediate_tags[0].name, "else_widget");
    }

    #[test]
    fn test_for_with_empty() {
        let source = r#"
@register.tag("for")
def do_for(parser, token):
    nodelist_loop = parser.parse(("empty", "endfor"))
    if token.contents == "empty":
        nodelist_empty = parser.parse(("endfor",))
    return ForNode(nodelist_loop, nodelist_empty)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // "endfor" appears as singleton
        assert_eq!(block_spec.end_tag, Some("endfor".to_string()));
        assert_eq!(block_spec.intermediate_tags.len(), 1);
        assert_eq!(block_spec.intermediate_tags[0].name, "empty");
    }

    #[test]
    fn test_no_block_spec_for_simple_tag() {
        let source = r#"
@register.simple_tag
def now(format_string):
    return datetime.now().strftime(format_string)
"#;
        let result = extract_rules(source).unwrap();
        assert!(result.tags[0].block_spec.is_none());
    }

    #[test]
    fn test_simple_block_tag_with_explicit_end_name() {
        // HIGH-CONFIDENCE PATH: explicit end_name is authoritative
        let source = r#"
@register.simple_block_tag(end_name="endmycustom")
def mycustom(context, nodelist):
    return nodelist.render(context)
"#;
        let result = extract_rules(source).unwrap();
        let tag = &result.tags[0];

        // Verify decorator kind is SimpleBlockTag, not Tag
        assert!(matches!(tag.decorator_kind, djls_extraction::DecoratorKind::SimpleBlockTag));

        // Verify explicit end_name is used directly
        let block_spec = tag.block_spec.as_ref().unwrap();
        assert_eq!(block_spec.end_tag, Some("endmycustom".to_string()));
        assert!(block_spec.intermediate_tags.is_empty());
    }

    #[test]
    fn test_simple_block_tag_without_end_name_uses_django_default() {
        // DJANGO-DEFINED SEMANTIC DEFAULT (simple_block_tag ONLY):
        // When end_name is omitted from @register.simple_block_tag, Django hardcodes
        // `end_name = f"end{function_name}"` (library.py:190). This is Django's
        // documented behavior for this decorator — NOT a generic heuristic.
        let source = r#"
@register.simple_block_tag
def myblock(context, nodelist):
    return nodelist.render(context)
"#;
        let result = extract_rules(source).unwrap();
        let tag = &result.tags[0];

        assert!(matches!(tag.decorator_kind, djls_extraction::DecoratorKind::SimpleBlockTag));

        // Django's semantic default for simple_block_tag: f"end{function_name}" = "endmyblock"
        let block_spec = tag.block_spec.as_ref().unwrap();
        assert_eq!(block_spec.end_tag, Some("endmyblock".to_string()));
    }

    #[test]
    fn test_simple_block_tag_with_custom_name() {
        // When tag name differs from function name
        let source = r#"
@register.simple_block_tag("customname", end_name="endcustom")
def my_internal_func(context, nodelist):
    return nodelist.render(context)
"#;
        let result = extract_rules(source).unwrap();
        let tag = &result.tags[0];

        // Tag name from decorator
        assert_eq!(tag.name, "customname");
        // Function name is different
        assert_eq!(tag.decorator_kind, djls_extraction::DecoratorKind::SimpleBlockTag);

        // Explicit end_name
        let block_spec = tag.block_spec.as_ref().unwrap();
        assert_eq!(block_spec.end_tag, Some("endcustom".to_string()));
    }

    #[test]
    fn test_helper_wrapper_decorator() {
        // Helper/wrapper decorators like register_simple_block_tag are recognized
        // but classified distinctly from register.simple_block_tag
        let source = r#"
@register_simple_block_tag(end_name="endhelper")
def helper_tag(context, nodelist):
    return nodelist.render(context)
"#;
        let result = extract_rules(source).unwrap();
        let tag = &result.tags[0];

        // Classified as HelperWrapper, not SimpleBlockTag
        assert!(matches!(
            tag.decorator_kind,
            djls_extraction::DecoratorKind::HelperWrapper(ref name) if name == "register_simple_block_tag"
        ));

        // Still extracts end_name
        let block_spec = tag.block_spec.as_ref().unwrap();
        assert_eq!(block_spec.end_tag, Some("endhelper".to_string()));
    }

    #[test]
    fn test_non_end_prefix_closer() {
        // Test that we DON'T rely on "end" prefix
        // This tag uses "finish_custom" as closer, not "endcustom"
        let source = r#"
@register.tag
def custom_block(parser, token):
    nodelist = parser.parse(("middle_custom", "finish_custom"))
    if token.contents == "middle_custom":
        nodelist2 = parser.parse(("finish_custom",))
    return CustomNode(nodelist, nodelist2)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // "finish_custom" is the singleton, so it's the closer
        assert_eq!(block_spec.end_tag, Some("finish_custom".to_string()));
        assert_eq!(block_spec.intermediate_tags.len(), 1);
        assert_eq!(block_spec.intermediate_tags[0].name, "middle_custom");
    }

    #[test]
    fn test_ambiguous_returns_none() {
        // Multiple different singletons — ambiguous
        let source = r#"
@register.tag
def confusing_block(parser, token):
    nodelist = parser.parse(("tag_a",))
    nodelist2 = parser.parse(("tag_b",))
    return Node(nodelist, nodelist2)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // Both are singletons, ambiguous — end_tag should be None
        assert_eq!(block_spec.end_tag, None);
    }

    #[test]
    fn test_django_convention_fallback() {
        // CONVENTION TIE-BREAKER FOR ALL BLOCK TAGS:
        // When singleton/unique-stop-tag inference fails, we check if `end{tag_name}`
        // appears in the extracted stop-tag literals. This reflects Django's widespread
        // convention (if→endif, for→endfor, block→endblock) but is NOT a primary signal.
        //
        // Here: no singleton, but "endfoo" (= end + foo) IS PRESENT in stop tags,
        // so we select it as closer via convention fallback.
        let source = r#"
@register.tag
def foo(parser, token):
    nodelist = parser.parse(("middle", "endfoo"))
    if some_condition:
        handle_middle()
    return FooNode(nodelist)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // "endfoo" is selected as closer because:
        // 1. It's present in stop-tag literals (we didn't invent it)
        // 2. It matches Django's end{tag} convention
        // 3. No ambiguity from multiple singletons
        assert_eq!(block_spec.end_tag, Some("endfoo".to_string()));
        assert_eq!(block_spec.intermediate_tags.len(), 1);
        assert_eq!(block_spec.intermediate_tags[0].name, "middle");
    }

    #[test]
    fn test_django_convention_not_invented() {
        // CRITICAL: We NEVER invent end tags. Convention fallback only works
        // when `end{tag_name}` is ACTUALLY PRESENT in stop-tag literals.
        //
        // Here: tag is "bar", but "endbar" does NOT appear in stop tags.
        // We should NOT invent it — end_tag must be None.
        let source = r#"
@register.tag
def bar(parser, token):
    nodelist = parser.parse(("stop_a", "stop_b"))
    return BarNode(nodelist)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // "endbar" not in stop tags → do NOT invent it, return None
        // This proves convention fallback only selects, never invents
        assert_eq!(block_spec.end_tag, None);
    }

    #[test]
    fn test_django_convention_blocked_by_singleton_ambiguity() {
        // "endfoo" appears in stop tags, BUT there are also multiple singletons
        // Ambiguity from singletons should block the convention fallback
        let source = r#"
@register.tag
def foo(parser, token):
    nodelist = parser.parse(("other",))
    nodelist2 = parser.parse(("another",))
    nodelist3 = parser.parse(("middle", "endfoo"))
    return FooNode(nodelist, nodelist2, nodelist3)
"#;
        let result = extract_rules(source).unwrap();
        let block_spec = result.tags[0].block_spec.as_ref().unwrap();

        // Multiple singletons ("other", "another") → ambiguous, convention blocked
        assert_eq!(block_spec.end_tag, None);
    }
}
````

### Success Criteria:

- [ ] Block spec tests pass: `cargo test -p djls-extraction structural`
- [ ] `test_singleton_closer_pattern` passes (`if`→`endif` via singleton, not convention)
- [ ] `test_generic_tag_with_non_conventional_closer` passes (proves control-flow inference, not naming)
- [ ] `test_non_end_prefix_closer` passes (verifies no `end*` string heuristics)
- [ ] `test_ambiguous_returns_none` passes (verifies `end_tag: None` when uncertain)
- [ ] `test_django_convention_fallback` passes (tie-breaker for ALL block tags when `end{tag}` in stop-tags)
- [ ] `test_django_convention_not_invented` passes (verifies we don't invent missing end tags)
- [ ] `test_django_convention_blocked_by_singleton_ambiguity` passes (verifies ambiguity blocks fallback)
- [ ] `test_simple_block_tag_without_end_name_uses_django_default` passes (decorator-defined semantic)

---
