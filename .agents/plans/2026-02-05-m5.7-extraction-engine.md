# M5: Extraction Engine - Phase 7

> **Parent document**: [M5: Extraction Engine Overview](2026-02-05-m5-extraction-engine.md)

---

## Phase 7: Salsa Integration

### Overview

Wire extraction into the Salsa query system with proper invalidation semantics. This phase integrates `djls-extraction` into the existing Salsa dependency graph while maintaining the "2 inputs only" constraint (`File` + `Project`).

**Key architectural decisions:**

1. **Workspace modules** → Tracked queries over `File` inputs (automatic invalidation)
2. **External modules (site-packages)** → Cached on `Project` field (manual refresh)
3. **Module path resolution** → Uses `sys_path` from `python_env` inspector query

### Crates/Files Modified

| Crate          | File                   | Changes                                                    |
| -------------- | ---------------------- | ---------------------------------------------------------- |
| `djls-project` | `Cargo.toml`           | Add `djls-extraction` dependency                           |
| `djls-project` | `src/lib.rs`           | Export new types                                           |
| `djls-project` | `src/project.rs`       | Add `sys_path`, `extracted_external_rules` fields          |
| `djls-project` | `src/django.rs`        | Add provenance module path to `InspectorInventory`         |
| `djls-project` | `src/resolve.rs` (new) | Module path → file path resolution                         |
| `djls-server`  | `src/db.rs`            | Add tracked extraction queries, update `compute_tag_specs` |

### Module Path → File Path Resolution

Registration modules (e.g., `django.templatetags.i18n`) must be resolved to file paths for extraction. This uses `sys_path` from the Python environment.

**Location**: New module `crates/djls-project/src/resolve.rs`

**Data source**: `sys_path` comes from the `python_env` inspector query, stored on `Project`.

**Algorithm**:

1. Split module path on `.` → `["django", "templatetags", "i18n"]`
2. For each entry in `sys_path`:
    - Build candidate path: `{sys_path_entry}/django/templatetags/i18n.py`
    - Also check `{sys_path_entry}/django/templatetags/i18n/__init__.py`
    - Return first match
3. Return `None` if no candidate exists

**Workspace vs External classification**:

- If resolved path starts with project root → workspace module
- Otherwise → external module (site-packages, stdlib, etc.)

### Testability and Determinism Requirements

#### Module Resolution Must Be Deterministic

The `resolve_module()` function must produce identical results given identical inputs:

```rust
// Given the same (module_path, sys_path, project_root), always returns the same result
let r1 = resolve_module("myapp.templatetags.custom", &sys_path, &root);
let r2 = resolve_module("myapp.templatetags.custom", &sys_path, &root);
assert_eq!(r1, r2);
```

**Ordering guarantee**: `sys_path` is searched in order; first match wins. This matches Python's import semantics.

**File system dependency**: Resolution calls `path.exists()`. For testing:

- Unit tests use predictable directory structures (in-memory or temp dirs)
- Integration tests use real corpus paths

#### Resolution Unit Tests

**File**: `crates/djls-project/src/resolve.rs` (append to module)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn setup_test_layout() -> (TempDir, Utf8PathBuf) {
        let tmp = TempDir::new().unwrap();
        let root = Utf8PathBuf::try_from(tmp.path().to_path_buf()).unwrap();

        // Create workspace module
        let workspace_tags = root.join("myproject/templatetags");
        std::fs::create_dir_all(&workspace_tags).unwrap();
        std::fs::write(workspace_tags.join("custom.py"), "# workspace").unwrap();

        // Create external module (simulated site-packages)
        let site_packages = root.join("venv/lib/python3.11/site-packages");
        let django_tags = site_packages.join("django/templatetags");
        std::fs::create_dir_all(&django_tags).unwrap();
        std::fs::write(django_tags.join("i18n.py"), "# django").unwrap();

        (tmp, root)
    }

    #[test]
    fn test_resolve_workspace_module() {
        let (_tmp, root) = setup_test_layout();
        let sys_path = vec![root.clone()];

        let result = resolve_module("myproject.templatetags.custom", &sys_path, &root);

        assert!(result.is_some());
        let resolved = result.unwrap();
        assert_eq!(resolved.location, ModuleLocation::Workspace);
        assert!(resolved.file_path.ends_with("custom.py"));
    }

    #[test]
    fn test_resolve_external_module() {
        let (_tmp, root) = setup_test_layout();
        let site_packages = root.join("venv/lib/python3.11/site-packages");
        let sys_path = vec![site_packages];

        let result = resolve_module("django.templatetags.i18n", &sys_path, &root);

        assert!(result.is_some());
        let resolved = result.unwrap();
        assert_eq!(resolved.location, ModuleLocation::External);
        assert!(resolved.file_path.ends_with("i18n.py"));
    }

    #[test]
    fn test_resolve_not_found() {
        let (_tmp, root) = setup_test_layout();
        let sys_path = vec![root.clone()];

        let result = resolve_module("nonexistent.module", &sys_path, &root);
        assert!(result.is_none());
    }

    #[test]
    fn test_sys_path_order_matters() {
        let (_tmp, root) = setup_test_layout();

        // Create same module in two places
        let dir1 = root.join("first");
        let dir2 = root.join("second");
        std::fs::create_dir_all(dir1.join("pkg")).unwrap();
        std::fs::create_dir_all(dir2.join("pkg")).unwrap();
        std::fs::write(dir1.join("pkg/mod.py"), "# first").unwrap();
        std::fs::write(dir2.join("pkg/mod.py"), "# second").unwrap();

        // First in sys_path wins
        let sys_path = vec![dir1.clone(), dir2.clone()];
        let result = resolve_module("pkg.mod", &sys_path, &root).unwrap();
        assert!(result.file_path.starts_with(&dir1));

        // Reverse order → different result
        let sys_path = vec![dir2.clone(), dir1.clone()];
        let result = resolve_module("pkg.mod", &sys_path, &root).unwrap();
        assert!(result.file_path.starts_with(&dir2));
    }
}
```

### External Module Caching Semantics

#### When External Rules Are Refreshed

| Trigger                      | Action                           | Notes                                 |
| ---------------------------- | -------------------------------- | ------------------------------------- |
| `refresh_inspector()` called | Re-extract all external modules  | Called on venv change, manual refresh |
| Inventory changes            | Re-extract if new modules appear | Checked via manual comparison         |
| `pip install/upgrade`        | NOT automatic                    | User must trigger refresh             |
| Project reopen               | Loads from `Project` field       | Persisted in Salsa                    |

#### What Invalidates Cached External Rules

External rules are stored in `Project.extracted_external_rules`. This field:

- **IS invalidated** when: `refresh_inspector()` finds different extraction results (manual comparison)
- **IS NOT invalidated** when: external files change on disk without refresh call

This is intentional — external modules (site-packages) are treated as stable. The user must explicitly request refresh after `pip install`.

#### Version Change Behavior

When a library version changes (e.g., `pip install django==5.2.12`):

1. **Without refresh**: Old extracted rules remain cached (stale but safe)
2. **With refresh**:
    - `refresh_inspector()` queries new inventory
    - New sys_path may point to different locations
    - Re-extraction produces new rules
    - Manual comparison detects change → setter called → Salsa invalidates dependents

**Test for version change:**

```rust
#[test]
fn test_external_rules_version_change() {
    let mut test = TestDatabase::with_project();
    let project = test.db.project().unwrap();

    // Simulate v1 extracted rules
    let mut v1_rules = FxHashMap::default();
    v1_rules.insert("django.templatetags.i18n".to_string(), ExtractionResult::default());
    project.set_extracted_external_rules(&mut test.db).to(v1_rules);

    // First access
    let _specs1 = test.db.tag_specs();
    test.logger.clear();

    // Simulate version change: different extraction result
    let mut v2_rules = FxHashMap::default();
    let mut v2_result = ExtractionResult::default();
    v2_result.tags.push(ExtractedTag { name: "new_tag".to_string(), /* ... */ });
    v2_rules.insert("django.templatetags.i18n".to_string(), v2_result);

    // Manual comparison detects change
    assert!(project.extracted_external_rules(&test.db) != &v2_rules);
    project.set_extracted_external_rules(&mut test.db).to(v2_rules);

    // Dependent queries re-run
    let _specs2 = test.db.tag_specs();
    assert!(test.logger.was_executed(&test.db, "compute_tag_specs"));
}
```

### Changes Required:

#### 1. Add extraction dependency to djls-project

**File**: `crates/djls-project/Cargo.toml`

```toml
[dependencies]
djls-extraction = { path = "../djls-extraction" }
```

#### 2. Extend Project with sys_path and extracted_external_rules

**File**: `crates/djls-project/src/project.rs`

```rust
use djls_extraction::ExtractionResult;
use rustc_hash::FxHashMap;

#[salsa::input]
#[derive(Debug)]
pub struct Project {
    // ... existing fields ...

    /// Python sys.path from interpreter (for module resolution).
    /// Updated via `refresh_python_env()`.
    #[returns(ref)]
    pub sys_path: Vec<Utf8PathBuf>,

    /// Extracted rules from external modules (site-packages).
    /// Keyed by registration module path (e.g., "django.templatetags.i18n").
    /// Updated via `refresh_inspector()` — NOT automatically invalidated.
    #[returns(ref)]
    pub extracted_external_rules: FxHashMap<String, ExtractionResult>,
}
```

**Update `Project::new` call sites** to include the new fields:

- `sys_path: Vec::new()` initially, populated by `refresh_python_env()`
- `extracted_external_rules: FxHashMap::default()` initially, populated by `refresh_inspector()`

#### 3. Add module path resolution

**File**: `crates/djls-project/src/resolve.rs` (new)

```rust
//! Module path → file path resolution using sys_path.

use camino::Utf8Path;
use camino::Utf8PathBuf;

/// Classification of where a module lives.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModuleLocation {
    /// Module is in the project workspace (tracked as File)
    Workspace,
    /// Module is external (site-packages, stdlib, etc.)
    External,
}

/// Resolved module information.
#[derive(Debug, Clone)]
pub struct ResolvedModule {
    pub module_path: String,
    pub file_path: Utf8PathBuf,
    pub location: ModuleLocation,
}

/// Resolve a Python module path to a file path.
///
/// # Arguments
/// * `module_path` - Dotted module path (e.g., "django.templatetags.i18n")
/// * `sys_path` - Python sys.path entries to search
/// * `project_root` - Project root for workspace vs external classification
///
/// # Returns
/// `Some(ResolvedModule)` if found, `None` otherwise
pub fn resolve_module(
    module_path: &str,
    sys_path: &[Utf8PathBuf],
    project_root: &Utf8Path,
) -> Option<ResolvedModule> {
    let parts: Vec<&str> = module_path.split('.').collect();

    for sys_entry in sys_path {
        // Build candidate: {sys_entry}/a/b/c.py
        let mut candidate = sys_entry.clone();
        for part in &parts {
            candidate.push(part);
        }

        // Try as .py file
        let py_file = candidate.with_extension("py");
        if py_file.exists() {
            let location = classify_location(&py_file, project_root);
            return Some(ResolvedModule {
                module_path: module_path.to_string(),
                file_path: py_file,
                location,
            });
        }

        // Try as package/__init__.py
        let init_file = candidate.join("__init__.py");
        if init_file.exists() {
            let location = classify_location(&init_file, project_root);
            return Some(ResolvedModule {
                module_path: module_path.to_string(),
                file_path: init_file,
                location,
            });
        }
    }

    None
}

fn classify_location(path: &Utf8Path, project_root: &Utf8Path) -> ModuleLocation {
    if path.starts_with(project_root) {
        ModuleLocation::Workspace
    } else {
        ModuleLocation::External
    }
}

/// Resolve multiple module paths, partitioned by location.
pub fn resolve_modules(
    module_paths: impl IntoIterator<Item = impl AsRef<str>>,
    sys_path: &[Utf8PathBuf],
    project_root: &Utf8Path,
) -> (Vec<ResolvedModule>, Vec<ResolvedModule>) {
    let mut workspace = Vec::new();
    let mut external = Vec::new();

    for module_path in module_paths {
        if let Some(resolved) = resolve_module(module_path.as_ref(), sys_path, project_root) {
            match resolved.location {
                ModuleLocation::Workspace => workspace.push(resolved),
                ModuleLocation::External => external.push(resolved),
            }
        }
    }

    (workspace, external)
}
```

#### 4. Export from djls-project

**File**: `crates/djls-project/src/lib.rs`

```rust
mod resolve;

pub use resolve::resolve_module;
pub use resolve::resolve_modules;
pub use resolve::ModuleLocation;
pub use resolve::ResolvedModule;
```

#### 5. Add tracked extraction query for workspace modules

**File**: `crates/djls-server/src/db.rs`

```rust
use djls_extraction::extract_rules;
use djls_extraction::ExtractionResult;
use djls_project::resolve_modules;
use djls_project::ModuleLocation;
use djls_source::File;
use djls_source::FileKind;

/// Extract validation rules from a workspace Python module.
///
/// This is a TRACKED QUERY: changes to the File input (revision bump)
/// automatically invalidate cached results.
///
/// Only extracts from Python files. Returns empty result for other file types.
#[salsa::tracked]
pub fn extract_workspace_module_rules(db: &DjangoDatabase, file: File) -> ExtractionResult {
    // Check file type
    let source = file.source(db);
    if source.kind() != &FileKind::Python {
        return ExtractionResult::default();
    }

    // Extract rules using djls-extraction
    match extract_rules(source.as_str()) {
        Ok(result) => result,
        Err(e) => {
            tracing::warn!(
                "Extraction failed for {}: {}",
                file.path(db),
                e
            );
            ExtractionResult::default()
        }
    }
}

/// Collect extracted rules from all workspace registration modules.
///
/// This tracked query:
/// 1. Gets registration modules from inspector inventory
/// 2. Resolves workspace modules to File inputs
/// 3. Extracts rules from each (via tracked `extract_workspace_module_rules`)
///
/// External modules are handled separately (cached on Project).
#[salsa::tracked]
pub fn collect_workspace_extraction_results(
    db: &DjangoDatabase,
    project: Project,
) -> Vec<(String, ExtractionResult)> {
    let inventory = project.inspector_inventory(db);
    let sys_path = project.sys_path(db);
    let root = project.root(db);

    let Some(inventory) = inventory else {
        return Vec::new();
    };

    // Get unique registration module paths from inventory
    let module_paths: Vec<&str> = inventory
        .tags()
        .iter()
        .filter_map(|tag| tag.provenance_module())
        .collect();

    // Resolve and partition by location
    let (workspace_modules, _external) = resolve_modules(module_paths, sys_path, root);

    let mut results = Vec::new();

    for resolved in workspace_modules {
        // Get or create File for this workspace module
        let file = db.get_file(&resolved.file_path)
            .unwrap_or_else(|| db.create_file(&resolved.file_path));

        // Extract via tracked query (establishes Salsa dependency)
        let extraction = extract_workspace_module_rules(db, file);

        if !extraction.is_empty() {
            results.push((resolved.module_path, extraction));
        }
    }

    results
}
```

#### 6. Update refresh_inspector to extract external module rules

**File**: `crates/djls-server/src/db.rs`

```rust
impl DjangoDatabase {
    /// Refresh the inspector inventory AND extract rules from external modules.
    ///
    /// This method:
    /// 1. Queries the Python inspector for inventory
    /// 2. Queries for sys_path (python_env)
    /// 3. Resolves external registration modules
    /// 4. Extracts rules from external modules (reads file content via fs)
    /// 5. Updates Project fields with manual comparison
    ///
    /// Called when:
    /// - Project is first initialized
    /// - Python environment changes (venv, PYTHONPATH)
    /// - User explicitly requests refresh
    pub fn refresh_inspector(&mut self) {
        use djls_project::resolve_modules;

        let Some(project) = self.project() else {
            tracing::warn!("Cannot refresh inspector: no project set");
            return;
        };

        // 1. Refresh sys_path from python_env query
        let new_sys_path = self.query_sys_path();
        if project.sys_path(self) != &new_sys_path {
            project.set_sys_path(self).to(new_sys_path.clone());
        }

        // 2. Refresh inventory (existing logic)
        let new_inventory = self.query_inventory();
        let inventory_changed = project.inspector_inventory(self) != &new_inventory;
        if inventory_changed {
            project.set_inspector_inventory(self).to(new_inventory.clone());
        }

        // 3. Extract from external modules (only if inventory changed or first run)
        if inventory_changed || project.extracted_external_rules(self).is_empty() {
            let new_external_rules = self.extract_external_module_rules(
                &new_inventory,
                &new_sys_path,
                project.root(self),
            );

            if project.extracted_external_rules(self) != &new_external_rules {
                tracing::debug!(
                    "External extraction updated: {} modules",
                    new_external_rules.len()
                );
                project.set_extracted_external_rules(self).to(new_external_rules);
            }
        }
    }

    /// Query sys_path from Python environment.
    fn query_sys_path(&self) -> Vec<Utf8PathBuf> {
        use djls_project::inspector;
        use djls_project::PythonEnvRequest;

        match inspector::query(self, &PythonEnvRequest) {
            Ok(response) => response
                .sys_path
                .into_iter()
                .filter_map(|p| Utf8PathBuf::try_from(p).ok())
                .collect(),
            Err(e) => {
                tracing::warn!("Failed to query sys_path: {}", e);
                Vec::new()
            }
        }
    }

    /// Query inventory from inspector (existing logic extracted).
    fn query_inventory(&self) -> Option<InspectorInventory> {
        use djls_project::inspector;
        use djls_project::TemplatetagsRequest;

        inspector::query(self, &TemplatetagsRequest)
            .map(|response| InspectorInventory::from_response(
                response.libraries,
                response.builtins,
                response.templatetags,
            ))
            .ok()
    }

    /// Extract rules from external modules.
    ///
    /// Reads file content directly from filesystem (not via Salsa File inputs).
    /// These are external to the project and don't need automatic invalidation.
    fn extract_external_module_rules(
        &self,
        inventory: &Option<InspectorInventory>,
        sys_path: &[Utf8PathBuf],
        project_root: &Utf8Path,
    ) -> FxHashMap<String, ExtractionResult> {
        use djls_project::resolve_modules;

        let Some(inventory) = inventory else {
            return FxHashMap::default();
        };

        let module_paths: Vec<&str> = inventory
            .tags()
            .iter()
            .filter_map(|tag| tag.provenance_module())
            .collect();

        let (_workspace, external_modules) = resolve_modules(module_paths, sys_path, project_root);

        let mut results = FxHashMap::default();

        for resolved in external_modules {
            // Read file content directly (NOT via Salsa)
            let Ok(source) = self.fs.read_to_string(&resolved.file_path) else {
                continue;
            };

            match extract_rules(&source) {
                Ok(extraction) if !extraction.is_empty() => {
                    results.insert(resolved.module_path, extraction);
                }
                Ok(_) => {} // Empty extraction, skip
                Err(e) => {
                    tracing::debug!(
                        "Extraction failed for external module {}: {}",
                        resolved.module_path,
                        e
                    );
                }
            }
        }

        results
    }
}
```

#### 7. Update compute_tag_specs to merge extraction results

**File**: `crates/djls-server/src/db.rs`

```rust
/// Compute tag specifications from all sources.
///
/// This tracked query merges:
/// 1. Django builtin specs (compile-time constant)
/// 2. Extracted rules from workspace modules (tracked queries)
/// 3. Extracted rules from external modules (Project field)
/// 4. User config overrides (Project.tagspecs field)
///
/// Invalidation triggers:
/// - Workspace Python file changes → via extract_workspace_module_rules dependency
/// - External modules change → via Project.extracted_external_rules
/// - User config changes → via Project.tagspecs
#[salsa::tracked]
pub fn compute_tag_specs(db: &DjangoDatabase, project: Project) -> TagSpecs {
    // Start with Django builtins (compile-time constant)
    let mut specs = django_builtin_specs();

    // Merge workspace extraction results (tracked)
    let workspace_results = collect_workspace_extraction_results(db, project);
    for (module_path, extraction) in workspace_results {
        merge_extraction_into_specs(&mut specs, &module_path, &extraction);
    }

    // Merge external extraction results (from Project field)
    let external_results = project.extracted_external_rules(db);
    for (module_path, extraction) in external_results.iter() {
        merge_extraction_into_specs(&mut specs, module_path, extraction);
    }

    // Apply user config overrides (highest priority)
    let user_specs = TagSpecs::from_config_def(project.tagspecs(db));
    specs.merge(user_specs);

    tracing::trace!("Computed tag specs: {} tags total", specs.len());

    specs
}

/// Merge extraction results into tag specs.
fn merge_extraction_into_specs(
    specs: &mut TagSpecs,
    module_path: &str,
    extraction: &ExtractionResult,
) {
    for tag in &extraction.tags {
        // Look up existing spec or create new one
        if let Some(spec) = specs.get_mut(&tag.name) {
            // Enrich existing spec with extracted rules
            spec.merge_extracted_rules(&tag.rules);
            if let Some(ref block_spec) = tag.block_spec {
                spec.merge_block_spec(block_spec);
            }
        } else {
            // Create new spec from extraction
            let new_spec = TagSpec::from_extraction(module_path, tag);
            specs.insert(tag.name.clone(), new_spec);
        }
    }
}
```

### Invalidation Semantics

| Change                                | Invalidation Path                                                                                                                              | Notes                                       |
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| Workspace Python file edited          | `File.revision` bump → `extract_workspace_module_rules` re-runs → `collect_workspace_extraction_results` re-runs → `compute_tag_specs` re-runs | Automatic via Salsa                         |
| External module changed (pip upgrade) | Manual `refresh_inspector()` call → `Project.extracted_external_rules` updated                                                                 | Not automatic — requires user/event trigger |
| User tagspecs config changed          | `Project.tagspecs` updated → `compute_tag_specs` re-runs                                                                                       | Via M2 config flow                          |
| Inspector inventory changed           | `Project.inspector_inventory` updated → `collect_workspace_extraction_results` re-runs                                                         | Via `refresh_inspector()`                   |

### Success Criteria:

#### Automated Verification:

- [ ] Cargo build passes: `cargo build`
- [ ] Clippy passes: `cargo clippy --all-targets -- -D warnings`
- [ ] All existing tests pass: `cargo test`

#### Invalidation Tests:

**File**: `crates/djls-server/src/db.rs` (in `#[cfg(test)]` module)

```rust
#[cfg(test)]
mod extraction_invalidation_tests {
    use super::*;
    use super::test_infrastructure::*;

    /// Helper to create a workspace Python file with tag registration.
    fn create_workspace_tag_file(test: &mut TestDatabase, name: &str, source: &str) -> File {
        let path = Utf8PathBuf::from(format!("/test/project/templatetags/{}.py", name));

        // Write to in-memory filesystem
        test.db.fs.write(&path, source).unwrap();

        // Create File input
        test.db.create_file(&path)
    }

    #[test]
    fn test_workspace_python_change_triggers_reextraction() {
        let mut test = TestDatabase::with_project();

        // Create a workspace Python file with a tag
        let source_v1 = r#"
@register.tag
def my_tag(parser, token):
    bits = token.split_contents()
    if len(bits) != 2:
        raise TemplateSyntaxError("my_tag takes 1 argument")
    return Node()
"#;
        let file = create_workspace_tag_file(&mut test, "my_tags", source_v1);

        // First extraction
        let result1 = extract_workspace_module_rules(&test.db, file);
        assert!(!result1.tags.is_empty(), "Should extract tag");

        test.logger.clear();

        // Modify the file
        let source_v2 = r#"
@register.tag
def my_tag(parser, token):
    bits = token.split_contents()
    if len(bits) != 3:
        raise TemplateSyntaxError("my_tag takes 2 arguments")
    return Node()
"#;
        test.db.fs.write(file.path(&test.db), source_v2).unwrap();

        // Bump revision to trigger invalidation
        file.set_revision(&mut test.db).to(file.revision(&test.db) + 1);

        // Re-extract — should run again (not cached)
        let result2 = extract_workspace_module_rules(&test.db, file);

        assert!(
            test.logger.was_executed(&test.db, "extract_workspace_module_rules"),
            "Should re-extract after file change"
        );

        // Verify content changed
        assert_ne!(result1, result2, "Extraction results should differ");
    }

    #[test]
    fn test_workspace_extraction_cached_when_unchanged() {
        let test = TestDatabase::with_project();

        let source = r#"
@register.tag
def cached_tag(parser, token):
    return Node()
"#;
        let path = Utf8PathBuf::from("/test/project/templatetags/cached.py");
        test.db.fs.write(&path, source).unwrap();
        let file = test.db.create_file(&path);

        // First extraction
        let _result1 = extract_workspace_module_rules(&test.db, file);
        assert!(test.logger.was_executed(&test.db, "extract_workspace_module_rules"));

        test.logger.clear();

        // Second extraction — should use cache
        let _result2 = extract_workspace_module_rules(&test.db, file);
        assert!(
            !test.logger.was_executed(&test.db, "extract_workspace_module_rules"),
            "Should use cached result when file unchanged"
        );
    }

    #[test]
    fn test_external_rules_not_auto_invalidated() {
        let mut test = TestDatabase::with_project();

        // Simulate external rules being set
        let mut external_rules = FxHashMap::default();
        external_rules.insert(
            "django.templatetags.i18n".to_string(),
            ExtractionResult::default(),
        );

        let project = test.db.project().unwrap();
        project.set_extracted_external_rules(&mut test.db).to(external_rules);

        // Access tag_specs
        let _specs1 = test.db.tag_specs();
        test.logger.clear();

        // External module "changes" (but we don't bump anything)
        // This simulates pip upgrade without refresh_inspector call

        // Access tag_specs again — should use cache
        let _specs2 = test.db.tag_specs();
        assert!(
            !test.logger.was_executed(&test.db, "compute_tag_specs"),
            "External rules don't auto-invalidate — need explicit refresh"
        );
    }

    #[test]
    fn test_compute_tag_specs_depends_on_workspace_extraction() {
        let mut test = TestDatabase::with_project();

        // Set up inventory with a workspace module
        let project = test.db.project().unwrap();
        let inventory = InspectorInventory::from_response(
            HashMap::new(),
            vec![],
            vec![TemplateTag {
                name: "workspace_tag".to_string(),
                module: "myproject.templatetags.custom".to_string(),
                provenance: TagProvenance::Builtin {
                    module: "myproject.templatetags.custom".to_string(),
                },
            }],
        );
        project.set_inspector_inventory(&mut test.db).to(Some(inventory));

        // Create the workspace module file
        let source = r#"
@register.tag
def workspace_tag(parser, token):
    return Node()
"#;
        let path = Utf8PathBuf::from("/test/project/myproject/templatetags/custom.py");
        test.db.fs.write(&path, source).unwrap();
        test.db.create_file(&path);

        // First compute
        let _specs1 = compute_tag_specs(&test.db, project);
        test.logger.clear();

        // Modify workspace file and bump revision
        let file = test.db.get_file(&path).unwrap();
        let new_source = r#"
@register.tag
def workspace_tag(parser, token):
    bits = token.split_contents()
    if len(bits) < 2:
        raise TemplateSyntaxError("needs args")
    return Node()
"#;
        test.db.fs.write(&path, new_source).unwrap();
        file.set_revision(&mut test.db).to(file.revision(&test.db) + 1);

        // Recompute — should trigger
        let _specs2 = compute_tag_specs(&test.db, project);
        assert!(
            test.logger.was_executed(&test.db, "extract_workspace_module_rules"),
            "Workspace file change should trigger extraction"
        );
        assert!(
            test.logger.was_executed(&test.db, "compute_tag_specs"),
            "Workspace file change should trigger tag_specs recompute"
        );
    }
}
```

### Summary: Workspace vs External Handling

| Aspect                   | Workspace Modules                                    | External Modules                          |
| ------------------------ | ---------------------------------------------------- | ----------------------------------------- |
| **Location**             | Under project root                                   | site-packages, stdlib, etc.               |
| **Salsa representation** | `File` input                                         | Not tracked as inputs                     |
| **Extraction query**     | `extract_workspace_module_rules(db, file)` (tracked) | Direct fs read in `refresh_inspector()`   |
| **Storage**              | Query cache (automatic)                              | `Project.extracted_external_rules` field  |
| **Invalidation**         | Automatic on `File.revision` bump                    | Manual via `refresh_inspector()`          |
| **Use case**             | User's custom tags evolve during dev                 | Stable library tags (Django, third-party) |

---
