# M5: Extraction Engine - Phase 4

> **Parent document**: [M5: Extraction Engine Overview](2026-02-05-m5-extraction-engine.md)

---

## Phase 4: Implement Rule Extraction

### Overview

Extract validation rules from TemplateSyntaxError guards, using the dynamically detected split variable name.

### Changes Required:

#### 1. Implement rules.rs

**File**: `crates/djls-extraction/src/rules.rs`

```rust
use ruff_python_ast::CmpOp;
use ruff_python_ast::Expr;
use ruff_python_ast::Mod;
use ruff_python_ast::Stmt;

use crate::context::FunctionContext;
use crate::parser::ParsedModule;
use crate::patterns;
use crate::registry::RegistrationInfo;
use crate::types::ExtractedRule;
use crate::types::RuleCondition;
use crate::ExtractionError;

/// Extract validation rules from a tag function.
///
/// Uses the detected `split_var` name from FunctionContext to identify
/// relevant conditions (e.g., `len(bits)`, `args[1]`, etc.).
pub fn extract_tag_rules(
    parsed: &ParsedModule,
    registration: &RegistrationInfo,
    ctx: &FunctionContext,
) -> Result<Vec<ExtractedRule>, ExtractionError> {
    let Mod::Module(module) = parsed.ast() else {
        return Ok(Vec::new());
    };

    let func_def = module.body.iter().find_map(|stmt| {
        if let Stmt::FunctionDef(fd) = stmt {
            if fd.name.as_str() == registration.function_name {
                return Some(fd);
            }
        }
        None
    });

    let Some(func_def) = func_def else {
        return Ok(Vec::new());
    };

    // If we couldn't detect the split variable, we can't extract rules
    let Some(split_var) = ctx.split_var() else {
        return Ok(Vec::new());
    };

    let mut rules = Vec::new();
    extract_rules_from_stmts(&func_def.body, split_var, &mut rules);

    Ok(rules)
}

fn extract_rules_from_stmts(stmts: &[Stmt], split_var: &str, rules: &mut Vec<ExtractedRule>) {
    for stmt in stmts {
        match stmt {
            Stmt::If(if_stmt) => {
                if has_template_syntax_error_raise(&if_stmt.body)
                    || if_stmt.elif_else_clauses.iter().any(|c| has_template_syntax_error_raise(&c.body))
                {
                    if let Some(condition) = analyze_condition(&if_stmt.test, split_var) {
                        let message = extract_error_message(&if_stmt.body);
                        rules.push(ExtractedRule { condition, message });
                    }
                }

                extract_rules_from_stmts(&if_stmt.body, split_var, rules);
                for clause in &if_stmt.elif_else_clauses {
                    extract_rules_from_stmts(&clause.body, split_var, rules);
                }
            }

            Stmt::While(while_stmt) => {
                extract_rules_from_stmts(&while_stmt.body, split_var, rules);
            }

            Stmt::For(for_stmt) => {
                extract_rules_from_stmts(&for_stmt.body, split_var, rules);
            }

            Stmt::Try(try_stmt) => {
                extract_rules_from_stmts(&try_stmt.body, split_var, rules);
            }

            _ => {}
        }
    }
}

fn has_template_syntax_error_raise(stmts: &[Stmt]) -> bool {
    stmts.iter().any(|stmt| {
        if let Stmt::Raise(raise) = stmt {
            if let Some(exc) = &raise.exc {
                return is_template_syntax_error(exc);
            }
        }
        false
    })
}

fn is_template_syntax_error(expr: &Expr) -> bool {
    match expr {
        Expr::Call(call) => {
            match call.func.as_ref() {
                Expr::Name(name) => name.id.as_str() == "TemplateSyntaxError",
                Expr::Attribute(attr) => attr.attr.as_str() == "TemplateSyntaxError",
                _ => false,
            }
        }
        _ => false,
    }
}

fn extract_error_message(stmts: &[Stmt]) -> Option<String> {
    for stmt in stmts {
        if let Stmt::Raise(raise) = stmt {
            if let Some(Expr::Call(call)) = &raise.exc {
                if let Some(Expr::StringLiteral(s)) = call.arguments.args.first() {
                    return Some(s.value.to_string());
                }
            }
        }
    }
    None
}

/// Analyze a condition expression using the detected split variable name.
fn analyze_condition(expr: &Expr, split_var: &str) -> Option<RuleCondition> {
    match expr {
        Expr::Compare(cmp) => analyze_comparison(cmp, split_var),

        Expr::UnaryOp(unary) if matches!(unary.op, ruff_python_ast::UnaryOp::Not) => {
            analyze_condition(&unary.operand, split_var).map(negate_condition)
        }

        _ => Some(RuleCondition::Opaque {
            description: "complex condition".to_string(),
        }),
    }
}

fn analyze_comparison(cmp: &ruff_python_ast::ExprCompare, split_var: &str) -> Option<RuleCondition> {
    if cmp.ops.len() != 1 || cmp.comparators.len() != 1 {
        return Some(RuleCondition::Opaque {
            description: "compound comparison".to_string(),
        });
    }

    let op = &cmp.ops[0];
    let left = &cmp.left;
    let right = &cmp.comparators[0];

    // len(<split_var>) <op> N
    if patterns::is_len_call(left, split_var).is_some() {
        if let Some(n) = patterns::extract_int_literal(right) {
            return Some(match op {
                CmpOp::Eq => RuleCondition::ExactArgCount { count: n as usize, negated: false },
                CmpOp::NotEq => RuleCondition::ExactArgCount { count: n as usize, negated: true },
                CmpOp::Lt => RuleCondition::MaxArgCount { max: (n - 1) as usize },
                CmpOp::LtE => RuleCondition::MaxArgCount { max: n as usize },
                CmpOp::Gt => RuleCondition::MinArgCount { min: (n + 1) as usize },
                CmpOp::GtE => RuleCondition::MinArgCount { min: n as usize },
                _ => return None,
            });
        }
    }

    // N <op> len(<split_var>) (reversed)
    if patterns::is_len_call(right, split_var).is_some() {
        if let Some(n) = patterns::extract_int_literal(left) {
            return Some(match op {
                CmpOp::Eq => RuleCondition::ExactArgCount { count: n as usize, negated: false },
                CmpOp::NotEq => RuleCondition::ExactArgCount { count: n as usize, negated: true },
                CmpOp::Lt => RuleCondition::MinArgCount { min: (n + 1) as usize },
                CmpOp::LtE => RuleCondition::MinArgCount { min: n as usize },
                CmpOp::Gt => RuleCondition::MaxArgCount { max: (n - 1) as usize },
                CmpOp::GtE => RuleCondition::MaxArgCount { max: n as usize },
                _ => return None,
            });
        }
    }

    // <split_var>[N] == "keyword"
    if let Some((idx, subscript_name)) = patterns::extract_subscript_index(left) {
        if subscript_name == split_var {
            if let Some(s) = patterns::extract_string_literal(right) {
                return Some(match op {
                    CmpOp::Eq => RuleCondition::LiteralAt { index: idx, value: s, negated: false },
                    CmpOp::NotEq => RuleCondition::LiteralAt { index: idx, value: s, negated: true },
                    _ => return None,
                });
            }
        }
    }

    // "keyword" in <split_var>
    if matches!(op, CmpOp::In | CmpOp::NotIn) {
        if let Some(s) = patterns::extract_string_literal(left) {
            if patterns::is_name(right, split_var) {
                return Some(RuleCondition::ContainsLiteral {
                    value: s,
                    negated: matches!(op, CmpOp::NotIn),
                });
            }
        }
    }

    // <split_var>[N] in ("opt1", "opt2")
    if matches!(op, CmpOp::In | CmpOp::NotIn) {
        if let Some((idx, subscript_name)) = patterns::extract_subscript_index(left) {
            if subscript_name == split_var {
                if let Some(choices) = patterns::extract_string_tuple(right) {
                    return Some(RuleCondition::ChoiceAt {
                        index: idx,
                        choices,
                        negated: matches!(op, CmpOp::NotIn),
                    });
                }
            }
        }
    }

    Some(RuleCondition::Opaque {
        description: "unrecognized comparison".to_string(),
    })
}

fn negate_condition(cond: RuleCondition) -> RuleCondition {
    match cond {
        RuleCondition::ExactArgCount { count, negated } => {
            RuleCondition::ExactArgCount { count, negated: !negated }
        }
        RuleCondition::LiteralAt { index, value, negated } => {
            RuleCondition::LiteralAt { index, value, negated: !negated }
        }
        RuleCondition::ChoiceAt { index, choices, negated } => {
            RuleCondition::ChoiceAt { index, choices, negated: !negated }
        }
        RuleCondition::ContainsLiteral { value, negated } => {
            RuleCondition::ContainsLiteral { value, negated: !negated }
        }
        other => other,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::extract_rules;

    #[test]
    fn test_extract_with_bits() {
        let source = r#"
@register.tag
def my_tag(parser, token):
    bits = token.split_contents()
    if len(bits) != 3:
        raise TemplateSyntaxError("Need 2 args")
    return Node()
"#;
        let result = extract_rules(source).unwrap();
        assert!(matches!(
            &result.tags[0].rules[0].condition,
            RuleCondition::ExactArgCount { count: 3, negated: true }
        ));
    }

    #[test]
    fn test_extract_with_args() {
        // Using 'args' instead of 'bits'
        let source = r#"
@register.tag
def my_tag(parser, token):
    args = token.split_contents()
    if len(args) < 2:
        raise TemplateSyntaxError("Need at least 1 arg")
    return Node()
"#;
        let result = extract_rules(source).unwrap();
        assert!(matches!(
            &result.tags[0].rules[0].condition,
            RuleCondition::MaxArgCount { max: 1 }
        ));
    }

    #[test]
    fn test_extract_with_parts() {
        // Using 'parts' instead of 'bits'
        let source = r#"
@register.tag
def my_tag(p, t):
    parts = t.split_contents()
    if parts[1] != "as":
        raise TemplateSyntaxError("Expected 'as'")
    return Node()
"#;
        let result = extract_rules(source).unwrap();
        assert!(matches!(
            &result.tags[0].rules[0].condition,
            RuleCondition::LiteralAt { index: 1, value, negated: true } if value == "as"
        ));
    }
}
```

#### 2. Implement patterns.rs

**File**: `crates/djls-extraction/src/patterns.rs`

```rust
use ruff_python_ast::Expr;
use ruff_python_ast::Number;

pub fn is_len_call(expr: &Expr, target_name: &str) -> Option<()> {
    let Expr::Call(call) = expr else { return None };
    let Expr::Name(func_name) = call.func.as_ref() else { return None };
    if func_name.id.as_str() != "len" { return None; }

    let Some(Expr::Name(arg_name)) = call.arguments.args.first() else { return None };
    if arg_name.id.as_str() != target_name { return None; }

    Some(())
}

pub fn is_name(expr: &Expr, target: &str) -> bool {
    matches!(expr, Expr::Name(n) if n.id.as_str() == target)
}

pub fn extract_int_literal(expr: &Expr) -> Option<i64> {
    let Expr::NumberLiteral(num) = expr else { return None };
    match &num.value {
        Number::Int(i) => i.as_i64(),
        _ => None,
    }
}

pub fn extract_string_literal(expr: &Expr) -> Option<String> {
    match expr {
        Expr::StringLiteral(s) => Some(s.value.to_string()),
        _ => None,
    }
}

pub fn extract_subscript_index(expr: &Expr) -> Option<(usize, String)> {
    let Expr::Subscript(sub) = expr else { return None };
    let Expr::Name(name) = sub.value.as_ref() else { return None };

    let idx = extract_int_literal(&sub.slice)?;
    if idx < 0 { return None; }

    Some((idx as usize, name.id.to_string()))
}

pub fn extract_string_tuple(expr: &Expr) -> Option<Vec<String>> {
    let Expr::Tuple(tuple) = expr else { return None };

    let mut strings = Vec::new();
    for elt in &tuple.elts {
        strings.push(extract_string_literal(elt)?);
    }

    Some(strings)
}
```

### Success Criteria:

- [ ] Rule tests pass with various variable names: `cargo test -p djls-extraction rules`
- [ ] Tests verify `bits`, `args`, `parts` all work correctly

---
