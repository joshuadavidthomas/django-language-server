# M6: Rule Evaluation - Phase 2-5

> **Parent document**: [M6: Rule Evaluation Overview](2026-02-05-m6-rule-evaluation.md)

---

## Phase 2: Add New Error Types (S114-S116)

### Changes Required

#### 1. New Error Variants
**File**: `crates/djls-semantic/src/errors.rs`

```rust
#[derive(Clone, Debug, Error, PartialEq, Eq, Serialize)]
pub enum ValidationError {
    // ... existing S100-S113 ...

    #[error("{message}")]
    ExpressionSyntaxError {
        tag: String,
        message: String,
        span: Span,
    },

    #[error("Filter '{filter}' requires an argument")]
    FilterMissingArgument {
        filter: String,
        span: Span,
    },

    #[error("Filter '{filter}' does not accept an argument")]
    FilterUnexpectedArgument {
        filter: String,
        span: Span,
    },
}
```

#### 2. Diagnostic Code Mapping
**File**: `crates/djls-ide/src/diagnostics.rs`

```rust
impl DiagnosticError for ValidationError {
    fn diagnostic_code(&self) -> &'static str {
        match self {
            // ... existing S100-S113 ...
            ValidationError::ExpressionSyntaxError { .. } => "S114",
            ValidationError::FilterMissingArgument { .. } => "S115",
            ValidationError::FilterUnexpectedArgument { .. } => "S116",
        }
    }

    fn span(&self) -> Option<(u32, u32)> {
        match self {
            // ... existing ...
            ValidationError::ExpressionSyntaxError { span, .. }
            | ValidationError::FilterMissingArgument { span, .. }
            | ValidationError::FilterUnexpectedArgument { span, .. } => Some(span.into()),
        }
    }
}
```

### Success Criteria

- [ ] Compiles: `cargo build -p djls-semantic -p djls-ide`
- [ ] Existing tests pass

---

## Phase 3: Extend Db Trait for M6 Queries

### Overview

Add methods to `djls-semantic::Db` trait that `djls-server` implements. This follows the established pattern from M3/M4/M5.

### Changes Required

#### 1. Extend Db Trait
**File**: `crates/djls-semantic/src/db.rs`

```rust
use djls_extraction::FilterArity;
use djls_extraction::SymbolKey;
use djls_project::InspectorInventory;
use djls_project::Project;
use rustc_hash::FxHashMap;

use crate::templatetags::TagSpecs;

/// Filter arity specs keyed by SymbolKey for collision-safe lookup.
#[derive(Debug, Clone, Default)]
pub struct FilterAritySpecs {
    specs: FxHashMap<SymbolKey, FilterArity>,
}

impl FilterAritySpecs {
    pub fn new(specs: FxHashMap<SymbolKey, FilterArity>) -> Self {
        Self { specs }
    }

    pub fn get(&self, key: &SymbolKey) -> Option<&FilterArity> {
        self.specs.get(key)
    }

    pub fn is_empty(&self) -> bool {
        self.specs.is_empty()
    }
}

/// Opaque tag map: opener name → closer name.
pub type OpaqueTagMap = FxHashMap<String, String>;

#[salsa::db]
pub trait Db: TemplateDb {
    /// Get the Django tag specifications (enriched by M5 extraction).
    fn tag_specs(&self) -> TagSpecs;

    fn tag_index(&self) -> TagIndex<'_>;

    fn template_dirs(&self) -> Option<Vec<Utf8PathBuf>>;

    fn diagnostics_config(&self) -> DiagnosticsConfig;

    /// Get the combined inspector inventory (tags + filters).
    ///
    /// Per M2/M4 architecture, this reads from `Project.inspector_inventory`
    /// (a Salsa input field), NOT via a tracked query calling the inspector.
    /// The inventory is refreshed by `refresh_inspector()` (side-effect).
    ///
    /// Used by:
    /// - M3/M4 tag/filter scoping validation
    /// - M6 filter arity resolution (to find filter provenance)
    ///
    /// Returns `None` if inspector unavailable (Django init failed, etc.).
    fn inspector_inventory(&self) -> Option<&InspectorInventory>;

    /// Get filter arity specs keyed by SymbolKey (M6).
    ///
    /// Keyed by `SymbolKey { registration_module, name, kind=Filter }` for
    /// collision-safe lookup when multiple libraries define the same filter name.
    ///
    /// Returns empty `FilterAritySpecs` if extraction unavailable.
    fn filter_arity_specs(&self) -> FilterAritySpecs;

    /// Get opaque tag mappings: opener → closer (M6).
    ///
    /// Derived from `TagSpecs` where `spec.opaque == true`.
    /// Used to identify regions where validation should be skipped
    /// (e.g., inside `{% verbatim %}...{% endverbatim %}`).
    fn opaque_tag_map(&self) -> OpaqueTagMap;
}
```

#### 2. Implement in djls-server
**File**: `crates/djls-server/src/db.rs`

**IMPORTANT (single accessor invariant)**: All code paths that need inventory data — M3 tag scoping, M4 filter scoping, M6 arity resolution — MUST use `db.inspector_inventory()`. This ensures a single source of truth and proper Salsa dependency tracking. Do NOT reach into `project.inspector_inventory(self)` directly from validation code.

```rust
use djls_extraction::FilterArity;
use djls_extraction::SymbolKey;
use djls_extraction::SymbolKind;
use djls_semantic::FilterAritySpecs;
use djls_semantic::OpaqueTagMap;

impl djls_semantic::Db for DjangoDatabase {
    // ... existing implementations ...

    /// Per M4.1/M4.4 pattern: read from Project field (Salsa input).
    /// This is THE canonical accessor for inventory data — M3/M4/M6 all use this.
    fn inspector_inventory(&self) -> Option<&djls_project::InspectorInventory> {
        self.project()
            .and_then(|project| project.inspector_inventory(self).as_ref())
    }

    fn filter_arity_specs(&self) -> FilterAritySpecs {
        let Some(project) = self.project() else {
            return FilterAritySpecs::default();
        };
        compute_filter_arity_specs(self, project)
    }

    fn opaque_tag_map(&self) -> OpaqueTagMap {
        let Some(project) = self.project() else {
            return OpaqueTagMap::default();
        };
        compute_opaque_tag_map(self, project)
    }
}

/// Compute filter arity specs from extraction results.
/// Keyed by SymbolKey (registration_module + name) for collision safety.
#[salsa::tracked]
fn compute_filter_arity_specs(db: &DjangoDatabase, project: Project) -> FilterAritySpecs {
    let mut specs = FxHashMap::default();

    // Workspace extraction
    let workspace_results = collect_workspace_extraction_results(db, project);
    for (module_path, extraction) in workspace_results {
        for filter in &extraction.filters {
            let key = SymbolKey {
                registration_module: module_path.clone(),
                name: filter.name.clone(),
                kind: SymbolKind::Filter,
            };
            specs.entry(key).or_insert(filter.arity.clone());
        }
    }

    // External extraction
    let external_results = project.extracted_external_rules(db);
    for (module_path, extraction) in external_results.iter() {
        for filter in &extraction.filters {
            let key = SymbolKey {
                registration_module: module_path.clone(),
                name: filter.name.clone(),
                kind: SymbolKind::Filter,
            };
            specs.entry(key).or_insert(filter.arity.clone());
        }
    }

    FilterAritySpecs::new(specs)
}

/// Compute opaque tag map from TagSpecs.
/// Returns opener → closer mapping for tags where `opaque == true`.
#[salsa::tracked]
fn compute_opaque_tag_map(db: &DjangoDatabase, project: Project) -> OpaqueTagMap {
    let mut map = OpaqueTagMap::default();
    let tag_specs = compute_tag_specs(db, project);

    for (tag_name, spec) in tag_specs.iter() {
        if spec.opaque {
            if let Some(ref end_tag) = spec.end_tag {
                map.insert(tag_name.clone(), end_tag.name.to_string());
            }
        }
    }

    map
}
```

### Success Criteria

- [ ] Compiles: `cargo build -p djls-semantic -p djls-server`
- [ ] Existing tests pass

---

## Phase 4: Wire Validation into Pipeline

### Overview

Add expression validation and filter arity validation to `validate_nodelist`, with opaque region masking.

### Changes Required

#### 1. Opaque Region Detection
**File**: `crates/djls-semantic/src/opaque.rs`

```rust
//! Opaque region handling — skip validation inside {% verbatim %} etc.

use djls_source::Span;
use djls_templates::Node;
use djls_templates::NodeList;

use crate::db::OpaqueTagMap;
use crate::Db;

/// Spans that should skip validation (inside opaque blocks).
#[derive(Debug, Clone, Default)]
pub struct OpaqueRegions {
    regions: Vec<Span>,
}

impl OpaqueRegions {
    pub fn is_opaque(&self, span: Span) -> bool {
        self.regions.iter().any(|r| r.contains_span(span))
    }
}

/// Build opaque regions from nodelist using opaque tag map from Db.
pub fn compute_opaque_regions(db: &dyn Db, nodelist: NodeList<'_>) -> OpaqueRegions {
    let opaque_tags = db.opaque_tag_map();

    if opaque_tags.is_empty() {
        return OpaqueRegions::default();
    }

    let mut regions = Vec::new();
    let nodes = nodelist.nodelist(db);
    let mut i = 0;

    while i < nodes.len() {
        if let Node::Tag { name, span: open_span, .. } = &nodes[i] {
            if let Some(closer) = opaque_tags.get(name.as_str()) {
                let open_end = open_span.end();
                let mut j = i + 1;

                while j < nodes.len() {
                    if let Node::Tag { name: close_name, span: close_span, .. } = &nodes[j] {
                        if close_name == closer {
                            let region_start = open_end;
                            let region_end = close_span.start();
                            if region_end > region_start {
                                regions.push(Span::new(region_start, region_end - region_start));
                            }
                            i = j;
                            break;
                        }
                    }
                    j += 1;
                }
            }
        }
        i += 1;
    }

    OpaqueRegions { regions }
}
```

#### 2. Filter Arity Validation
**File**: `crates/djls-semantic/src/filter_arity.rs`

```rust
//! Filter arity validation using M4 scoping + M5 extraction.

use djls_extraction::FilterArity;
use djls_extraction::SymbolKey;
use djls_extraction::SymbolKind;
use djls_project::FilterProvenance;
use djls_templates::Filter;
use djls_templates::Node;
use djls_templates::NodeList;
use salsa::Accumulator;

use crate::db::FilterAritySpecs;
use crate::errors::ValidationError;
use crate::errors::ValidationErrorAccumulator;
use crate::load_resolution::compute_loaded_libraries;
use crate::load_resolution::LoadedLibraries;
use crate::load_resolution::LoadState;
use crate::opaque::OpaqueRegions;
use crate::Db;

/// Build LoadState for symbols available at a given position.
///
/// Uses the same state-machine approach as M3/M4: processes load statements
/// in document order, respecting selective imports (`{% load X from Y %}`).
fn build_load_state_at(loaded: &LoadedLibraries, position: u32) -> LoadState {
    let mut state = LoadState::default();
    for stmt in loaded.loads() {
        if stmt.span.end() <= position {
            state.process(stmt);
        }
    }
    state
}

/// Resolve which filter implementation is in scope.
/// Returns SymbolKey if unambiguous, None otherwise.
///
/// Uses M3/M4's LoadState to determine filter availability with proper
/// selective import handling (`{% load X from Y %}`).
///
/// **Ambiguity policy:**
/// - If ≥2 library candidates are in-scope at position → return `None`.
///   M4's S113 (AmbiguousUnloadedFilter) handles diagnostics; M6 emits no arity errors.
/// - If builtin + exactly 1 library candidate are in-scope → **library wins**.
///   Once a library is loaded, its filter shadows the builtin.
/// - Builtins are fallback only when NO loaded library candidate exists.
///   Among multiple builtins, later-in-`builtins()` wins (Django semantics).
fn resolve_filter_symbol(
    filter_name: &str,
    position: u32,
    loaded: &LoadedLibraries,
    db: &dyn Db,
) -> Option<SymbolKey> {
    let Some(inventory) = db.inspector_inventory() else {
        return None;
    };

    // Build load state at this position (same as M3/M4)
    let state = build_load_state_at(loaded, position);

    let mut candidates: Vec<String> = Vec::new();
    let mut builtin_candidates: Vec<String> = Vec::new();

    for filter in inventory.filters() {
        if filter.name() != filter_name {
            continue;
        }

        match filter.provenance() {
            FilterProvenance::Builtin { module } => {
                builtin_candidates.push(module.clone());
            }
            FilterProvenance::Library { load_name, module } => {
                // Use M3/M4's state-machine API which respects selective imports.
                // is_tag_available works for both tags and filters since they
                // follow the same scoping rules.
                if state.is_tag_available(filter_name, load_name) {
                    candidates.push(module.clone());
                }
            }
        }
    }

    if candidates.is_empty() {
        // Builtins are ordered (later wins per Django semantics). If multiple
        // builtin modules define the same filter, pick the one from the LAST
        // module in `inventory.builtins()`.
        let builtin_module = builtin_candidates
            .into_iter()
            .max_by_key(|m| inventory.builtins().iter().position(|b| b == m).unwrap_or(0));

        builtin_module.map(|m| SymbolKey {
            registration_module: m,
            name: filter_name.to_string(),
            kind: SymbolKind::Filter,
        })
    } else if candidates.len() == 1 {
        Some(SymbolKey {
            registration_module: candidates.remove(0),
            name: filter_name.to_string(),
            kind: SymbolKind::Filter,
        })
    } else {
        None // Ambiguous - multiple loaded libraries define this filter
    }
}

/// Validate filter arity for all filters in nodelist.
pub fn validate_filter_arity(
    db: &dyn Db,
    nodelist: NodeList<'_>,
    opaque: &OpaqueRegions,
) {
    let arity_specs = db.filter_arity_specs();
    if arity_specs.is_empty() {
        return;
    }

    let loaded = compute_loaded_libraries(db, nodelist);

    for node in nodelist.nodelist(db) {
        if let Node::Variable { filters, span, .. } = node {
            if opaque.is_opaque(*span) {
                continue;
            }

            for filter in filters {
                if opaque.is_opaque(filter.span) {
                    continue;
                }

                let Some(symbol_key) = resolve_filter_symbol(
                    &filter.name,
                    filter.span.start(),
                    &loaded,
                    db,
                ) else {
                    continue; // Unknown or ambiguous
                };

                let Some(arity) = arity_specs.get(&symbol_key) else {
                    continue; // No arity extracted
                };

                match arity {
                    FilterArity::None => {
                        if filter.arg.is_some() {
                            ValidationErrorAccumulator(ValidationError::FilterUnexpectedArgument {
                                filter: filter.name.clone(),
                                span: filter.span,
                            }).accumulate(db);
                        }
                    }
                    FilterArity::Required => {
                        if filter.arg.is_none() {
                            ValidationErrorAccumulator(ValidationError::FilterMissingArgument {
                                filter: filter.name.clone(),
                                span: filter.span,
                            }).accumulate(db);
                        }
                    }
                    FilterArity::Optional | FilterArity::Unknown => {}
                }
            }
        }
    }
}
```

#### 3. Update validate_nodelist
**File**: `crates/djls-semantic/src/lib.rs`

```rust
mod filter_arity;
mod if_expression;
mod opaque;

pub use filter_arity::validate_filter_arity;
pub use if_expression::validate_if_expression;
pub use opaque::compute_opaque_regions;
pub use opaque::OpaqueRegions;

use djls_templates::tokens::TagDelimiter;
use salsa::Accumulator;

#[salsa::tracked]
pub fn validate_nodelist(db: &dyn Db, nodelist: djls_templates::NodeList<'_>) {
    if nodelist.nodelist(db).is_empty() {
        return;
    }

    // HARD INVARIANT: Compute opaque regions FIRST, before ANY validation pass.
    // All subsequent passes that emit diagnostics MUST receive `opaque` and skip
    // spans inside opaque regions. Failure to do this causes false positives
    // inside {% verbatim %} and similar opaque blocks.
    let opaque = compute_opaque_regions(db, nodelist);

    let block_tree = build_block_tree(db, nodelist);
    let _forest = build_semantic_forest(db, block_tree, nodelist);

    // Existing validation (with opaque filtering)
    validate_all_tag_arguments_filtered(db, nodelist, &opaque);
    load_resolution::validate_tag_scoping_filtered(db, nodelist, &opaque);
    load_resolution::validate_filter_scoping_filtered(db, nodelist, &opaque);

    // M6: Expression validation
    validate_if_expressions(db, nodelist, &opaque);

    // M6: Filter arity validation
    validate_filter_arity(db, nodelist, &opaque);
}

fn validate_if_expressions(
    db: &dyn Db,
    nodelist: djls_templates::NodeList<'_>,
    opaque: &OpaqueRegions,
) {
    use djls_templates::Node;

    for node in nodelist.nodelist(db) {
        if let Node::Tag { name, bits, span } = node {
            if opaque.is_opaque(*span) {
                continue;
            }

            if name == "if" || name == "elif" {
                if let Some(message) = validate_if_expression(bits) {
                    let marker_span = span.expand(
                        TagDelimiter::LENGTH_U32,
                        TagDelimiter::LENGTH_U32,
                    );
                    ValidationErrorAccumulator(ValidationError::ExpressionSyntaxError {
                        tag: name.to_string(),
                        message,
                        span: marker_span,
                    }).accumulate(db);
                }
            }
        }
    }
}
```

### Success Criteria

- [ ] S114 for `{% if and x %}`
- [ ] S115 for missing required filter argument
- [ ] S116 for unexpected filter argument
- [ ] No errors inside `{% verbatim %}` blocks

---

## Phase 5: Testing

### Corpus Testing

- Environment variable: `DJLS_CORPUS_ROOT`
- Default location: `crates/djls-corpus/.corpus`

**File**: `crates/djls-semantic/tests/corpus_m6.rs`

```rust
use std::path::PathBuf;

fn corpus_root() -> Option<PathBuf> {
    if let Ok(root) = std::env::var("DJLS_CORPUS_ROOT") {
        let path = PathBuf::from(root);
        if path.exists() {
            return Some(path);
        }
    }

    let default = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../djls-corpus/.corpus");
    if default.exists() {
        Some(default)
    } else {
        None
    }
}

#[test]
fn test_no_false_positive_expression_errors() {
    let Some(root) = corpus_root() else {
        eprintln!("Corpus not available, skipping");
        return;
    };

    // Parse Django admin templates, assert no S114 errors
}
```

### Snapshot Tests

```rust
#[test]
fn test_expression_error_snapshots() {
    let templates = [
        ("if_and_at_start", "{% if and x %}{% endif %}"),
        ("if_missing_rhs", "{% if x == %}{% endif %}"),
        ("elif_or_at_start", "{% if x %}{% elif or y %}{% endif %}"),
    ];

    for (name, content) in templates {
        let errors = validate_template(content);
        insta::assert_yaml_snapshot!(name, errors);
    }
}
```

### Concrete Test Fixtures (Filter Arity)

These require a test harness with mocked `InspectorInventory` and `FilterAritySpecs`:

```rust
#[test]
fn test_filter_missing_required_argument() {
    // Setup: inventory has `truncatewords` with FilterArity::Required
    let template = "{{ title|truncatewords }}";
    let errors = validate_with_mocked_inventory(template);
    assert_eq!(errors, vec![
        ("S115", "Filter 'truncatewords' requires an argument"),
    ]);
}

#[test]
fn test_filter_unexpected_argument() {
    // Setup: inventory has `title` with FilterArity::None
    let template = r#"{{ name|title:"unused" }}"#;
    let errors = validate_with_mocked_inventory(template);
    assert_eq!(errors, vec![
        ("S116", "Filter 'title' does not accept an argument"),
    ]);
}

#[test]
fn test_filter_optional_argument_both_valid() {
    // Setup: inventory has `default` with FilterArity::Optional
    let template1 = "{{ value|default }}";
    let template2 = r#"{{ value|default:"N/A" }}"#;
    assert!(validate_with_mocked_inventory(template1).is_empty());
    assert!(validate_with_mocked_inventory(template2).is_empty());
}

#[test]
fn test_selective_import_arity_lookup() {
    // Setup: `localize` filter from `l10n` library with FilterArity::None
    // The filter IS loaded (via selective import), so M4 won't flag S112.
    // M6 should resolve it to l10n's registration_module and check arity.
    let template = r#"
        {% load localize from l10n %}
        {{ price|localize:"unexpected" }}
    "#;
    let errors = validate_with_mocked_inventory(template);
    // Filter is loaded and available — this is purely an arity error (S116)
    assert_eq!(errors, vec![
        ("S116", "Filter 'localize' does not accept an argument"),
    ]);
}

#[test]
fn test_ambiguous_library_filters_no_arity_error() {
    // Setup: `myfilter` defined in both `libA` and `libB`, both loaded
    // M4's S113 handles ambiguity; M6 should emit NO arity errors
    let template = r#"
        {% load libA %}
        {% load libB %}
        {{ value|myfilter }}
    "#;
    let errors = validate_with_mocked_inventory(template);
    // Should have S113 from M4, but NO S115/S116 from M6
    assert!(errors.iter().all(|(code, _)| *code != "S115" && *code != "S116"));
}

#[test]
fn test_builtin_collision_tiebreak() {
    // Setup: `escape` defined in two builtin modules (contrived for testing)
    // inventory.builtins() = ["mod_a", "mod_b"] → mod_b wins (later)
    // mod_a has FilterArity::None, mod_b has FilterArity::Required
    let template = "{{ html|escape }}";
    let errors = validate_with_mocked_inventory(template);
    // Should use mod_b's arity (Required), so missing arg → S115
    assert_eq!(errors, vec![
        ("S115", "Filter 'escape' requires an argument"),
    ]);
}

#[test]
fn test_library_shadows_builtin() {
    // Setup: `upper` is builtin with FilterArity::None
    //        `upper` also in `custom_lib` with FilterArity::Required
    // After {% load custom_lib %}, library version should shadow builtin
    let template = r#"
        {% load custom_lib %}
        {{ name|upper }}
    "#;
    let errors = validate_with_mocked_inventory(template);
    // Library's arity (Required) should apply, not builtin's (None)
    assert_eq!(errors, vec![
        ("S115", "Filter 'upper' requires an argument"),
    ]);
}
```

### Unit Tests (Always Run)

| Category | Location | Coverage |
|----------|----------|----------|
| Expression parser | `if_expression.rs` | Operators, valid/invalid |
| Error types | `errors.rs` | S114-S116 |
| Opaque regions | `opaque.rs` | Span containment |

### Integration Tests (Always Run)

| Category | Coverage |
|----------|----------|
| Expression validation | S114 for invalid if/elif |
| Filter arity | S115/S116 with extraction |
| Opaque skipping | No errors inside verbatim |
| Regression | No changes to S100-S113 |

### Corpus Tests (Auto-Gated)

| Category | Gating | Coverage |
|----------|--------|----------|
| Django admin | `DJLS_CORPUS_ROOT` | No false positives |

### Success Criteria

- [ ] Django admin templates produce no S114 errors
- [ ] Snapshot tests match expected diagnostics
- [ ] All existing tests pass: `cargo test`
