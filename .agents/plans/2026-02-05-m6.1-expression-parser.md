# M6: Rule Evaluation - Phase 1

> **Parent document**: [M6: Rule Evaluation Overview](2026-02-05-m6-rule-evaluation.md)

---

## Phase 1: Expression Validation Module (Tests First)

### Overview

Port Django's `smartif.py` Pratt parser to Rust for validating `{% if %}`/`{% elif %}` expression syntax.

This is a **self-contained module** with no dependencies on M5 extraction or filter arity. It validates the syntactic structure of boolean expressions in `{% if %}` and `{% elif %}` tags.

### Error Code

| Code | Error Type | Example |
|------|------------|---------|
| S114 | ExpressionSyntaxError | `{% if and x %}` |

### Changes Required

#### 1. New Module: Expression Parser
**File**: `crates/djls-semantic/src/if_expression.rs`

```rust
//! Static syntax validation for `{% if %}` / `{% elif %}` expressions.
//!
//! Mirrors Django's `smartif.py` parser to catch compile-time expression
//! syntax errors (operator/operand placement, dangling operators, unused
//! trailing tokens).

/// Token in an if expression
#[derive(Debug, Clone)]
enum IfToken {
    Literal(String),
    Operator(Operator),
    End,
}

#[derive(Debug, Clone, Copy)]
struct Operator {
    id: &'static str,
    lbp: u8,
    is_prefix: bool,
}

impl Operator {
    const fn infix(id: &'static str, lbp: u8) -> Self {
        Self { id, lbp, is_prefix: false }
    }
    
    const fn prefix(id: &'static str, lbp: u8) -> Self {
        Self { id, lbp, is_prefix: true }
    }
}

/// Operator precedence table (matches Django's smartif.py)
const OPERATORS: &[(&str, Operator)] = &[
    ("or", Operator::infix("or", 6)),
    ("and", Operator::infix("and", 7)),
    ("not", Operator::prefix("not", 8)),
    ("in", Operator::infix("in", 9)),
    ("not in", Operator::infix("not in", 9)),
    ("is", Operator::infix("is", 10)),
    ("is not", Operator::infix("is not", 10)),
    ("==", Operator::infix("==", 10)),
    ("!=", Operator::infix("!=", 10)),
    (">", Operator::infix(">", 10)),
    (">=", Operator::infix(">=", 10)),
    ("<", Operator::infix("<", 10)),
    ("<=", Operator::infix("<=", 10)),
];

fn lookup_operator(token: &str) -> Option<Operator> {
    OPERATORS.iter().find(|(k, _)| *k == token).map(|(_, op)| *op)
}

struct IfExpressionParser {
    tokens: Vec<IfToken>,
    pos: usize,
    current: IfToken,
}

impl IfExpressionParser {
    fn new(bits: &[String]) -> Self {
        let mut mapped = Vec::new();
        let mut i = 0;
        
        while i < bits.len() {
            let token = &bits[i];
            
            // Handle two-word operators
            let (combined, advance) = if token == "is" && bits.get(i + 1).map_or(false, |t| t == "not") {
                ("is not", 1)
            } else if token == "not" && bits.get(i + 1).map_or(false, |t| t == "in") {
                ("not in", 1)
            } else {
                (token.as_str(), 0)
            };
            
            i += advance;
            
            let if_token = if let Some(op) = lookup_operator(combined) {
                IfToken::Operator(op)
            } else {
                IfToken::Literal(bits[i].clone())
            };
            
            mapped.push(if_token);
            i += 1;
        }
        
        let current = mapped.first().cloned().unwrap_or(IfToken::End);
        Self { tokens: mapped, pos: 0, current }
    }
    
    fn advance(&mut self) {
        self.pos += 1;
        self.current = self.tokens.get(self.pos).cloned().unwrap_or(IfToken::End);
    }
    
    fn parse(&mut self) -> Result<(), String> {
        self.expression(0)?;
        
        if !matches!(self.current, IfToken::End) {
            let display = match &self.current {
                IfToken::Literal(s) => s.clone(),
                IfToken::Operator(op) => op.id.to_string(),
                IfToken::End => unreachable!(),
            };
            return Err(format!("Unused '{}' at end of if expression.", display));
        }
        Ok(())
    }
    
    fn expression(&mut self, rbp: u8) -> Result<(), String> {
        let t = std::mem::replace(&mut self.current, IfToken::End);
        self.advance();
        
        match &t {
            IfToken::Literal(_) => {}
            IfToken::Operator(op) if op.is_prefix => {
                self.expression(op.lbp)?;
            }
            IfToken::Operator(op) => {
                return Err(format!("Not expecting '{}' in this position in if tag.", op.id));
            }
            IfToken::End => {
                return Err("Unexpected end of expression in if tag.".to_string());
            }
        }
        
        loop {
            let lbp = match &self.current {
                IfToken::Operator(op) => op.lbp,
                _ => 0,
            };
            
            if rbp >= lbp {
                break;
            }
            
            let t = std::mem::replace(&mut self.current, IfToken::End);
            self.advance();
            
            if let IfToken::Operator(op) = t {
                if op.is_prefix {
                    return Err(format!("Not expecting '{}' as infix operator in if tag.", op.id));
                }
                self.expression(op.lbp)?;
            }
        }
        Ok(())
    }
}

/// Validate expression tokens for `{% if %}` / `{% elif %}`.
/// Returns an error message matching Django's style, or None if valid.
pub fn validate_if_expression(bits: &[String]) -> Option<String> {
    if bits.is_empty() {
        return Some("Unexpected end of expression in if tag.".to_string());
    }
    let mut parser = IfExpressionParser::new(bits);
    parser.parse().err()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    fn bits(s: &[&str]) -> Vec<String> {
        s.iter().map(|s| s.to_string()).collect()
    }
    
    #[test]
    fn test_valid_expressions() {
        assert!(validate_if_expression(&bits(&["x"])).is_none());
        assert!(validate_if_expression(&bits(&["not", "x"])).is_none());
        assert!(validate_if_expression(&bits(&["x", "and", "y"])).is_none());
        assert!(validate_if_expression(&bits(&["x", "or", "y"])).is_none());
        assert!(validate_if_expression(&bits(&["x", "==", "y"])).is_none());
        assert!(validate_if_expression(&bits(&["x", "and", "not", "y"])).is_none());
        assert!(validate_if_expression(&bits(&["x", "not", "in", "y"])).is_none());
        assert!(validate_if_expression(&bits(&["x", "is", "not", "y"])).is_none());
    }
    
    #[test]
    fn test_invalid_operator_at_start() {
        assert_eq!(
            validate_if_expression(&bits(&["and", "x"])),
            Some("Not expecting 'and' in this position in if tag.".to_string())
        );
    }
    
    #[test]
    fn test_invalid_missing_rhs() {
        assert_eq!(
            validate_if_expression(&bits(&["x", "=="])),
            Some("Unexpected end of expression in if tag.".to_string())
        );
    }
    
    #[test]
    fn test_invalid_trailing_token() {
        assert_eq!(
            validate_if_expression(&bits(&["x", "y"])),
            Some("Unused 'y' at end of if expression.".to_string())
        );
    }
    
    #[test]
    fn test_empty() {
        assert_eq!(
            validate_if_expression(&[]),
            Some("Unexpected end of expression in if tag.".to_string())
        );
    }
}
```

#### 2. Register Module
**File**: `crates/djls-semantic/src/lib.rs`

```rust
mod if_expression;
pub use if_expression::validate_if_expression;
```

### Success Criteria

- [ ] All unit tests pass: `cargo test -p djls-semantic if_expression`
- [ ] Clippy passes: `cargo clippy -p djls-semantic`

### Integration Note

Phase 2 (in [m6.2-filter-arity-validation.md](2026-02-05-m6.2-filter-arity-validation.md)) adds the S114 error variant and wires `validate_if_expression` into the `validate_nodelist` pipeline.
