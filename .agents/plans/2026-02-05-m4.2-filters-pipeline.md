# M4: Filters Pipeline - Phase 2

> **Parent document**: [M4: Filters Pipeline Overview](2026-02-05-m4-filters-pipeline.md)

---

## Phase 2: Structured Filter Representation (BREAKPOINT)

### Overview

**This is the core breakpoint identified in the charter.** Transform `filters: Vec<String>` → `Vec<Filter>` with structured data:

```rust
// BEFORE
filters: Vec<String>  // ["default:'nothing'", "title"]

// AFTER
filters: Vec<Filter>  // [Filter { name: "default", arg: Some(FilterArg { value: "'nothing'", span }), span }, Filter { name: "title", arg: None, span }]
```

### Files Touched (Complete List)

| File                                  | Change Required                                    |
| ------------------------------------- | -------------------------------------------------- |
| `djls-templates/src/nodelist.rs`      | `Node::Variable { filters: Vec<Filter> }`          |
| `djls-templates/src/parser.rs`        | Parse filters into structured `Filter`             |
| `djls-templates/src/lib.rs`           | Export `Filter`, `FilterArg` types                 |
| `djls-semantic/src/blocks/tree.rs`    | `NodeView::Variable { filters: Vec<Filter> }`      |
| `djls-semantic/src/blocks/builder.rs` | Pattern match update                               |
| `djls-ide/src/context.rs`             | `OffsetContext::Variable { filters: Vec<Filter> }` |
| Tests/snapshots                       | Update all filter-related snapshots                |

### Changes Required:

#### 1. Add Filter Struct

**File**: `crates/djls-templates/src/nodelist.rs` **Changes**: Add new types before Node enum

```rust
use djls_source::Span;

use crate::parser::ParseError;
use crate::tokens::TagDelimiter;

/// A parsed filter in a variable expression.
///
/// Represents `|filter_name:arg` in `{{ var|filter_name:arg }}`.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Filter {
    /// The filter name (e.g., "default", "date", "length")
    pub name: String,
    /// The filter argument, if any (e.g., `'nothing'` in `|default:'nothing'`)
    pub arg: Option<FilterArg>,
    /// Span of the entire filter (name + colon + arg, NOT including the leading `|`)
    pub span: Span,
}

impl Filter {
    /// Span of just the filter name
    pub fn name_span(&self) -> Span {
        self.span.with_length_usize_saturating(self.name.len())
    }
}

/// A filter argument.
///
/// The value is stored as the raw string from the template, including quotes.
/// E.g., for `|default:'nothing'`, the value is `'nothing'` (with quotes).
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct FilterArg {
    /// Raw argument value including quotes
    pub value: String,
    /// Span of the argument (NOT including the colon)
    pub span: Span,
}
```

#### 2. Update Node::Variable

**File**: `crates/djls-templates/src/nodelist.rs` **Changes**: Change filters field type

```rust
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Node {
    Tag {
        name: String,
        bits: Vec<String>,
        span: Span,
    },
    Comment {
        content: String,
        span: Span,
    },
    Text {
        span: Span,
    },
    Variable {
        var: String,
        filters: Vec<Filter>,  // CHANGED from Vec<String>
        span: Span,
    },
    Error {
        span: Span,
        full_span: Span,
        error: ParseError,
    },
}
```

#### 3. Update Parser with Quote-Aware Scanner

**File**: `crates/djls-templates/src/parser.rs` **Changes**: Rewrite `parse_variable` using a proper state-machine scanner

**CRITICAL**: Naive `split('|')` is WRONG. It breaks on `{{ x|default:"a|b" }}` where `|` appears inside quotes.

```rust
use crate::nodelist::Filter;
use crate::nodelist::FilterArg;

fn parse_variable(&mut self) -> Result<Node, ParseError> {
    let token = self.peek_previous()?;

    let Token::Variable {
        content: content_ref,
        ..
    } = token
    else {
        return Err(ParseError::InvalidSyntax {
            context: "Expected Variable token".to_string(),
        });
    };

    let content_span = token.content_span_or_fallback();
    let content_start = content_span.start();

    // Parse variable and filters using quote-aware scanner
    let (var, filters) = parse_variable_expression(content_ref, content_start)?;

    Ok(Node::Variable {
        var,
        filters,
        span: content_span,
    })
}

/// Parse a variable expression like `value|default:'nothing'|title`.
///
/// Uses a single-pass quote-aware scanner to correctly handle:
/// - `{{ x|default:"a|b" }}` — pipe inside quotes is NOT a filter separator
/// - `{{ x|default:'value:with:colons' }}` — colons inside quotes are argument content
/// - `{{ x | filter1 | filter2 }}` — whitespace around pipes
/// - `{{x|filter}}` — no whitespace
///
/// Returns (variable_name, filters) with byte-accurate spans.
fn parse_variable_expression(
    content: &str,
    content_start: u32,
) -> Result<(String, Vec<Filter>), ParseError> {
    let scanner = VariableScanner::new(content, content_start);
    scanner.parse()
}

/// State-machine scanner for variable expressions with quote awareness.
///
/// Tracks quote state to distinguish `|` as filter separator vs literal character.
struct VariableScanner<'a> {
    content: &'a str,
    content_start: u32,
    bytes: &'a [u8],
    pos: usize,
}

#[derive(Clone, Copy, PartialEq)]
enum QuoteState {
    None,
    Single,  // Inside '...'
    Double,  // Inside "..."
}

impl<'a> VariableScanner<'a> {
    fn new(content: &'a str, content_start: u32) -> Self {
        Self {
            content,
            content_start,
            bytes: content.as_bytes(),
            pos: 0,
        }
    }

    fn parse(mut self) -> Result<(String, Vec<Filter>), ParseError> {
        // Skip leading whitespace
        self.skip_whitespace();
        let var_start = self.pos;

        // Scan variable name (up to first unquoted | or end)
        let var_end = self.scan_until_unquoted_pipe();
        let var = self.content[var_start..var_end].trim().to_string();

        if var.is_empty() {
            return Err(ParseError::EmptyTag);
        }

        let mut filters = Vec::new();

        // Parse filters
        while self.pos < self.bytes.len() {
            // We're at a | character - skip it
            assert_eq!(self.bytes[self.pos], b'|');
            self.pos += 1;

            // Skip whitespace after |
            self.skip_whitespace();

            if self.pos >= self.bytes.len() {
                // Trailing pipe with nothing after - skip
                break;
            }

            // Parse single filter
            if let Some(filter) = self.parse_single_filter()? {
                filters.push(filter);
            }
        }

        Ok((var, filters))
    }

    /// Parse a single filter: `name` or `name:arg`
    fn parse_single_filter(&mut self) -> Result<Option<Filter>, ParseError> {
        let filter_byte_start = self.pos;
        let filter_start = self.content_start + filter_byte_start as u32;

        // Scan filter name (letters, digits, underscores - up to : or | or end)
        let name_start = self.pos;
        while self.pos < self.bytes.len() {
            let b = self.bytes[self.pos];
            if b == b':' || b == b'|' || b.is_ascii_whitespace() {
                break;
            }
            self.pos += 1;
        }
        let name = self.content[name_start..self.pos].to_string();

        if name.is_empty() {
            // Empty filter name (e.g., `||` or `| |`)
            self.scan_until_unquoted_pipe();
            return Ok(None);
        }

        // Skip whitespace after name
        self.skip_whitespace();

        // Check for argument
        let arg = if self.pos < self.bytes.len() && self.bytes[self.pos] == b':' {
            self.pos += 1; // Skip :
            let arg_raw_start = self.pos;

            // Scan argument (quote-aware, up to unquoted | or end)
            let arg_raw_end = self.scan_until_unquoted_pipe();
            let arg_raw = &self.content[arg_raw_start..arg_raw_end];

            // Compute trimmed bounds for accurate span
            let leading_ws = arg_raw.len() - arg_raw.trim_start().len();
            let trailing_ws = arg_raw.len() - arg_raw.trim_end().len();
            let arg_trimmed_start = arg_raw_start + leading_ws;
            let arg_trimmed_end = arg_raw_end - trailing_ws;

            let arg_value = arg_raw.trim().to_string();

            if !arg_value.is_empty() {
                let arg_span_start = self.content_start + arg_trimmed_start as u32;
                let arg_span_len = (arg_trimmed_end - arg_trimmed_start) as u32;

                Some(FilterArg {
                    value: arg_value,
                    span: Span::new(arg_span_start, arg_span_len),
                })
            } else {
                None
            }
        } else {
            // No argument - scan to next | anyway
            self.scan_until_unquoted_pipe();
            None
        };

        // Calculate filter span (from name start to end of arg or name)
        let filter_byte_end = self.pos;
        let filter_len = (filter_byte_end - filter_byte_start) as u32;
        // Trim trailing whitespace from span
        let trimmed_content = self.content[filter_byte_start..filter_byte_end].trim_end();
        let filter_span = Span::new(filter_start, trimmed_content.len() as u32);

        Ok(Some(Filter {
            name,
            arg,
            span: filter_span,
        }))
    }

    /// Scan forward until we hit an unquoted `|` or end of content.
    /// Returns the byte position (exclusive).
    ///
    /// Handles escape sequences inside quoted strings:
    /// - `\'` inside single quotes does NOT close the quote
    /// - `\"` inside double quotes does NOT close the quote
    /// - `\\` is an escaped backslash (consumes the next byte)
    fn scan_until_unquoted_pipe(&mut self) -> usize {
        let mut quote_state = QuoteState::None;

        while self.pos < self.bytes.len() {
            let b = self.bytes[self.pos];

            // Handle escape sequences inside quotes
            // When we see \, consume the next byte unconditionally
            if quote_state != QuoteState::None && b == b'\\' {
                self.pos += 1; // Skip the backslash
                if self.pos < self.bytes.len() {
                    self.pos += 1; // Skip the escaped character
                }
                continue;
            }

            match (quote_state, b) {
                // Opening quotes
                (QuoteState::None, b'\'') => quote_state = QuoteState::Single,
                (QuoteState::None, b'"') => quote_state = QuoteState::Double,

                // Closing quotes (only if not escaped - handled above)
                (QuoteState::Single, b'\'') => quote_state = QuoteState::None,
                (QuoteState::Double, b'"') => quote_state = QuoteState::None,

                // Unquoted pipe - stop here
                (QuoteState::None, b'|') => return self.pos,

                // Everything else - continue
                _ => {}
            }

            self.pos += 1;
        }

        self.pos
    }

    fn skip_whitespace(&mut self) {
        while self.pos < self.bytes.len() && self.bytes[self.pos].is_ascii_whitespace() {
            self.pos += 1;
        }
    }
}
```

**Key correctness properties**:

1. `|` inside quotes does NOT split: `{{ x|default:"a|b" }}` → `[Filter { name: "default", arg: "\"a|b\"" }]`
2. Escape sequences handled: `\"`, `\'`, `\\` inside quotes don't terminate the quote state
3. Spans computed from original byte indices with trimming accounted for:
    - `{{ x|default: 'value' }}` → arg span points to `'value'`, not ` 'value'`
4. Whitespace before variable is handled: `{{ value|f }}` vs `{{value|f}}`
5. Empty filters skipped: `{{ x|| }}` doesn't panic

#### 4. Update Export

**File**: `crates/djls-templates/src/lib.rs` **Changes**: Export new types

```rust
pub use nodelist::Filter;
pub use nodelist::FilterArg;
```

#### 5. Update Semantic Block Tree

**File**: `crates/djls-semantic/src/blocks/tree.rs` **Changes**: Update NodeView and pattern matches

Find `NodeView::Variable`:

```rust
// Before
Variable {
    var: String,
    filters: Vec<String>,
    span: Span,
}

// After
Variable {
    var: String,
    filters: Vec<djls_templates::Filter>,
    span: Span,
}
```

Find pattern match:

```rust
// Before
Node::Variable { var, filters, span } => NodeView::Variable {
    var: var.clone(),
    filters: filters.clone(),
    span: *span,
}

// After
Node::Variable { var, filters, span } => NodeView::Variable {
    var: var.clone(),
    filters: filters.clone(),
    span: *span,
}
// Note: This may need no code change if filters.clone() works with new type
```

#### 6. Update Block Builder

**File**: `crates/djls-semantic/src/blocks/builder.rs` **Changes**: Update pattern match (around line 434)

```rust
// The pattern match should still work since we just destructure
Node::Variable { .. } => {
    // Existing code
}
```

#### 7. Update IDE Context

**File**: `crates/djls-ide/src/context.rs` **Changes**: Update OffsetContext::Variable

```rust
// Before (line 23-25)
Variable {
    var: String,
    filters: Vec<String>,
}

// After
Variable {
    var: String,
    filters: Vec<djls_templates::Filter>,
}
```

Update pattern match (line 51-53):

```rust
Node::Variable { var, filters, .. } => Some(OffsetContext::Variable {
    var: var.clone(),
    filters: filters.clone(),
})
```

#### 8. Update TestNode for Snapshots

**File**: `crates/djls-templates/src/parser.rs` **Changes**: Update test helpers (around line 353)

```rust
#[derive(Debug, Serialize)]
struct TestFilter {
    name: String,
    arg: Option<String>,
    span: (u32, u32),
}

#[derive(Debug, Serialize)]
#[serde(tag = "type")]
enum TestNode {
    Tag { /* ... */ },
    Variable {
        var: String,
        filters: Vec<TestFilter>,  // CHANGED
        span: (u32, u32),
        full_span: (u32, u32),
    },
    // ...
}

// Update convert_nodelist_for_testing
Node::Variable { var, filters, span } => TestNode::Variable {
    var: var.clone(),
    filters: filters.iter().map(|f| TestFilter {
        name: f.name.clone(),
        arg: f.arg.as_ref().map(|a| a.value.clone()),
        span: f.span.into(),
    }).collect(),
    span: (*span).into(),
    full_span: full_span.into(),
}
```

#### 9. Add New Parser Unit Tests (Critical Edge Cases)

**File**: `crates/djls-templates/src/parser.rs` **Changes**: Add tests for quote-aware parsing

```rust
#[cfg(test)]
mod filter_parsing_tests {
    use super::*;

    #[test]
    fn test_pipe_inside_quotes_not_split() {
        // CRITICAL: This is the main bug the quote-aware scanner fixes
        let source = r#"{{ x|default:"a|b" }}"#;
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
        // Should produce ONE filter "default" with arg "\"a|b\"", NOT two filters
    }

    #[test]
    fn test_pipe_inside_single_quotes() {
        let source = "{{ x|default:'a|b|c' }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_colon_inside_quotes() {
        let source = r#"{{ x|date:"H:i:s" }}"#;
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
        // Arg should be "\"H:i:s\"", not split at colons
    }

    #[test]
    fn test_whitespace_preserved_in_spans() {
        // Whitespace around var and pipes
        let source = "{{ value | filter1 | filter2 }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_no_whitespace() {
        let source = "{{value|filter1|filter2}}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_leading_whitespace_before_var() {
        let source = "{{  value|filter }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_trailing_pipe() {
        // Trailing pipe with nothing after - should not panic
        let source = "{{ value| }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_empty_between_pipes() {
        // Empty filter between pipes - should skip gracefully
        let source = "{{ value||filter }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_filter_span_accuracy() {
        // Verify spans point to exact bytes
        let source = "{{ v|ab|cd:x }}";
        //              0123456789...
        // v is at 3, ab is at 5-6, cd:x is at 8-11
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_filter_with_variable_arg() {
        // Filter argument that's a variable, not quoted
        let source = "{{ value|default:other_var }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_filter_with_numeric_arg() {
        let source = "{{ value|truncatewords:30 }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_filter_arg_span_with_whitespace_after_colon() {
        // Whitespace after : should NOT be included in arg span
        let source = "{{ x|default: 'value' }}";
        //                         ^--- arg should start here, not at space
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
        // Arg span should point to 'value', not " 'value'"
    }

    #[test]
    fn test_filter_arg_span_with_whitespace_both_sides() {
        let source = "{{ x|default:  'value'  }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
        // Arg value should be "'value'" and span should exclude surrounding whitespace
    }

    #[test]
    fn test_complex_chain() {
        let source = r#"{{ value|default:"N/A"|title|truncatewords:5 }}"#;
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    // === ESCAPE SEQUENCE TESTS ===

    #[test]
    fn test_escaped_quote_in_double_quotes() {
        // \" inside double quotes should NOT close the quote
        let source = r#"{{ x|default:"say \"hello\"" }}"#;
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
        // Should be ONE filter with arg: "say \"hello\""
    }

    #[test]
    fn test_escaped_quote_in_single_quotes() {
        // \' inside single quotes should NOT close the quote
        let source = r"{{ x|default:'it\'s fine' }}";
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_escaped_backslash() {
        // \\ is an escaped backslash
        let source = r#"{{ x|default:"path\\to\\file" }}"#;
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
    }

    #[test]
    fn test_escaped_pipe_in_quotes() {
        // Pipe after escaped quote should still be recognized as separator
        let source = r#"{{ x|default:"a\""|upper }}"#;
        let nodelist = parse_test_template(source);
        insta::assert_yaml_snapshot!(convert_nodelist_for_testing(&nodelist));
        // Should be TWO filters: default with arg "a\"", then upper
    }
}
```

#### 10. Update All Existing Snapshots

**Files**: `crates/djls-templates/src/snapshots/*.snap`

Run `cargo test -p djls-templates` and update snapshots:

- `djls_templates__parser__tests__django__parse_django_variable_with_filter.snap`
- `djls_templates__parser__tests__django__parse_filter_chains.snap`
- `djls_templates__parser__tests__django__parse_mixed_content.snap`
- Any other snapshots containing `filters:`

**New snapshot format:**

```yaml
# Before
filters:
  - "default:'nothing'"
  - title

# After
filters:
  - name: default
    arg: "'nothing'"
    span: [8, 17]
  - name: title
    arg: ~
    span: [18, 23]
```

### Success Criteria:

#### Automated Verification:

- [ ] Cargo build passes: `cargo build`
- [ ] Clippy passes: `cargo clippy --all-targets -- -D warnings`
- [ ] All existing tests pass (after snapshot updates): `cargo test`
- [ ] Format passes: `cargo +nightly fmt`
- [ ] **CRITICAL**: `test_pipe_inside_quotes_not_split` passes (verifies quote-awareness)
- [ ] **CRITICAL**: `test_escaped_quote_in_double_quotes` passes (verifies escape handling)
- [ ] **CRITICAL**: `test_filter_span_accuracy` passes (verifies byte-accurate spans)
- [ ] **CRITICAL**: `test_filter_arg_span_with_whitespace_after_colon` passes (verifies trimmed arg spans)

#### Manual Verification:

- [ ] Open a template with `{{ x|default:"a|b" }}` in editor, verify single filter parsed
- [ ] Verify error recovery still works for malformed filters
- [ ] Hover on filter name shows correct range (not including arg)

**Implementation Note**: This phase should be done in a single PR to avoid intermediate broken states. The quote-aware scanner is the critical correctness fix — run `test_pipe_inside_quotes_not_split` first to verify. After completing this phase, pause for manual confirmation before proceeding.
