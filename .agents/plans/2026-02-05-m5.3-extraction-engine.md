# M5: Extraction Engine - Phase 3

> **Parent document**: [M5: Extraction Engine Overview](2026-02-05-m5-extraction-engine.md)

---

## Phase 3: Implement Function Context Detection

### Overview

Detect the variable names used in tag functions — specifically the variable bound to `token.split_contents()`. This enables rule extraction to work regardless of naming conventions.

**Why this matters**: Django code commonly uses `bits`, but also `args`, `parts`, `tokens`, etc. We must not hardcode any name.

### Changes Required:

#### 1. Implement context.rs

**File**: `crates/djls-extraction/src/context.rs`

```rust
//! Function context detection for tag functions.
//!
//! Detects key variable bindings:
//! - `split_var`: The variable bound to `token.split_contents()` (e.g., `bits`, `args`)
//! - `parser_var`: The parser parameter name (usually `parser`)
//! - `token_var`: The token parameter name (usually `token`)

use ruff_python_ast::Expr;
use ruff_python_ast::Mod;
use ruff_python_ast::Stmt;

use crate::parser::ParsedModule;
use crate::registry::RegistrationInfo;

/// Context for a tag function, including detected variable names.
#[derive(Debug, Clone)]
pub struct FunctionContext {
    /// Variable bound to `token.split_contents()` — may be None if not detected
    pub split_var: Option<String>,
    /// Parser parameter name (first param, usually `parser`)
    pub parser_var: Option<String>,
    /// Token parameter name (second param, usually `token`)
    pub token_var: Option<String>,
}

impl FunctionContext {
    /// Build context by analyzing the function definition.
    pub fn from_registration(parsed: &ParsedModule, registration: &RegistrationInfo) -> Self {
        let Mod::Module(module) = parsed.ast() else {
            return Self::empty();
        };

        let func_def = module.body.iter().find_map(|stmt| {
            if let Stmt::FunctionDef(fd) = stmt {
                if fd.name.as_str() == registration.function_name {
                    return Some(fd);
                }
            }
            None
        });

        let Some(func_def) = func_def else {
            return Self::empty();
        };

        // Extract parameter names (first two positional params)
        let params = &func_def.parameters;
        let parser_var = params.args.first().map(|p| p.parameter.name.to_string());
        let token_var = params.args.get(1).map(|p| p.parameter.name.to_string());

        // Find split_var by looking for: <var> = <token>.split_contents()
        let split_var = find_split_contents_var(&func_def.body, token_var.as_deref());

        Self {
            split_var,
            parser_var,
            token_var,
        }
    }

    fn empty() -> Self {
        Self {
            split_var: None,
            parser_var: None,
            token_var: None,
        }
    }

    /// Returns the split variable name, or None if not detected.
    pub fn split_var(&self) -> Option<&str> {
        self.split_var.as_deref()
    }
}

/// Find the variable assigned from `<token>.split_contents()`.
///
/// Looks for patterns like:
/// - `bits = token.split_contents()`
/// - `args = t.split_contents()`
fn find_split_contents_var(stmts: &[Stmt], token_var: Option<&str>) -> Option<String> {
    for stmt in stmts {
        match stmt {
            Stmt::Assign(assign) => {
                if is_split_contents_call(&assign.value, token_var) {
                    // Get the first target (simple name assignment)
                    if let Some(Expr::Name(name)) = assign.targets.first() {
                        return Some(name.id.to_string());
                    }
                }
            }

            // Recurse into control flow
            Stmt::If(if_stmt) => {
                if let Some(var) = find_split_contents_var(&if_stmt.body, token_var) {
                    return Some(var);
                }
                for clause in &if_stmt.elif_else_clauses {
                    if let Some(var) = find_split_contents_var(&clause.body, token_var) {
                        return Some(var);
                    }
                }
            }

            Stmt::Try(try_stmt) => {
                if let Some(var) = find_split_contents_var(&try_stmt.body, token_var) {
                    return Some(var);
                }
            }

            _ => {}
        }
    }

    None
}

/// Check if an expression is `<token>.split_contents()`.
fn is_split_contents_call(expr: &Expr, token_var: Option<&str>) -> bool {
    let Expr::Call(call) = expr else { return false };
    let Expr::Attribute(attr) = call.func.as_ref() else { return false };

    if attr.attr.as_str() != "split_contents" {
        return false;
    }

    // If we know the token var, verify it matches
    if let Some(expected_token) = token_var {
        if let Expr::Name(name) = attr.value.as_ref() {
            return name.id.as_str() == expected_token;
        }
    }

    // If we don't know the token var, accept any .split_contents() call
    true
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_module;
    use crate::registry::find_registrations;

    #[test]
    fn test_detect_bits() {
        let source = r#"
@register.tag
def my_tag(parser, token):
    bits = token.split_contents()
    return Node()
"#;
        let parsed = parse_module(source).unwrap();
        let regs = find_registrations(&parsed).unwrap();
        let ctx = FunctionContext::from_registration(&parsed, &regs.tags[0]);

        assert_eq!(ctx.split_var(), Some("bits"));
        assert_eq!(ctx.parser_var.as_deref(), Some("parser"));
        assert_eq!(ctx.token_var.as_deref(), Some("token"));
    }

    #[test]
    fn test_detect_args() {
        let source = r#"
@register.tag
def my_tag(p, t):
    args = t.split_contents()
    return Node()
"#;
        let parsed = parse_module(source).unwrap();
        let regs = find_registrations(&parsed).unwrap();
        let ctx = FunctionContext::from_registration(&parsed, &regs.tags[0]);

        assert_eq!(ctx.split_var(), Some("args"));
        assert_eq!(ctx.parser_var.as_deref(), Some("p"));
        assert_eq!(ctx.token_var.as_deref(), Some("t"));
    }

    #[test]
    fn test_detect_parts() {
        let source = r#"
@register.tag
def my_tag(parser, token):
    parts = token.split_contents()
    if len(parts) < 2:
        raise Error()
    return Node()
"#;
        let parsed = parse_module(source).unwrap();
        let regs = find_registrations(&parsed).unwrap();
        let ctx = FunctionContext::from_registration(&parsed, &regs.tags[0]);

        assert_eq!(ctx.split_var(), Some("parts"));
    }

    #[test]
    fn test_no_split_contents() {
        let source = r#"
@register.simple_tag
def my_tag(value):
    return value
"#;
        let parsed = parse_module(source).unwrap();
        let regs = find_registrations(&parsed).unwrap();
        let ctx = FunctionContext::from_registration(&parsed, &regs.tags[0]);

        assert_eq!(ctx.split_var(), None);
    }
}
```

### Success Criteria:

- [ ] Context tests pass: `cargo test -p djls-extraction context`
- [ ] Tests verify detection of various variable names (`bits`, `args`, `parts`)

---
