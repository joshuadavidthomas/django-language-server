# M4: Filters Pipeline - Phase 4

> **Parent document**: [M4: Filters Pipeline Overview](2026-02-05-m4-filters-pipeline.md)

---

## Phase 4: Filter Validation with Load Scoping

### Overview
Add validation that checks filters against the inventory and load state, producing diagnostics for unknown or unloaded filters.

### Changes Required:

#### 1. Add Error Variants
**File**: `crates/djls-semantic/src/errors.rs`
**Changes**: Add filter error variants

```rust
#[derive(Clone, Debug, Error, PartialEq, Eq, Serialize)]
pub enum ValidationError {
    // ... existing variants S100-S110 ...

    #[error("Unknown filter '{filter}'")]
    UnknownFilter { filter: String, span: Span },

    #[error("Filter '{filter}' requires '{{% load {library} %}}'")]
    UnloadedLibraryFilter {
        filter: String,
        library: String,
        span: Span,
    },

    #[error("Filter '{filter}' requires one of: {}", libraries.iter().map(|l| format!("{{% load {} %}}", l)).collect::<Vec<_>>().join(", "))]
    AmbiguousUnloadedFilter {
        filter: String,
        libraries: Vec<String>,
        span: Span,
    },
}
```

#### 2. Add Diagnostic Codes
**File**: `crates/djls-ide/src/diagnostics.rs`
**Changes**: Add codes for filter errors

```rust
impl DiagnosticError for ValidationError {
    fn code(&self) -> &'static str {
        match self {
            // ... existing S100-S110 ...
            ValidationError::UnknownFilter { .. } => "S111",
            ValidationError::UnloadedLibraryFilter { .. } => "S112",
            ValidationError::AmbiguousUnloadedFilter { .. } => "S113",
        }
    }

    fn span(&self) -> Option<(u32, u32)> {
        match self {
            // ... existing cases ...
            ValidationError::UnknownFilter { span, .. }
            | ValidationError::UnloadedLibraryFilter { span, .. }
            | ValidationError::AmbiguousUnloadedFilter { span, .. } => Some(span.into()),
        }
    }
}
```

#### 3. Add Filter Availability Query
**File**: `crates/djls-semantic/src/load_resolution.rs`
**Changes**: Add parallel to `available_tags_at`, using unified `InspectorInventory`

```rust
use djls_project::FilterProvenance;
use djls_project::InspectorInventory;

/// Result of querying available filters at a position.
#[derive(Debug, Clone, Default)]
pub struct AvailableFilters {
    pub filters: FxHashSet<String>,
}

impl AvailableFilters {
    pub fn has_filter(&self, name: &str) -> bool {
        self.filters.contains(name)
    }
}

/// Determine which filters are available at a given position.
/// 
/// Uses the same state-machine approach as `available_tags_at`.
/// Takes `InspectorInventory` (M2 unified type) and extracts filters.
pub fn available_filters_at(
    loaded: &LoadedLibraries,
    inventory: &InspectorInventory,
    position: u32,
) -> AvailableFilters {
    let mut available = AvailableFilters::default();
    
    // Build load state
    let mut state = LoadState::default();
    for stmt in loaded.loads() {
        if stmt.span.end() <= position {
            state.process(stmt);
        }
    }
    
    // Determine available filters from inventory
    for filter in inventory.filters() {
        match filter.provenance() {
            FilterProvenance::Builtin { .. } => {
                available.filters.insert(filter.name().to_string());
            }
            FilterProvenance::Library { load_name, .. } => {
                // Filters follow same scoping rules as tags
                if state.is_tag_available(filter.name(), load_name) {
                    available.filters.insert(filter.name().to_string());
                }
            }
        }
    }
    
    available
}
```

#### 4. Update Db Accessor to Use Unified Inventory
**File**: `crates/djls-semantic/src/db.rs`
**Changes**: Accessor returns reference to combined inventory

```rust
use djls_project::InspectorInventory;

#[salsa::db]
pub trait Db: TemplateDb {
    // ... existing methods ...
    
    /// Get the combined inspector inventory (tags + filters).
    /// Per M2, this reads from Project field (Salsa input), not a tracked query.
    fn inspector_inventory(&self) -> Option<&InspectorInventory>;
}
```

**File**: `crates/djls-server/src/db.rs`
**Changes**: Implement accessor reading from Project

```rust
fn inspector_inventory(&self) -> Option<&djls_project::InspectorInventory> {
    self.project()
        .and_then(|project| project.inspector_inventory(self).as_ref())
}
```

#### 5. Add Filter Validation
**File**: `crates/djls-semantic/src/load_resolution.rs`
**Changes**: Add validation function

```rust
/// Entry for a filter in the inventory lookup.
#[derive(Debug, Clone)]
enum FilterInventoryEntry {
    Builtin,
    Libraries(Vec<String>),
}

/// Build lookup from filter name to inventory entry.
/// Takes unified `InspectorInventory` and extracts filter data.
fn build_filter_inventory(inventory: &InspectorInventory) -> FxHashMap<String, FilterInventoryEntry> {
    let mut result: FxHashMap<String, FilterInventoryEntry> = FxHashMap::default();
    
    for filter in inventory.filters() {
        let name = filter.name().to_string();
        match filter.provenance() {
            FilterProvenance::Builtin { .. } => {
                result.insert(name, FilterInventoryEntry::Builtin);
            }
            FilterProvenance::Library { load_name, .. } => {
                if let Some(entry) = result.get_mut(&name) {
                    if let FilterInventoryEntry::Libraries(libs) = entry {
                        if !libs.contains(load_name) {
                            libs.push(load_name.clone());
                        }
                    }
                } else {
                    result.insert(name, FilterInventoryEntry::Libraries(vec![load_name.clone()]));
                }
            }
        }
    }
    
    result
}

/// Validate that all filters in the template are either builtins or from loaded libraries.
#[salsa::tracked]
pub fn validate_filter_scoping(
    db: &dyn crate::Db,
    nodelist: djls_templates::NodeList<'_>,
) {
    // Get unified inventory from Project (M2 pattern)
    let Some(inventory) = db.inspector_inventory() else {
        tracing::debug!("Inspector inventory unavailable, skipping filter scoping validation");
        return;
    };

    let loaded = compute_loaded_libraries(db, nodelist);
    let filter_lookup = build_filter_inventory(inventory);

    for node in nodelist.nodelist(db) {
        if let Node::Variable { filters, .. } = node {
            for filter in filters {
                validate_single_filter(
                    db,
                    filter,
                    &filter_lookup,
                    &loaded,
                    inventory,
                );
            }
        }
    }
}

fn validate_single_filter(
    db: &dyn crate::Db,
    filter: &djls_templates::Filter,
    filter_lookup: &FxHashMap<String, FilterInventoryEntry>,
    loaded: &LoadedLibraries,
    inventory: &InspectorInventory,
) {
    let name = &filter.name;
    let span = filter.name_span(); // Use filter name span for precise error location
    
    match filter_lookup.get(name) {
        None => {
            // Filter not in inventory at all
            ValidationErrorAccumulator(ValidationError::UnknownFilter {
                filter: name.clone(),
                span,
            })
            .accumulate(db);
        }
        Some(FilterInventoryEntry::Builtin) => {
            // Builtins always valid
        }
        Some(FilterInventoryEntry::Libraries(candidate_libs)) => {
            let available = available_filters_at(loaded, inventory, filter.span.start());
            
            if !available.has_filter(name) {
                if candidate_libs.len() == 1 {
                    ValidationErrorAccumulator(ValidationError::UnloadedLibraryFilter {
                        filter: name.clone(),
                        library: candidate_libs[0].clone(),
                        span,
                    })
                    .accumulate(db);
                } else {
                    ValidationErrorAccumulator(ValidationError::AmbiguousUnloadedFilter {
                        filter: name.clone(),
                        libraries: candidate_libs.clone(),
                        span,
                    })
                    .accumulate(db);
                }
            }
        }
    }
}
```

#### 6. Wire into validate_nodelist
**File**: `crates/djls-semantic/src/lib.rs`
**Changes**: Add call to filter validation

```rust
#[salsa::tracked]
pub fn validate_nodelist(db: &dyn Db, nodelist: djls_templates::NodeList<'_>) {
    if nodelist.nodelist(db).is_empty() {
        return;
    }

    let block_tree = build_block_tree(db, nodelist);
    let _forest = build_semantic_forest(db, block_tree, nodelist);
    validate_all_tag_arguments(db, nodelist);
    
    // Tag scoping (M3)
    load_resolution::validate_tag_scoping(db, nodelist);
    
    // Filter scoping (M4) - NEW
    load_resolution::validate_filter_scoping(db, nodelist);
}
```

### Success Criteria:

#### Automated Verification:
- [ ] Cargo build passes: `cargo build`
- [ ] All tests pass: `cargo test`
- [ ] Clippy passes: `cargo clippy --all-targets -- -D warnings`

#### Manual Verification:
- [ ] Use `{{ value|nonexistent }}` - verify S111 diagnostic
- [ ] Use `{{ value|floatformat }}` without `{% load humanize %}` - verify S112 (if floatformat is library filter)
- [ ] Add `{% load humanize %}` - verify S112 goes away
- [ ] Verify no false positives on builtin filters (title, upper, default, etc.)

**Implementation Note**: After completing this phase, pause for manual confirmation that diagnostics work correctly.

---

