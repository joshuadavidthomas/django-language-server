# M5: Extraction Engine - Phase 1

> **Parent document**: [M5: Extraction Engine Overview](2026-02-05-m5-extraction-engine.md)

---

## Phase 1: Create `djls-extraction` Crate with Ruff Parser

### Overview

Create a new crate with a pure, testable API for Python source extraction. Pin Ruff parser to a known-good SHA.

### Ruff Parser SHA Selection

**Decision**: Pin Ruff crates to a **full 40-character git commit SHA** (not a version tag string).

**The SHA is chosen at implementation time** — this plan does not prescribe a specific SHA. The implementer must:

1. **Choose a Ruff release tag** (e.g., `0.9.7`) based on:
    - Recent stable release (not pre-release/alpha)
    - Python syntax coverage needed (3.12+, 3.13+ if required)

2. **Resolve the tag to its commit SHA** (tags may be annotated objects, not commits):

    ```bash
    # List recent release tags
    git ls-remote --tags https://github.com/astral-sh/ruff \
      | grep -E 'refs/tags/[0-9]+\.[0-9]+\.[0-9]+$' \
      | tail -5

    # Resolve tag to commit SHA (handles annotated tags correctly)
    git ls-remote https://github.com/astral-sh/ruff refs/tags/<TAG>^{}
    # Or locally after cloning:
    git rev-parse <TAG>^{commit}
    ```

3. **Record both the source tag AND the resolved SHA** in Cargo.toml:
    ```toml
    # Ruff parser — pinned to tag v0.9.7
    # Resolved SHA: git rev-parse 0.9.7^{commit}
    ruff_python_parser = { git = "https://github.com/astral-sh/ruff", rev = "<40-HEX-SHA>" }
    ruff_python_ast = { git = "https://github.com/astral-sh/ruff", rev = "<40-HEX-SHA>" }
    ruff_text_size = { git = "https://github.com/astral-sh/ruff", rev = "<40-HEX-SHA>" }
    ```

**Example** (illustrative only — use actual values at implementation time):

```toml
# Ruff parser — pinned to tag v0.9.7
# Resolved: git ls-remote ... refs/tags/0.9.7^{} → abc123def456...
ruff_python_parser = { git = "https://github.com/astral-sh/ruff", rev = "abc123def456789abc123def456789abc123def4" }
```

**Update policy**:

- Bump SHA deliberately when Ruff adds Python syntax support we need or bug fixes affect extraction
- Never auto-update — always run golden tests before merging SHA bump
- Always record both the source tag and resolved SHA in comments

### Changes Required:

#### 1. Add Workspace Dependency

**File**: `Cargo.toml` (workspace root) **Changes**: Add to `[workspace.dependencies]`

```toml
[workspace.dependencies]
# ... existing deps ...

djls-extraction = { path = "crates/djls-extraction" }

# Ruff parser (internal crates, SHA-pinned)
# IMPLEMENTATION NOTE: Replace <40-HEX-SHA> with actual value.
# See "Ruff Parser SHA Selection" section for resolution steps.
#
# Example (use actual values):
#   Tag: v0.9.7
#   SHA: git ls-remote ... refs/tags/0.9.7^{} → <resolved-sha>
ruff_python_parser = { git = "https://github.com/astral-sh/ruff", rev = "<40-HEX-SHA>" }
ruff_python_ast = { git = "https://github.com/astral-sh/ruff", rev = "<40-HEX-SHA>" }
ruff_text_size = { git = "https://github.com/astral-sh/ruff", rev = "<40-HEX-SHA>" }
```

#### 2. Create Crate Structure

**Directory**: `crates/djls-extraction/`

```
crates/djls-extraction/
├── Cargo.toml
└── src/
    ├── lib.rs           # Public API
    ├── error.rs         # ExtractionError types
    ├── types.rs         # ExtractedTag, ExtractedFilter, etc.
    ├── parser.rs        # Ruff parser wrapper
    ├── registry.rs      # Find @register.tag/filter decorators
    ├── context.rs       # Function context: split_var detection
    ├── rules.rs         # Extract validation rules from guards
    ├── structural.rs    # Block spec extraction (parser.parse)
    ├── filters.rs       # Filter arity extraction
    └── patterns.rs      # AST pattern matching utilities
```

#### 3. Create Cargo.toml

**File**: `crates/djls-extraction/Cargo.toml`

```toml
[package]
name = "djls-extraction"
version = "0.0.0"
edition = "2021"
description = "Python AST extraction for Django template tag/filter validation rules"

[dependencies]
ruff_python_parser = { workspace = true }
ruff_python_ast = { workspace = true }
ruff_text_size = { workspace = true }

rustc-hash = { workspace = true }
serde = { workspace = true }
thiserror = { workspace = true }
tracing = { workspace = true }

[dev-dependencies]
insta = { workspace = true }
```

#### 4. Create Public API

**File**: `crates/djls-extraction/src/lib.rs`

````rust
//! Python AST extraction for Django template tag/filter validation rules.
//!
//! This crate provides a pure API for extracting validation semantics from
//! Python template tag/filter registration modules. It does NOT:
//! - Resolve module paths to file paths (caller's responsibility)
//! - Read files from disk (takes source text)
//! - Know about sys.path or Python environments
//!
//! ## Key Design Decisions
//!
//! 1. **No hardcoded variable names**: The split-contents variable (often `bits`,
//!    but could be `args`, `parts`, etc.) is detected by finding the assignment
//!    `<var> = token.split_contents()` and threading that name through rule extraction.
//!
//! 2. **No string-based end-tag heuristics**: End tags are NOT inferred from names
//!    like `starts_with("end")`. Instead, we analyze control flow patterns:
//!    - Singleton `parser.parse((<single>,))` calls indicate the closer
//!    - If ambiguous, we emit `None` rather than guess
//!
//! # Example
//!
//! ```rust,ignore
//! use djls_extraction::extract_rules;
//!
//! let source = r#"
//! @register.tag
//! def my_tag(parser, token):
//!     args = token.split_contents()  # Note: 'args', not 'bits'
//!     if len(args) != 2:
//!         raise TemplateSyntaxError("...")
//!     return MyNode(args[1])
//! "#;
//!
//! let result = extract_rules(source)?;
//! // result.tags contains ExtractedTag for "my_tag" with rules keyed to 'args'
//! ```

mod context;
mod error;
mod filters;
mod parser;
mod patterns;
mod registry;
mod rules;
mod structural;
mod types;

pub use error::ExtractionError;
pub use types::BlockTagSpec;
pub use types::DecoratorKind;
pub use types::ExtractedFilter;
pub use types::ExtractedRule;
pub use types::ExtractedTag;
pub use types::ExtractionResult;
pub use types::FilterArity;
pub use types::IntermediateTagSpec;
pub use types::RuleCondition;
pub use types::SymbolKey;
pub use types::SymbolKind;

/// Extract validation rules from a Python template registration module.
///
/// This is a pure function: source text in, extraction result out.
/// Module-to-path resolution is NOT this crate's responsibility.
pub fn extract_rules(source: &str) -> Result<ExtractionResult, ExtractionError> {
    let parsed = parser::parse_module(source)?;
    let registry = registry::find_registrations(&parsed)?;

    let mut tags = Vec::new();
    let mut filters = Vec::new();

    for reg in &registry.tags {
        // Build function context (detects split_var name, parser_var, token_var)
        let ctx = context::FunctionContext::from_registration(&parsed, reg);

        let rules = rules::extract_tag_rules(&parsed, reg, &ctx)?;
        let block_spec = structural::extract_block_spec(&parsed, reg, &ctx)?;

        tags.push(ExtractedTag {
            name: reg.name.clone(),
            decorator_kind: reg.decorator_kind.clone(),
            rules,
            block_spec,
        });
    }

    for reg in &registry.filters {
        let arity = filters::extract_filter_arity(&parsed, reg)?;

        filters.push(ExtractedFilter {
            name: reg.name.clone(),
            arity,
        });
    }

    Ok(ExtractionResult { tags, filters })
}
````

#### 5. Create Type Definitions

**File**: `crates/djls-extraction/src/types.rs`

```rust
use serde::Deserialize;
use serde::Serialize;

/// Key for addressing extracted rules - includes registration module to avoid collisions.
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct SymbolKey {
    /// Module path where registration occurs (e.g., "django.templatetags.i18n")
    pub registration_module: String,
    /// Tag/filter name as used in templates
    pub name: String,
    /// Whether this is a tag or filter
    pub kind: SymbolKind,
}

impl SymbolKey {
    pub fn tag(registration_module: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            registration_module: registration_module.into(),
            name: name.into(),
            kind: SymbolKind::Tag,
        }
    }

    pub fn filter(registration_module: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            registration_module: registration_module.into(),
            name: name.into(),
            kind: SymbolKind::Filter,
        }
    }
}

#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum SymbolKind {
    Tag,
    Filter,
}

/// Result of extracting rules from a Python module.
#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
pub struct ExtractionResult {
    pub tags: Vec<ExtractedTag>,
    pub filters: Vec<ExtractedFilter>,
}

impl ExtractionResult {
    pub fn is_empty(&self) -> bool {
        self.tags.is_empty() && self.filters.is_empty()
    }
}

/// Extracted validation data for a template tag.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ExtractedTag {
    /// Tag name as registered
    pub name: String,
    /// Kind of registration decorator (tag, simple_tag, inclusion_tag)
    pub decorator_kind: DecoratorKind,
    /// Validation rules extracted from TemplateSyntaxError guards
    pub rules: Vec<ExtractedRule>,
    /// Block structure (end tag, intermediates) if any
    pub block_spec: Option<BlockTagSpec>,
}

/// Kind of tag registration decorator.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum DecoratorKind {
    /// `@register.tag` — manual tag function (parser, token) -> Node
    Tag,
    /// `@register.simple_tag` — automatic argument parsing
    SimpleTag,
    /// `@register.inclusion_tag` — renders a template
    InclusionTag,
    /// `@register.simple_block_tag` — block tag with automatic end tag.
    /// Django hardcodes `end_name = f"end{function_name}"` when not explicitly provided
    /// (library.py:190). This is a Django-defined semantic default for THIS decorator only.
    SimpleBlockTag,
    /// Helper/wrapper decorator (e.g., `@register_simple_block_tag`)
    /// These are NOT `register.<method>` but are recognized registration signals
    HelperWrapper(String),
    /// Unknown decorator name
    Custom(String),
}

/// A validation rule extracted from Python source.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ExtractedRule {
    /// Condition that triggers the error
    pub condition: RuleCondition,
    /// Error message from the raise statement (if extractable)
    pub message: Option<String>,
}

/// Condition types for validation rules.
///
/// Note: These do NOT reference a specific variable name. The extraction process
/// identifies the split-contents variable dynamically and these conditions are
/// expressed in terms of "the split result" abstractly.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum RuleCondition {
    /// `len(<split>) == N` or `len(<split>) != N`
    ExactArgCount { count: usize, negated: bool },
    /// `len(<split>) < N` or `len(<split>) > N`
    ArgCountComparison { count: usize, op: ComparisonOp },
    /// `len(<split>) >= N` (minimum args)
    MinArgCount { min: usize },
    /// `len(<split>) <= N` (maximum args)
    MaxArgCount { max: usize },
    /// `<split>[N] == "keyword"` or `<split>[N] != "keyword"`
    LiteralAt { index: usize, value: String, negated: bool },
    /// `<split>[N] in ("opt1", "opt2", ...)`
    ChoiceAt { index: usize, choices: Vec<String>, negated: bool },
    /// `"keyword" in <split>` or `"keyword" not in <split>`
    ContainsLiteral { value: String, negated: bool },
    /// Complex condition we couldn't simplify
    Opaque { description: String },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ComparisonOp {
    Lt,
    LtEq,
    Gt,
    GtEq,
}

/// Block structure specification extracted from `parser.parse((...))` calls.
///
/// **Important**: End tags are inferred from control flow patterns, NOT from
/// string heuristics like `starts_with("end")`. If we cannot confidently
/// identify the closer, `end_tag` is `None`.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BlockTagSpec {
    /// End tag name (e.g., "endif" for "if") — inferred from control flow, not name patterns
    pub end_tag: Option<String>,
    /// Intermediate tags (e.g., "else", "elif" for "if")
    pub intermediate_tags: Vec<IntermediateTagSpec>,
    /// Whether this is an opaque block (like verbatim/comment)
    pub opaque: bool,
}

/// Specification for an intermediate tag.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IntermediateTagSpec {
    /// Tag name (e.g., "else", "elif")
    pub name: String,
    /// Can this tag repeat? (e.g., elif can, else cannot)
    pub repeatable: bool,
}

/// Extracted validation data for a template filter.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ExtractedFilter {
    /// Filter name as registered
    pub name: String,
    /// Argument arity
    pub arity: FilterArity,
}

/// Filter argument arity.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum FilterArity {
    None,
    Optional,
    Required,
    Unknown,
}
```

#### 6. Create Error Types

**File**: `crates/djls-extraction/src/error.rs`

```rust
use thiserror::Error;

#[derive(Debug, Clone, Error)]
pub enum ExtractionError {
    #[error("Failed to parse Python source: {message}")]
    ParseError { message: String },

    #[error("Unsupported Python syntax at offset {offset}: {description}")]
    UnsupportedSyntax { offset: usize, description: String },

    #[error("Could not resolve reference: {name}")]
    UnresolvedReference { name: String },
}
```

#### 7. Create Parser Wrapper

**File**: `crates/djls-extraction/src/parser.rs`

```rust
use ruff_python_ast::Mod;
use ruff_python_parser::parse_module as ruff_parse;
use ruff_python_parser::Parsed;

use crate::ExtractionError;

pub struct ParsedModule {
    pub(crate) parsed: Parsed<Mod>,
}

impl ParsedModule {
    pub fn ast(&self) -> &Mod {
        self.parsed.syntax()
    }
}

pub fn parse_module(source: &str) -> Result<ParsedModule, ExtractionError> {
    match ruff_parse(source) {
        Ok(parsed) => Ok(ParsedModule { parsed }),
        Err(errors) => {
            let message = errors
                .into_iter()
                .map(|e| e.error.to_string())
                .collect::<Vec<_>>()
                .join("; ");
            Err(ExtractionError::ParseError { message })
        }
    }
}
```

### Success Criteria:

#### Automated Verification:

- [ ] Cargo build passes: `cargo build -p djls-extraction`
- [ ] Clippy passes: `cargo clippy -p djls-extraction --all-targets -- -D warnings`
- [ ] Ruff SHA in Cargo.toml is exactly 40 hex characters (not a version string)
- [ ] Cargo.toml comment documents both source tag AND resolved SHA
