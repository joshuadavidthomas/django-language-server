# M5: Extraction Engine - Phase 9

> **Parent document**: [M5: Extraction Engine Overview](2026-02-05-m5-extraction-engine.md)

---

## Phase 9: Corpus / Full-Source Extraction Tests

### Overview

Small fixture tests (Phase 8) verify individual extraction patterns in isolation. This phase adds a second test tier that validates extraction at **Django + ecosystem scale** using a Rust-native corpus infrastructure.

**Why corpus testing matters:**
- Small fixtures cannot surface edge cases in real-world tag implementations
- Corpus tests catch regressions when modifying extraction heuristics
- Running against Django core + ecosystem libraries validates extraction robustness
- Provides confidence before removing handcoded builtins

### Rust-Native Corpus Infrastructure

Corpus management lives entirely in the Rust workspace. No external dependencies on Python tooling.

#### New Crate: `crates/djls-corpus/`

```
crates/djls-corpus/
├── Cargo.toml
├── manifest.toml           # Pins Django versions + third-party libs
├── src/
│   ├── lib.rs              # Library API for corpus enumeration
│   ├── manifest.rs         # Parse manifest.toml
│   ├── sync.rs             # Download + extract packages/repos
│   └── enumerate.rs        # Find extraction-relevant files
└── .corpus/                # Gitignored: downloaded corpus data
    ├── packages/           # PyPI packages (Django, wagtail, etc.)
    └── repos/              # Git repos (sentry, netbox, etc.)
```

#### Corpus Root Location

The corpus is stored at `crates/djls-corpus/.corpus/` (gitignored). Tests default to this location but can be overridden via `DJLS_CORPUS_ROOT`.

**`.gitignore` addition:**
```
crates/djls-corpus/.corpus/
```

### Changes Required

#### 1. Create Corpus Crate
**File**: `crates/djls-corpus/Cargo.toml`

```toml
[package]
name = "djls-corpus"
version = "0.0.0"
edition = "2021"
description = "Corpus management for Django template extraction testing"

[dependencies]
camino = { workspace = true }
reqwest = { version = "0.12", features = ["blocking"] }
serde = { workspace = true }
tar = "0.4"
flate2 = "1.0"
toml = "0.8"
walkdir = { workspace = true }
zip = "2.0"

[dev-dependencies]
# None — this crate is test infrastructure
```

#### 2. Create Manifest
**File**: `crates/djls-corpus/manifest.toml`

```toml
[corpus]
root_dir = ".corpus"

# Django versions (multiple supported branches)
[[package]]
name = "Django"
version = "6.0.2"

[[package]]
name = "Django"
version = "5.2.11"

[[package]]
name = "Django"
version = "5.1.15"

[[package]]
name = "Django"
version = "4.2.28"

# Third-party packages with templatetags
[[package]]
name = "django-debug-toolbar"
version = "4.4.6"

[[package]]
name = "django-allauth"
version = "0.63.3"

[[package]]
name = "django-crispy-forms"
version = "2.2"

[[package]]
name = "wagtail"
version = "7.3"

[[package]]
name = "django-compressor"
version = "4.5.1"

# ... additional packages from original manifest ...

# Project repos (pinned by commit)
[[repo]]
name = "getsentry-sentry"
url = "https://github.com/getsentry/sentry.git"
ref = "f96e0f2de81f9d5b95614393be420f3107604220"

[[repo]]
name = "netbox-community-netbox"
url = "https://github.com/netbox-community/netbox.git"
ref = "ee6cbdcefe1c522d718e880ea3f955e7683f2b9b"

# ... additional repos from original manifest ...
```

#### 3. Implement Sync Logic
**File**: `crates/djls-corpus/src/sync.rs`

```rust
//! Download and extract corpus packages/repos.
//!
//! This is a simplified Rust port of the Python sync logic.
//! Extracts only files relevant to extraction testing:
//! - `**/templatetags/**/*.py`
//! - `**/template/defaulttags.py`, `defaultfilters.py`, `loader_tags.py`

use std::path::Path;

use crate::manifest::Manifest;
use crate::manifest::Package;
use crate::manifest::Repo;

pub fn sync_corpus(manifest: &Manifest, corpus_root: &Path) -> anyhow::Result<()> {
    let packages_dir = corpus_root.join("packages");
    let repos_dir = corpus_root.join("repos");
    
    std::fs::create_dir_all(&packages_dir)?;
    std::fs::create_dir_all(&repos_dir)?;
    
    for package in &manifest.packages {
        sync_package(package, &packages_dir)?;
    }
    
    for repo in &manifest.repos {
        sync_repo(repo, &repos_dir)?;
    }
    
    Ok(())
}

fn sync_package(package: &Package, packages_dir: &Path) -> anyhow::Result<()> {
    let out_dir = packages_dir.join(&package.name).join(&package.version);
    let marker = out_dir.join(".complete");
    
    if marker.exists() {
        return Ok(()); // Already synced
    }
    
    // Download from PyPI, extract relevant files
    // ... implementation details ...
    
    std::fs::write(marker, "")?;
    Ok(())
}

fn sync_repo(repo: &Repo, repos_dir: &Path) -> anyhow::Result<()> {
    let out_dir = repos_dir.join(&repo.name).join(&repo.git_ref);
    let marker = out_dir.join(".complete");
    
    if marker.exists() {
        return Ok(());
    }
    
    // Clone repo, extract relevant files
    // ... implementation details ...
    
    std::fs::write(marker, "")?;
    Ok(())
}
```

#### 4. Add Justfile Targets
**File**: `Justfile` (append to existing)

```just
# Corpus management for extraction testing
corpus-sync:
    cargo run -p djls-corpus -- sync

corpus-clean:
    cargo run -p djls-corpus -- clean
```

#### 4b. Add Binary Entry Point to Corpus Crate
**File**: `crates/djls-corpus/src/main.rs` (NEW)

```rust
//! CLI entry point for corpus management.

use std::path::Path;

fn main() {
    let args: Vec<String> = std::env::args().collect();
    
    match args.get(1).map(String::as_str) {
        Some("sync") => corpus_sync(),
        Some("clean") => corpus_clean(),
        _ => {
            eprintln!("Usage: cargo run -p djls-corpus -- [sync|clean]");
            eprintln!("   or: just corpus-sync | just corpus-clean");
            std::process::exit(1);
        }
    }
}

fn corpus_sync() {
    use djls_corpus::manifest::Manifest;
    use djls_corpus::sync::sync_corpus;
    
    let manifest_path = Path::new("crates/djls-corpus/manifest.toml");
    let manifest = Manifest::load(manifest_path).expect("load manifest");
    let corpus_root = Path::new("crates/djls-corpus/.corpus");
    
    sync_corpus(&manifest, corpus_root).expect("sync corpus");
    println!("Corpus synced to {}", corpus_root.display());
}

fn corpus_clean() {
    let corpus_root = Path::new("crates/djls-corpus/.corpus");
    if corpus_root.exists() {
        std::fs::remove_dir_all(corpus_root).expect("remove corpus");
        println!("Corpus cleaned");
    }
}
```

**Update**: `crates/djls-corpus/Cargo.toml` — add binary target:

```toml
[[bin]]
name = "djls-corpus"
path = "src/main.rs"
```

#### 5. Create Corpus Test Module
**File**: `crates/djls-extraction/tests/corpus.rs`

```rust
//! Corpus-scale extraction tests.
//!
//! These tests enumerate all registration modules in the corpus and run
//! extraction on each, validating:
//! - No panics (extraction is resilient to all Python patterns)
//! - Parse failures are logged with context (not silent)
//! - Stable serialization (golden snapshots for key entries)
//! - Key invariants hold across the corpus
//!
//! # Running
//!
//! These tests are gated by `DJLS_CORPUS_ROOT` to avoid CI failures when
//! corpus isn't synced. Default location: `crates/djls-corpus/.corpus/`
//!
//! ```bash
//! # First, sync the corpus:
//! just corpus-sync
//!
//! # Then run corpus tests (uses default corpus location):
//! cargo test -p djls-extraction corpus -- --nocapture
//!
//! # Or with explicit path:
//! DJLS_CORPUS_ROOT=crates/djls-corpus/.corpus cargo test -p djls-extraction corpus
//! ```

use std::collections::HashMap;
use std::path::Path;
use std::path::PathBuf;

use djls_extraction::extract_rules;
use djls_extraction::ExtractionResult;
use walkdir::WalkDir;

/// Default corpus location (relative to workspace root).
const DEFAULT_CORPUS_ROOT: &str = "crates/djls-corpus/.corpus";

/// Get corpus root from environment, or use default if it exists.
fn corpus_root() -> Option<PathBuf> {
    // Explicit env var takes precedence
    if let Ok(path) = std::env::var("DJLS_CORPUS_ROOT") {
        return Some(PathBuf::from(path));
    }
    
    // Try default location
    let default = PathBuf::from(DEFAULT_CORPUS_ROOT);
    if default.exists() {
        return Some(default);
    }
    
    None
}

/// Find all Python files relevant to extraction in the corpus.
fn enumerate_extraction_files(corpus_root: &Path) -> Vec<PathBuf> {
    let mut files = Vec::new();
    
    for entry in WalkDir::new(corpus_root)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
    {
        let path = entry.path();
        let path_str = path.to_string_lossy();
        
        // Skip __pycache__
        if path_str.contains("__pycache__") {
            continue;
        }
        
        // Must be a .py file
        if path.extension().map_or(true, |ext| ext != "py") {
            continue;
        }
        
        // Pattern 1: **/templatetags/**/*.py
        if path_str.contains("/templatetags/") {
            files.push(path.to_path_buf());
            continue;
        }
        
        // Pattern 2: Django core template modules
        let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
        if path_str.contains("/template/") && 
           matches!(file_name, "defaulttags.py" | "defaultfilters.py" | "loader_tags.py")
        {
            files.push(path.to_path_buf());
        }
    }
    
    files.sort();
    files.dedup();
    files
}

/// Extraction outcome for a single file.
#[derive(Debug)]
enum ExtractionOutcome {
    Success(ExtractionResult),
    ParseFailure(String),
    ExtractionError(String),
}

/// Run extraction on a single file, capturing outcome.
fn extract_file(path: &Path) -> ExtractionOutcome {
    let source = match std::fs::read_to_string(path) {
        Ok(s) => s,
        Err(e) => return ExtractionOutcome::ExtractionError(format!("read error: {}", e)),
    };
    
    match extract_rules(&source) {
        Ok(result) => ExtractionOutcome::Success(result),
        Err(djls_extraction::ExtractionError::ParseError { message }) => {
            ExtractionOutcome::ParseFailure(message)
        }
        Err(e) => ExtractionOutcome::ExtractionError(e.to_string()),
    }
}

#[test]
fn test_corpus_extraction_no_panics() {
    let Some(root) = corpus_root() else {
        eprintln!("Corpus not available (run `just corpus-sync` first)");
        eprintln!("Or set DJLS_CORPUS_ROOT to corpus location");
        return;
    };
    
    let files = enumerate_extraction_files(&root);
    assert!(!files.is_empty(), "Corpus should contain extraction targets");
    
    let mut success_count = 0;
    let mut parse_failure_count = 0;
    let mut error_count = 0;
    let mut failures: Vec<(PathBuf, String)> = Vec::new();
    
    for path in &files {
        match extract_file(path) {
            ExtractionOutcome::Success(_) => success_count += 1,
            ExtractionOutcome::ParseFailure(msg) => {
                parse_failure_count += 1;
                eprintln!("Parse failure in {}: {}", path.display(), msg);
            }
            ExtractionOutcome::ExtractionError(msg) => {
                error_count += 1;
                failures.push((path.clone(), msg));
            }
        }
    }
    
    eprintln!("\n=== Corpus Extraction Summary ===");
    eprintln!("Total files:      {}", files.len());
    eprintln!("Successful:       {}", success_count);
    eprintln!("Parse failures:   {} (expected for unsupported syntax)", parse_failure_count);
    eprintln!("Errors:           {}", error_count);
    
    assert!(
        failures.is_empty(),
        "Extraction errors (not parse failures):\n{}",
        failures
            .iter()
            .map(|(p, e)| format!("  {}: {}", p.display(), e))
            .collect::<Vec<_>>()
            .join("\n")
    );
}

#[test]
fn test_corpus_extraction_yields_results() {
    let Some(root) = corpus_root() else {
        return;
    };
    
    let files = enumerate_extraction_files(&root);
    
    let mut tags_found = 0;
    let mut filters_found = 0;
    let mut files_with_registrations = 0;
    
    for path in &files {
        if let ExtractionOutcome::Success(result) = extract_file(path) {
            if !result.is_empty() {
                files_with_registrations += 1;
                tags_found += result.tags.len();
                filters_found += result.filters.len();
            }
        }
    }
    
    eprintln!("\n=== Extraction Yields ===");
    eprintln!("Files with registrations: {}", files_with_registrations);
    eprintln!("Tags extracted:           {}", tags_found);
    eprintln!("Filters extracted:        {}", filters_found);
    
    assert!(tags_found > 50, "Expected >50 tags from corpus, got {}", tags_found);
    assert!(filters_found > 20, "Expected >20 filters from corpus, got {}", filters_found);
}

#[test]
fn test_corpus_no_hardcoded_bits_assumption() {
    let Some(root) = corpus_root() else {
        return;
    };
    
    let files = enumerate_extraction_files(&root);
    let mut non_bits_vars_found = 0;
    
    for path in &files {
        let source = match std::fs::read_to_string(path) {
            Ok(s) => s,
            Err(_) => continue,
        };
        
        for line in source.lines() {
            if line.contains("split_contents()") {
                if let Some(var) = line.split('=').next() {
                    let var = var.trim();
                    if !var.is_empty() && var != "bits" {
                        non_bits_vars_found += 1;
                    }
                }
            }
        }
    }
    
    eprintln!("Non-'bits' split_contents assignments found: {}", non_bits_vars_found);
}

#[test]
fn test_corpus_django_versions_golden() {
    let Some(root) = corpus_root() else {
        return;
    };
    
    let django_packages = root.join("packages/Django");
    if !django_packages.exists() {
        eprintln!("Django packages not in corpus, skipping");
        return;
    }
    
    let django_dirs: Vec<_> = std::fs::read_dir(&django_packages)
        .into_iter()
        .flatten()
        .filter_map(|e| e.ok())
        .map(|e| e.path())
        .filter(|p| {
            let name = p.file_name().unwrap().to_string_lossy();
            name.chars().filter(|c| *c == '.').count() >= 2
        })
        .collect();
    
    if django_dirs.is_empty() {
        eprintln!("No Django version dirs found, skipping");
        return;
    }
    
    let mut version_results: HashMap<String, ExtractionResult> = HashMap::new();
    
    for django_dir in django_dirs {
        let version = django_dir.file_name().unwrap().to_string_lossy().to_string();
        let defaulttags = django_dir.join("django/template/defaulttags.py");
        
        if defaulttags.exists() {
            if let ExtractionOutcome::Success(result) = extract_file(&defaulttags) {
                version_results.insert(version, result);
            }
        }
    }
    
    insta::assert_yaml_snapshot!("django_versions_extraction", version_results, {
        ".*[].rules[].message" => "[message]",
    });
}

#[test]
fn test_corpus_unsupported_patterns_summary() {
    let Some(root) = corpus_root() else {
        return;
    };
    
    let files = enumerate_extraction_files(&root);
    
    let mut opaque_rules = 0;
    let mut ambiguous_block_specs = 0;
    let mut total_tags = 0;
    let mut total_with_rules = 0;
    let mut total_with_block_spec = 0;
    
    for path in &files {
        if let ExtractionOutcome::Success(result) = extract_file(path) {
            for tag in &result.tags {
                total_tags += 1;
                
                if !tag.rules.is_empty() {
                    total_with_rules += 1;
                    for rule in &tag.rules {
                        if matches!(rule.condition, djls_extraction::RuleCondition::Opaque { .. }) {
                            opaque_rules += 1;
                        }
                    }
                }
                
                if let Some(ref spec) = tag.block_spec {
                    if spec.end_tag.is_some() {
                        total_with_block_spec += 1;
                    } else {
                        ambiguous_block_specs += 1;
                    }
                }
            }
        }
    }
    
    eprintln!("\n=== Unsupported Pattern Summary ===");
    eprintln!("Total tags:                {}", total_tags);
    eprintln!("Tags with rules:           {}", total_with_rules);
    eprintln!("Tags with block spec:      {}", total_with_block_spec);
    eprintln!("Opaque rules (couldn't simplify): {}", opaque_rules);
    eprintln!("Ambiguous block specs (end_tag=None): {}", ambiguous_block_specs);
}
```

#### 6. Add Walkdir Dev-Dependency
**File**: `crates/djls-extraction/Cargo.toml`

```toml
[dev-dependencies]
insta = { workspace = true }
walkdir = { workspace = true }
```

#### 7. Create Corpus CI Workflow
**File**: `.github/workflows/corpus-tests.yml`

```yaml
name: Corpus Tests

on:
  schedule:
    - cron: '0 6 * * 1'  # Weekly on Monday
  workflow_dispatch:

jobs:
  corpus-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Install just
        uses: extractions/setup-just@v2
      
      - name: Sync corpus
        run: just corpus-sync
      
      - name: Run corpus extraction tests
        run: cargo test -p djls-extraction corpus -- --nocapture
```

### Parity Oracle (TEMPORARY Porting Scaffolding)

> **⚠️ TEMPORARY**: This test exists only to validate the port. It must be deleted after M6 parity is achieved. See "Post-Port Cleanup" section below.

**What is it?** A "parity oracle" uses the Python prototype as a known-correct reference implementation to validate Rust extraction output during the porting effort. This is **temporary scaffolding** — useful until M6 parity is achieved, then deleted.

**Lifecycle:**
- **During port (M5–M6):** Use to catch heuristic drift, validate 1:1 behavior with Python prototype
- **After port complete:** Delete `test_corpus_parity_with_python_prototype`, remove all `template_linter` references from Rust workspace

**When to use it:** Only during active porting work, when modifying extraction heuristics and needing to verify Rust matches Python output.

**Requirements:** Requires a separate checkout of the Python prototype and explicit opt-in via environment variables.

#### Parity Test (Developer-Only)

**File**: `crates/djls-extraction/tests/corpus.rs` (append)

```rust
/// Parity oracle: compare Rust extraction to Python prototype.
///
/// **⚠️ TEMPORARY PORTING SCAFFOLDING — DELETE AFTER M6 PARITY ACHIEVED**
///
/// This test validates that Rust extraction matches the Python prototype during
/// the porting effort. Once M6 is complete and parity is confirmed:
/// 1. Delete this entire test function
/// 2. Remove any `template_linter` references from the Rust workspace
/// 3. Keep only Rust-native corpus tests as long-term guardrails
///
/// Requirements:
/// - `DJLS_PY_ORACLE=1` — explicit opt-in
/// - `DJLS_PY_ORACLE_PATH` — path to Python prototype checkout
/// - Corpus synced (DJLS_CORPUS_ROOT or default location)
///
/// Example:
/// ```bash
/// DJLS_PY_ORACLE=1 \
/// DJLS_PY_ORACLE_PATH=/path/to/template_linter \
/// cargo test -p djls-extraction test_corpus_parity -- --nocapture
/// ```
#[test]
fn test_corpus_parity_with_python_prototype() {
    // Gate 1: Corpus must be available
    let Some(corpus) = corpus_root() else {
        eprintln!("Corpus not available, skipping parity test");
        return;
    };
    
    // Gate 2: Must explicitly opt-in
    if std::env::var("DJLS_PY_ORACLE").as_deref() != Ok("1") {
        eprintln!("DJLS_PY_ORACLE not set — parity oracle is opt-in developer scaffolding");
        eprintln!("Set DJLS_PY_ORACLE=1 and DJLS_PY_ORACLE_PATH=/path/to/prototype to enable");
        return;
    }
    
    // Gate 3: Must provide prototype path
    let prototype_path = match std::env::var("DJLS_PY_ORACLE_PATH") {
        Ok(p) => PathBuf::from(p),
        Err(_) => {
            eprintln!("DJLS_PY_ORACLE_PATH not set — must point to Python prototype checkout");
            return;
        }
    };
    
    if !prototype_path.exists() {
        eprintln!("DJLS_PY_ORACLE_PATH does not exist: {}", prototype_path.display());
        return;
    }
    
    // Verify prototype is runnable
    let prototype_check = std::process::Command::new("uv")
        .args(["run", "--directory", &prototype_path.to_string_lossy(), "python", "-c", "import template_linter"])
        .status();
    
    if !prototype_check.map(|s| s.success()).unwrap_or(false) {
        eprintln!("Python prototype not runnable at {}", prototype_path.display());
        return;
    }
    
    // Test against Django's defaulttags.py
    let django_version = std::env::var("DJLS_PY_ORACLE_DJANGO_VERSION")
        .unwrap_or_else(|_| "5.2.11".to_string());
    
    let test_file = corpus.join(format!("packages/Django/{}/django/template/defaulttags.py", django_version));
    if !test_file.exists() {
        eprintln!("Django {} not in corpus", django_version);
        return;
    }
    
    // Run Rust extraction
    let rust_result = match extract_file(&test_file) {
        ExtractionOutcome::Success(r) => r,
        other => {
            eprintln!("Rust extraction failed: {:?}", other);
            return;
        }
    };
    
    // Run Python extraction
    let python_output = std::process::Command::new("uv")
        .args([
            "run",
            "--directory",
            &prototype_path.to_string_lossy(),
            "python",
            "-c",
            &format!(
                r#"
import json
from template_linter.extraction import extract_from_file
result = extract_from_file("{}")
print(json.dumps({{
    "tags": sorted([t.name for t in result.tags]),
    "filters": sorted([f.name for f in result.filters]),
    "block_tags": sorted([t.name for t in result.tags if t.block_spec and t.block_spec.end_tag]),
}}, sort_keys=True))
"#,
                test_file.display()
            ),
        ])
        .output();
    
    let python_result: serde_json::Value = match python_output {
        Ok(output) if output.status.success() => {
            serde_json::from_slice(&output.stdout).expect("parse Python JSON")
        }
        Ok(output) => {
            eprintln!("Python extraction failed:\n{}", String::from_utf8_lossy(&output.stderr));
            return;
        }
        Err(e) => {
            eprintln!("Failed to run Python: {}", e);
            return;
        }
    };
    
    // Compare
    let mut rust_tags: Vec<_> = rust_result.tags.iter().map(|t| t.name.as_str()).collect();
    rust_tags.sort();
    let python_tags: Vec<&str> = python_result["tags"]
        .as_array()
        .unwrap()
        .iter()
        .map(|v| v.as_str().unwrap())
        .collect();
    
    let missing: Vec<_> = python_tags.iter().filter(|t| !rust_tags.contains(t)).collect();
    let extra: Vec<_> = rust_tags.iter().filter(|t| !python_tags.contains(t)).collect();
    
    eprintln!("\n=== Parity Oracle Report (Django {}) ===", django_version);
    eprintln!("Rust: {} tags, Python: {} tags", rust_tags.len(), python_tags.len());
    if !missing.is_empty() {
        eprintln!("Missing in Rust: {:?}", missing);
    }
    if !extra.is_empty() {
        eprintln!("Extra in Rust: {:?}", extra);
    }
    
    // Informational — track parity over time, don't hard-fail
    if missing.len() > 5 {
        eprintln!("WARNING: Large parity gap. Review extraction heuristics.");
    }
}
```

### Running Corpus Tests

**Standard workflow (no Python prototype needed):**

```bash
# 1. Sync corpus (one-time, ~5-10 minutes)
just corpus-sync

# 2. Run corpus extraction tests
cargo test -p djls-extraction corpus -- --nocapture

# 3. Update golden snapshots if needed
cargo insta test -p djls-extraction
cargo insta review
```

**With explicit corpus path:**

```bash
DJLS_CORPUS_ROOT=/path/to/corpus cargo test -p djls-extraction corpus
```

**With parity oracle (developer-only):**

```bash
# Requires separate Python prototype checkout
DJLS_PY_ORACLE=1 \
DJLS_PY_ORACLE_PATH=/path/to/template_linter \
DJLS_PY_ORACLE_DJANGO_VERSION=5.2.11 \
cargo test -p djls-extraction test_corpus_parity -- --nocapture
```

### Unsupported Pattern Policy

Some Python patterns cannot be statically extracted. Policy:

| Pattern | Handling | Example |
|---------|----------|---------|
| Dynamic decorator args | Skip (no panic) | `@register.tag(get_name())` |
| Computed stop tags | `block_spec: None` | `parser.parse((f"end{name}",))` |
| Complex conditionals | `RuleCondition::Opaque` | `if some_func(bits):` |
| Walrus operator | Parse failure (log) | `if (x := foo()):` (Python 3.8+) |

**Tracking progress:**
- `test_corpus_unsupported_patterns_summary` outputs counts
- As extraction improves, opaque/ambiguous counts should decrease
- Snapshot tests catch regressions

### Success Criteria

#### Automated Verification:
- [ ] Corpus crate builds: `cargo build -p djls-corpus`
- [ ] Corpus sync works: `just corpus-sync`
- [ ] Corpus tests compile: `cargo build -p djls-extraction --tests`
- [ ] Tests skip gracefully without corpus: `cargo test -p djls-extraction corpus`
- [ ] Tests run with corpus: `cargo test -p djls-extraction corpus`

#### Corpus Coverage:
- [ ] No panics on any corpus file
- [ ] >50 tags extracted from corpus
- [ ] >20 filters extracted from corpus
- [ ] Django version golden snapshots pass
- [ ] Parse failures logged with file context

#### Parity Oracle (TEMPORARY — during port only):
- [ ] Test runs with all three env vars set
- [ ] Outputs comparison metrics
- [ ] Gracefully skips when not configured
- [ ] Used to validate Rust matches Python during M5–M6 development

### Post-Port Cleanup (After M6 Parity Achieved)

Once M6 rule evaluation is complete and parity with the Python prototype is confirmed, the temporary scaffolding must be removed:

#### Cleanup Tasks:
- [ ] **Delete parity oracle test**: Remove `test_corpus_parity_with_python_prototype` from `crates/djls-extraction/tests/corpus.rs`
- [ ] **Remove `template_linter` references**: Grep workspace for any remaining references to `template_linter` and remove them
- [ ] **Update docs**: Remove parity oracle documentation from this plan and any READMEs
- [ ] **Verify Rust-only tests remain**: Confirm `test_corpus_extraction_*` tests still pass as long-term guardrails

#### Long-Term Test Strategy (Post-Cleanup):
| What Remains | Purpose |
|--------------|---------|
| Tier 1: Unit/Fixture tests | Fast, deterministic pattern verification |
| Tier 2: Corpus tests (Rust-only) | Scale validation, regression detection |
| Golden snapshots | Catch extraction changes across Django versions |

The Python prototype is no longer needed after cleanup — Rust corpus tests provide sufficient coverage.

---

