#!/usr/bin/env python3
"""
Simulate the build.rs doc generation for testing purposes.
This generates the individual rule markdown files.
"""

import sys
from pathlib import Path

try:
    import tomllib  # Python 3.11+
except ImportError:
    import tomli as tomllib  # Fallback for older Python


def generate_rule_page(rule):
    """Generate a single rule's markdown page."""
    page = f"# {rule['code']} - {rule['name']}\n\n"
    page += "<!-- This file is automatically generated from diagnostics.toml -->\n"
    page += "<!-- Do not edit manually. To update this rule, edit the TOML file instead. -->\n\n"

    page += f"**Code:** `{rule['code']}`  \n"
    page += f"**Category:** {rule['category']}  \n"
    page += f"**Severity:** {rule['severity']}  \n\n"

    page += "## Description\n\n"
    page += rule['description']
    page += "\n\n"

    if 'explanation' in rule and rule['explanation']:
        page += "## Details\n\n"
        page += rule['explanation'].strip()
        page += "\n"

    return page


def main():
    # Read TOML
    toml_path = Path(__file__).parent / "crates" / "djls-ide" / "diagnostics.toml"
    with open(toml_path, "rb") as f:
        data = tomllib.load(f)

    rules = data.get("rule", [])

    # Create docs/rules directory
    docs_dir = Path(__file__).parent / "docs" / "rules"
    docs_dir.mkdir(parents=True, exist_ok=True)

    # Group by category
    template_rules = [r for r in rules if r['category'] == 'template']
    semantic_rules = [r for r in rules if r['category'] == 'semantic']

    # Generate individual rule pages
    for rule in rules:
        rule_path = docs_dir / f"{rule['code']}.md"
        content = generate_rule_page(rule)
        rule_path.write_text(content)
        print(f"Generated: {rule_path}")

    # Generate index page
    index = "# Diagnostic Rules Reference\n\n"
    index += "<!-- This file is automatically generated from diagnostics.toml -->\n"
    index += "<!-- Do not edit manually. To update rules, edit the TOML file instead. -->\n\n"
    index += "This document lists all diagnostic rules provided by the Django Language Server.\n\n"

    index += "## Template Parsing Errors (T-series)\n\n"
    index += "These errors occur during the parsing phase of template processing.\n\n"
    for rule in template_rules:
        index += f"- [**{rule['code']}**](./{rule['code']}.md) - {rule['name']}\n"
    index += "\n"

    index += "## Semantic Validation Errors (S-series)\n\n"
    index += "These errors are detected during semantic analysis of valid template syntax.\n\n"
    for rule in semantic_rules:
        index += f"- [**{rule['code']}**](./{rule['code']}.md) - {rule['name']}\n"

    index_path = docs_dir / "index.md"
    index_path.write_text(index)
    print(f"Generated: {index_path}")

    # Also generate the lookup data preview
    print("\n" + "="*70)
    print("Generated lookup table (would be in diagnostic_codes.rs):")
    print("="*70)
    print("pub(crate) const DIAGNOSTIC_CODE_MAPPINGS: &[(&str, &str)] = &[")
    for rule in rules:
        for error_type in rule['error_type'].split('|'):
            error_type = error_type.strip()
            print(f'    ("{error_type}", "{rule["code"]}"),')
    print("];")

    print("\nâœ“ Documentation generated successfully!")
    return 0


if __name__ == "__main__":
    sys.exit(main())
