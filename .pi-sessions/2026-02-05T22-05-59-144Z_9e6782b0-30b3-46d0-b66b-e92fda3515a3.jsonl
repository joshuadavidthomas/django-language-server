{"type":"session","version":3,"id":"9e6782b0-30b3-46d0-b66b-e92fda3515a3","timestamp":"2026-02-05T22:05:59.144Z","cwd":"/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6"}
{"type":"model_change","id":"e4322bdc","parentId":null,"timestamp":"2026-02-05T22:05:59.146Z","provider":"anthropic","modelId":"claude-opus-4-6"}
{"type":"thinking_level_change","id":"aeb3cce6","parentId":"e4322bdc","timestamp":"2026-02-05T22:05:59.146Z","thinkingLevel":"high"}
{"type":"message","id":"5a33dc96","parentId":"aeb3cce6","timestamp":"2026-02-05T22:05:59.170Z","message":{"role":"user","content":[{"type":"text","text":"<file name=\"/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/PROMPT.md\">\n# Build Instructions\n\n## Your Task\n\n1. Read `AGENTS.md` for build commands and code style rules\n2. Read `IMPLEMENTATION_PLAN.md` to understand current progress\n3. If `IMPLEMENTATION_PLAN.md` does not exist, create it (see Planning below) and stop\n4. Pick the next unchecked task from the plan\n5. Read the plan for the current milestone only (e.g., `.agents/plans/2026-02-05-m1-payload-library-name-fix.md`)\n6. Before making changes, search the codebase — don't assume something isn't implemented\n7. Implement that single task completely\n8. Run quality checks: `cargo build`, `cargo clippy --all-targets --all-features -- -D warnings`, `cargo test`\n9. If checks pass, mark the task complete in `IMPLEMENTATION_PLAN.md` and note any discoveries\n10. `git add -A && git commit` with a descriptive message\n\n## Planning\n\nWhen there are no unchecked tasks available (either the plan doesn't exist or the current milestone is complete), this is a planning iteration:\n\n1. If `IMPLEMENTATION_PLAN.md` doesn't exist, read `.agents/ROADMAP.md` and the charter at `.agents/charter/2026-02-05-template-validation-port-charter.md`, then create it with stub entries for all milestones\n2. Read the next milestone's plan from `.agents/plans/` (the first incomplete one)\n3. Expand that milestone's section in `IMPLEMENTATION_PLAN.md` with detailed tasks\n4. `git add -A && git commit`\n\nOnly read one milestone plan at a time — never load all of them upfront. Some milestones are split across multiple phase files (e.g., `m3.1-load-scoping.md`, `m3.2-load-scoping.md`). Read the overview file (e.g., `m3-load-scoping.md`) to understand the milestone structure, then read individual phase files only as you work on them.\n\nDo NOT implement anything during a planning iteration.\n\n## Quality Requirements\n\n- ALL commits must pass `cargo build`, `cargo clippy`, and `cargo test`\n- Do NOT commit broken code\n- Keep changes focused to the current task\n- Follow existing code patterns in the codebase\n\n## Project-Specific Rules\n\n- This is a Rust project using `tower-lsp-server` NOT `tower-lsp`. Imports are `tower_lsp_server::*`.\n- Use `insta` for snapshot tests in the template parser. Never create standalone test files.\n- Salsa must maintain exactly 2 inputs (`File` + `Project`). Do NOT add new `#[salsa::input]` types.\n- For extraction (M5), use `ruff_python_parser` NOT `rustpython-parser`. Pin to a specific git SHA.\n- The Python prototype in `template_linter/` is the behavioral reference for what the Rust code should do.\n\n## Update AGENTS.md\n\nIf you discover something operational that future iterations should know, add it to `AGENTS.md`. Good additions:\n\n- \"After editing `queries.py`, `cargo build` triggers pyz rebuild via `build.rs`\"\n- \"Return `&str` not `&String` from accessors — clippy flags this\"\n- \"`TemplateTags` does not implement `Deref` — use `.iter()`, `.tags()`, `.len()`\"\n\nDo NOT add progress notes or status updates — those belong in `IMPLEMENTATION_PLAN.md`. A bloated `AGENTS.md` pollutes every future iteration's context.\n\n## Stop Condition\n\nAfter completing your work — creating the plan, expanding a milestone, or implementing a task — commit and stop. Do not start the next piece of work.\n\n</file>\n"}],"timestamp":1770329159160}}
{"type":"message","id":"2ce38827","parentId":"5a33dc96","timestamp":"2026-02-05T22:06:03.615Z","message":{"role":"assistant","content":[{"type":"thinking","thinking":"Let me follow the build instructions. First, I need to read `AGENTS.md` and check if `IMPLEMENTATION_PLAN.md` exists.","thinkingSignature":"Ep4CCkYICxgCKkD/NKuZv7HHf7vqDR31bSrpMkzdjRx37FBdTpv+Z53tceVIplKBimLSsy8pkkI3xcqbxNUSRmUrPAzew8U/6f+JEgyVWAIBUe11WOKFBK4aDGN4DNNHkkFFeNpsKSIwPr1z2DhAs7ZuqK0WoAw6xNDm/+uZwEg0VLmhbq2r6nzkFwnzqU67XWgyQTRKoJ6UKoUBqbfh9613DOqGWTG1spqcB0LsmwToUQmYulz7Z5bRDP0q9EST8hdfBIcEtXvd2WnCpxMShPImWyFVE0XyQ4Z3eE4pK2GWtTJdj7JgLI3kd2h8JVndPrXEHkAOdg8cXZTPr+YqKi4v+yldI1JEkIUdOAwCqNgwa3XeT4EJakPbNJ1Kp6ol6hgB"},{"type":"toolCall","id":"toolu_014iCXfTPm1eChabDid3DMjo","name":"read","arguments":{"path":"/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/AGENTS.md"}},{"type":"toolCall","id":"toolu_01FVw2njsMVCpykg4gg31Kpk","name":"bash","arguments":{"command":"ls /home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/IMPLEMENTATION_PLAN.md 2>&1"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":9,"output":207,"cacheRead":0,"cacheWrite":6363,"totalTokens":6579,"cost":{"input":0.000045,"output":0.005175,"cacheRead":0,"cacheWrite":0.03976875,"total":0.04498875}},"stopReason":"toolUse","timestamp":1770329159165}}
{"type":"message","id":"d1dde34d","parentId":"2ce38827","timestamp":"2026-02-05T22:06:03.631Z","message":{"role":"toolResult","toolCallId":"toolu_014iCXfTPm1eChabDid3DMjo","toolName":"read","content":[{"type":"text","text":"# Agent Guidelines\n\n## Build/Test Commands\n```bash\ncargo build                      # Build all crates\ncargo clippy --all-targets --all-features --fix -- -D warnings  # Lint with fixes\ncargo +nightly fmt              # Format code (requires nightly)\ncargo test                      # Run all tests  \ncargo test test_name            # Run single test by name\ncargo test -p crate_name        # Test specific crate\njust test                       # Run tests via nox (with Django matrix)\njust lint                       # Run pre-commit hooks\n# NEVER use `cargo doc --open` - it requires browser interaction\n```\n\n## Code Style\n- **IMPORTANT LSP**: Use `tower-lsp-server` NOT `tower-lsp`. Imports are `tower_lsp_server::*` NOT `tower_lsp::*`\n- **LSP Types**: Use `tower_lsp_server::lsp_types` - we don't add `lsp-types` directly, it comes transitively from tower-lsp-server\n- **Imports**: One per line, grouped (std/external/crate), vertical layout per `.rustfmt.toml`\n- **Errors**: Use `anyhow::Result` for binaries, `thiserror` for libraries\n- **Naming**: snake_case functions/variables, CamelCase types, SCREAMING_SNAKE constants\n- **Comments**: Avoid unless essential; use doc comments `///` for public APIs only\n- **Testing**: Use `insta` for snapshot tests in template parser. NEVER write standalone test files - always add test cases to the existing test modules in the codebase\n- **Python**: Inspector runs via zipapp, test against Django 4.2/5.1/5.2/main\n\n## Project Structure\n- `crates/djls/` - Main CLI binary and PyO3 interface\n- `crates/djls-server/` - LSP server implementation  \n- `crates/djls-templates/` - Django template parser\n- `crates/djls-workspace/` - Workspace/document management\n\n## Task Management\nUse `/dex` to break down complex work, track progress across sessions, and coordinate multi-step implementations.\n"}],"isError":false,"timestamp":1770329163621}}
{"type":"message","id":"8ca7c70e","parentId":"d1dde34d","timestamp":"2026-02-05T22:06:03.637Z","message":{"role":"toolResult","toolCallId":"toolu_01FVw2njsMVCpykg4gg31Kpk","toolName":"bash","content":[{"type":"text","text":"ls: cannot access '/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/IMPLEMENTATION_PLAN.md': No such file or directory\n\n\nCommand exited with code 2"}],"details":{},"isError":true,"timestamp":1770329163636}}
{"type":"message","id":"75fa3082","parentId":"8ca7c70e","timestamp":"2026-02-05T22:06:07.340Z","message":{"role":"assistant","content":[{"type":"text","text":"No `IMPLEMENTATION_PLAN.md` exists. This is a planning iteration. Let me read the roadmap and charter."},{"type":"toolCall","id":"toolu_01R9QLBU1n159gRWPB8mMTME","name":"read","arguments":{"path":"/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/.agents/ROADMAP.md"}},{"type":"toolCall","id":"toolu_012P72t121bbiqs85G18NcCG","name":"read","arguments":{"path":"/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/.agents/charter/2026-02-05-template-validation-port-charter.md"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":1,"output":204,"cacheRead":6363,"cacheWrite":843,"totalTokens":7411,"cost":{"input":0.000005,"output":0.0051,"cacheRead":0.0031815,"cacheWrite":0.00526875,"total":0.013555250000000001}},"stopReason":"toolUse","timestamp":1770329163637}}
{"type":"message","id":"3f5ea5be","parentId":"75fa3082","timestamp":"2026-02-05T22:06:07.343Z","message":{"role":"toolResult","toolCallId":"toolu_01R9QLBU1n159gRWPB8mMTME","toolName":"read","content":[{"type":"text","text":"# Template Validation Port: Program Roadmap\n\n**Last updated:** 2026-02-05\n\nThis file is the single \"what are we doing next?\" index for porting the Python `template_linter/` prototype into Rust `django-language-server` (djls).\n\nIt is intentionally outcome-driven and document-linked. Implementation details live in per-milestone plans under `.agents/plans/`.\n\n---\n\n## North Star (End Result)\n\ndjls provides **runtime-aware, `{% load %}`-scoped template validation** where:\n\n- The **Python inspector** reports authoritative runtime inventory (what tags/filters exist, which `{% load %}` libraries exist, builtins ordering).\n- Rust (with Ruff AST) provides **rules/semantics enrichment** (how to validate usage), without runtime execution, and with **Salsa correctness** (no stale diagnostics).\n\nSource of truth for requirements:\n\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n\n---\n\n## Documents (What Exists Now)\n\n### Research (completed)\n\n- [`.agents/research/2026-02-04_template-introspection-pipeline.md`](research/2026-02-04_template-introspection-pipeline.md)\n- [`.agents/research/2026-02-04_tagspecs-flow-analysis.md`](research/2026-02-04_tagspecs-flow-analysis.md)\n- [`.agents/research/2026-02-04_template-filters-analysis.md`](research/2026-02-04_template-filters-analysis.md)\n- [`.agents/research/2026-02-04_load-tag-library-scoping.md`](research/2026-02-04_load-tag-library-scoping.md)\n- [`.agents/research/2026-02-04_semantic-validation-orchestration.md`](research/2026-02-04_semantic-validation-orchestration.md)\n- [`.agents/research/2026-02-04_salsa-settings-invalidation.md`](research/2026-02-04_salsa-settings-invalidation.md)\n- [`.agents/research/2026-02-04_python-ast-parsing-rust.md`](research/2026-02-04_python-ast-parsing-rust.md)\n- [`.agents/research/2026-02-04_template-linter-integration-seams.md`](research/2026-02-04_template-linter-integration-seams.md)\n\n### Program charter (requirements + milestones)\n\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n\n### RFCs (architecture decisions)\n\n- [`.agents/rfcs/2026-02-05-rfc-extraction-placement.md`](rfcs/2026-02-05-rfc-extraction-placement.md) (recommends `djls-extraction` crate; extraction keyed by `SymbolKey`. Note: its earlier \"new Salsa inputs\" discussion is superseded by the M2 direction to fold inspector/config into `Project` and avoid new global inputs.)\n\n### Implementation plans (per milestone)\n\n- [`.agents/plans/2026-02-05-m1-payload-library-name-fix.md`](plans/2026-02-05-m1-payload-library-name-fix.md) (M1 plan; ready to implement)\n- [`.agents/plans/2026-02-05-m2-salsa-invalidation-plumbing.md`](plans/2026-02-05-m2-salsa-invalidation-plumbing.md) (M2 plan; ready to implement)\n- [`.agents/plans/2026-02-05-m3-load-scoping.md`](plans/2026-02-05-m3-load-scoping.md) (M3 plan; ready to implement)\n- [`.agents/plans/2026-02-05-m4-filters-pipeline.md`](plans/2026-02-05-m4-filters-pipeline.md) (M4 plan; ready to implement)\n- [`.agents/plans/2026-02-05-m5-extraction-engine.md`](plans/2026-02-05-m5-extraction-engine.md) (M5 plan; ready to implement)\n- [`.agents/plans/2026-02-05-m6-rule-evaluation.md`](plans/2026-02-05-m6-rule-evaluation.md) (M6 plan; ready to implement)\n\n**Next action:** start implementation at **M1**, then proceed in order (M2 → M3 → M4 → M5 → M6), running tests after each major change.\n\n---\n\n## Program Milestones (Vertical Slices)\n\nMilestones below are copied/condensed from the charter, with explicit dependencies.\n\nStatuses: **backlog** -> **planning** -> **ready** -> **in progress** -> **done**\n\n### M1 - Payload shape + `{% load %}` library name correctness\n\n**Status:** ready\n\n**Why:** fixes a correctness bug and establishes the canonical inventory payload shape.\n\n**Plan:** [`.agents/plans/2026-02-05-m1-payload-library-name-fix.md`](plans/2026-02-05-m1-payload-library-name-fix.md)\n\n**Deliverables:**\n\n- Inspector payload preserves:\n    - `libraries: {load_name -> module_path}` (keys preserved)\n    - `builtins: [module_path, ...]` (ordered)\n    - `templatetags[]` items with provenance + `defining_module`\n- Rust `TemplateTags` model includes top-level `libraries`/`builtins`.\n- `{% load %}` completions show load-names (e.g. `i18n`, `static`), not module paths.\n\n### M2 - Salsa invalidation plumbing (no stale inventory/spec/rules)\n\n**Status:** ready\n\n**Depends on:** M1 payload shape (so inventory can become an input)\n\n**Why:** prevents building M3/M4/M5 on invisible/stale dependencies.\n\n**Plan:** [`.agents/plans/2026-02-05-m2-salsa-invalidation-plumbing.md`](plans/2026-02-05-m2-salsa-invalidation-plumbing.md)\n\n**Deliverables (conceptual):**\n\n- **Hard constraint:** do **not** \"explode\" Salsa inputs. Prefer the Ruff/Rust-Analyzer pattern: a _small_ number of semantically-meaningful, _large_ inputs updated via setters.\n- **Target:** keep djls at **two** primary inputs (`File`, `Project`) by extending `Project` to hold:\n    - semantic config needed for validation (`tagspecs`, `diagnostics`, strictness knobs)\n    - the authoritative inspector snapshot (tags/filters inventory + `libraries`/`builtins` + health)\n- Replace untracked `Arc<Mutex<Settings>>` reads inside semantic code with **Salsa-visible** reads from the `Project` input (no invisible dependencies).\n- Provide an explicit refresh path (`db.refresh_inspector()` or equivalent) that:\n    1. queries Python (side effect), 2) updates `Project` input fields (setters), 3) relies on Salsa invalidation for downstream recomputation.\n- **Future (M5+):** prefer extracted rules as _derived tracked queries_ over Python module `File` sources (so edits invalidate naturally) rather than introducing another global \"rev counter\" input.\n\n#### Plan prompt\n\n```text\n/implementation_plan\n\nTask: M2 \"Salsa invalidation plumbing\" - eliminate stale template diagnostics by making external data\nsources explicit Salsa inputs with an explicit refresh/update path.\n\nRead fully (source of truth):\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n- [`.agents/rfcs/2026-02-05-rfc-extraction-placement.md`](rfcs/2026-02-05-rfc-extraction-placement.md) (extraction placement; Salsa integration notes\n  may need updating to match the \"minimal inputs\" constraint)\n- [`.agents/research/2026-02-04_salsa-settings-invalidation.md`](research/2026-02-04_salsa-settings-invalidation.md)\n- [`.agents/research/2026-02-04_semantic-validation-orchestration.md`](research/2026-02-04_semantic-validation-orchestration.md)\n- [`.agents/plans/2026-02-05-m1-payload-library-name-fix.md`](plans/2026-02-05-m1-payload-library-name-fix.md) (payload shape assumptions)\n\nPlan must decide and specify:\n- **Hard constraint:** keep Salsa inputs minimal - prefer **extending the existing `Project` input**\n  (Ruff-style \"big input\") rather than adding new global `#[salsa::input]` types.\n- Explicitly remove the untracked `Arc<Mutex<Settings>>` → semantic pipeline dependency by making\n  semantic-relevant config **Salsa-visible** (via `Project` fields).\n- Treat inspector results the same way: *Python produces facts*, djls **stores those facts** in\n  `Project` input fields via setters (no `#[salsa::tracked]` wrapper around `inspector::query`).\n- The refresh/update mechanism and API surface (e.g. `db.refresh_inspector()`), explicitly stating\n  \"Salsa invalidates; refresh path performs side effects\".\n- Which tracked queries depend on which inputs (dependency graph).\n- Tests that prove invalidation works (config change, refresh change) and how to run them.\n  Prefer the rust-analyzer test idiom: use salsa events + `ingredient_debug_name` rather than brittle\n  substring matching of `Debug` strings.\n\nOutput file:\n- [`.agents/plans/2026-02-05-m2-salsa-invalidation-plumbing.md`](plans/2026-02-05-m2-salsa-invalidation-plumbing.md)\n```\n\n### M3 - `{% load %}` scoping infrastructure (diagnostics + completions)\n\n**Status:** ready\n\n**Depends on:** M1, M2\n\n**Plan:** [`.agents/plans/2026-02-05-m3-load-scoping.md`](plans/2026-02-05-m3-load-scoping.md)\n\n**Deliverables:**\n\n- Position-aware tag/filter availability at cursor position:\n    - builtins always available\n    - libraries available only after `{% load %}`\n    - `{% load X from Y %}` selective imports supported\n- Diagnostics + completions are scoped when inspector is healthy; conservative fallback when not:\n    - validation: emit no S108/S109/S110 if inspector unavailable\n    - completions: skip availability filtering if inspector unavailable (show all known tags)\n    - library completions: empty if inspector unavailable (no libraries known)\n- Selective-vs-full load semantics are explicit (full load overrides/clears selective imports).\n- Span/position semantics are explicit: byte offsets matching `djls_source::Span`, and availability boundary is `load_stmt.span.end() <= position`.\n- TagSpecs interaction is explicit: skip structural tags (openers/closers/intermediates) because those are validated by block/argument validation, not load scoping.\n\n### Plan prompt\n\n```text\n/implementation_plan\n\nTask: M3 \"Load scoping infrastructure\" - position-aware `{% load %}` scoping for tags and filters in\ndiagnostics + completions (builtins always available; `{% load %}` libraries only after load; support\n`{% load X from Y %}` selective imports).\n\nRead fully:\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n- [`.agents/research/2026-02-04_load-tag-library-scoping.md`](research/2026-02-04_load-tag-library-scoping.md)\n- [`.agents/research/2026-02-04_template-introspection-pipeline.md`](research/2026-02-04_template-introspection-pipeline.md)\n- [`.agents/research/2026-02-04_semantic-validation-orchestration.md`](research/2026-02-04_semantic-validation-orchestration.md)\n- [`.agents/plans/2026-02-05-m1-payload-library-name-fix.md`](plans/2026-02-05-m1-payload-library-name-fix.md)\n- [`.agents/plans/2026-02-05-m2-salsa-invalidation-plumbing.md`](plans/2026-02-05-m2-salsa-invalidation-plumbing.md)\n\nPlan must include:\n- Data model for \"available symbols at position\" (builtins + loaded libs).\n- Where it is computed (semantic vs IDE) and how it is cached/invalidation-safe (ties into M2).\n- Exact behavior for unknown/collisions per charter (inspector healthy vs unavailable).\n- Tests: scoping boundaries (before/after load), selective imports, completions filtering.\n\nOutput file:\n- [`.agents/plans/2026-02-05-m3-load-scoping.md`](plans/2026-02-05-m3-load-scoping.md)\n```\n\n### M4 - Filters pipeline (inventory-driven; scoped; parsing breakpoint)\n\n**Status:** ready\n\n**Depends on:** M1, M2, M3\n\n**Plan:** [`.agents/plans/2026-02-05-m4-filters-pipeline.md`](plans/2026-02-05-m4-filters-pipeline.md)\n\n**Deliverables:**\n\n- Inspector provides authoritative filter inventory (grouped by provenance).\n- `djls-templates` parses filters into structured representation with spans.\n- Filter completions in `{{ x|... }}` respect scoping (builtins + loaded libs).\n- Unknown filter diagnostics (post-M3 semantics).\n- **Planned type evolution (breaking change in M4):** switch the `Project` field carrying inspector data from a tags-only shape (`TemplateTags`) to a unified inventory shape (`InspectorInventory`) that includes both tags and filters. This is implemented _as part of M4_; M1-M3 are implemented against the tags-only shape.\n\n### Plan prompt\n\n```text\n/implementation_plan\n\nTask: M4 \"Filters pipeline\" - filter inventory-driven completions + unknown-filter diagnostics, with\nload scoping correctness, and a structured filter representation in `djls-templates`.\n\nRead fully:\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n- [`.agents/research/2026-02-04_template-filters-analysis.md`](research/2026-02-04_template-filters-analysis.md)\n- [`.agents/research/2026-02-04_load-tag-library-scoping.md`](research/2026-02-04_load-tag-library-scoping.md)\n- [`.agents/plans/2026-02-05-m1-payload-library-name-fix.md`](plans/2026-02-05-m1-payload-library-name-fix.md)\n- [`.agents/plans/2026-02-05-m3-load-scoping.md`](plans/2026-02-05-m3-load-scoping.md)\n\nPlan must include:\n- The explicit \"breakpoint\" for changing filter representation (`Vec<String>` → structured w/ spans),\n  including which crates/files are touched and how tests will be updated.\n- How inspector filter inventory will be represented (provenance consistent with M1).\n- How scoping applies to filters (reuse M3 infrastructure).\n- Tests: parsing edge cases, completions in `{{ x| }}`, unknown filter diagnostics, scoping checks.\n\nOutput file:\n- [`.agents/plans/2026-02-05-m4-filters-pipeline.md`](plans/2026-02-05-m4-filters-pipeline.md)\n```\n\n### M5 - Rust extraction engine (`djls-extraction`) for rule enrichment\n\n**Status:** ready\n\n**Depends on:** M1, M2 (and ideally M3)\n\n**Plan:** [`.agents/plans/2026-02-05-m5-extraction-engine.md`](plans/2026-02-05-m5-extraction-engine.md)\n\n**Deliverables:**\n\n- New crate `djls-extraction` using `ruff_python_parser` (SHA-pinned).\n- Extraction keyed by `SymbolKey { registration_module, name, kind }` to avoid collisions.\n- Extraction output cached via Salsa (prefer **derived tracked queries over Python module `File`** sources; avoid introducing a new global `ExtractedRules` input unless it's the only practical way).\n- Corpus/full-source extraction tests (Rust-native corpus tooling), with a **temporary** Python parity oracle during the port that is explicitly deleted after M6 parity is achieved.\n\n### Plan prompt\n\n```text\n/implementation_plan\n\nTask: M5 \"Extraction engine (rules enrichment)\" - implement `djls-extraction` using Ruff AST to mine\nvalidation semantics from Python registration modules, keyed by SymbolKey to avoid collisions, and\ncache results via Salsa (prefer derived tracked queries over Python module `File` sources; avoid new\nglobal inputs unless strictly necessary).\n\nRead fully:\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n- [`.agents/rfcs/2026-02-05-rfc-extraction-placement.md`](rfcs/2026-02-05-rfc-extraction-placement.md)\n- [`.agents/research/2026-02-04_python-ast-parsing-rust.md`](research/2026-02-04_python-ast-parsing-rust.md)\n- [`.agents/research/2026-02-04_tagspecs-flow-analysis.md`](research/2026-02-04_tagspecs-flow-analysis.md)\n\nPlan must decide/specify:\n- Initial Ruff SHA pinning strategy and update process.\n- Exact crate boundary (`djls-extraction`) public API (pure: `source -> rules`).\n- Where module->path resolution + file IO live (outside `djls-extraction`).\n- How extraction is triggered/refreshed (eager vs lazy; ties into M2 refresh path).\n- Tests: golden extraction fixtures + integration wiring into semantic layer.\n\nOutput file:\n- [`.agents/plans/2026-02-05-m5-extraction-engine.md`](plans/2026-02-05-m5-extraction-engine.md)\n```\n\n### M6 - Rule evaluation + expression validation\n\n**Status:** ready\n\n**Depends on:** M3-M5\n\n**Deliverables:**\n\n- Apply extracted rules to templates (TemplateSyntaxError-derived constraints).\n- Block structure derived from extraction (end tags, intermediates, opaque blocks).\n- `{% if %}` / `{% elif %}` expression syntax validation.\n\n**Plan:** [`.agents/plans/2026-02-05-m6-rule-evaluation.md`](plans/2026-02-05-m6-rule-evaluation.md)\n\n### Plan prompt\n\n```text\n/implementation_plan\n\nTask: M6 \"Rule evaluation + expression validation\" - apply extracted rules to templates (argument\nconstraints, block structure, opaque blocks) and add `{% if %}` / `{% elif %}` expression syntax\nvalidation (operator/operand).\n\nRead fully:\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n- [`.agents/research/2026-02-04_tagspecs-flow-analysis.md`](research/2026-02-04_tagspecs-flow-analysis.md)\n- [`.agents/research/2026-02-04_semantic-validation-orchestration.md`](research/2026-02-04_semantic-validation-orchestration.md)\n- [`.agents/plans/2026-02-05-m3-load-scoping.md`](plans/2026-02-05-m3-load-scoping.md)\n- [`.agents/plans/2026-02-05-m5-extraction-engine.md`](plans/2026-02-05-m5-extraction-engine.md)\n- `template_linter/PORTING.md` (behavioral reference for rule categories)\n\nPlan must include:\n- How extracted rules map onto existing semantic validation stages (arguments, blocks, diagnostics).\n- Where expression validation lives and how it reports errors (tests first).\n- Test strategy: fixtures + snapshots; avoid false positives on Django core templates.\n\nOutput file:\n- [`.agents/plans/2026-02-05-m6-rule-evaluation.md`](plans/2026-02-05-m6-rule-evaluation.md)\n```\n\n### M7 - Documentation + issue reporting (post-port hardening)\n\n**Status:** ready\n\n**Depends on:** M1-M6\n\n**Why:** template validation is ultimately heuristic/static compared to Python runtime behavior; we need clear docs + a high-signal repro path for gaps we discover in the wild.\n\n**Deliverables:**\n\n- Documentation update that explains:\n    - the new runtime-inventory + load-scoping model (what's validated, when it's conservative)\n    - known limitations of AST-derived rule mining (what we can/can't infer)\n    - how to configure severities for \"unknown/unloaded\" diagnostics during adoption\n- GitHub issue template for \"Template validation mismatch\" with a strict repro checklist:\n    - environment/version info\n    - minimal template snippet\n    - relevant `{% load %}` statements + library names\n    - `djls.toml` (tagspecs/diagnostics) excerpt\n    - inspector snapshot / debug logs collection instructions\n- Link the issue template from docs (and `CONTRIBUTING.md` if appropriate).\n\n### Plan prompt\n\n```text\n/implementation_plan\n\nTask: M7 \"Docs + issue reporting\" — after the port is complete, update documentation to reflect the\nnew template validation behavior and add a high-signal issue template for reporting mismatches\nbetween djls static validation and Django runtime behavior.\n\nRead fully:\n- [`.agents/charter/2026-02-05-template-validation-port-charter.md`](charter/2026-02-05-template-validation-port-charter.md)\n- [`.agents/rfcs/2026-02-05-rfc-extraction-placement.md`](rfcs/2026-02-05-rfc-extraction-placement.md)\n- [`.agents/plans/2026-02-05-m3-load-scoping.md`](plans/2026-02-05-m3-load-scoping.md)\n- [`.agents/plans/2026-02-05-m4-filters-pipeline.md`](plans/2026-02-05-m4-filters-pipeline.md)\n- [`.agents/plans/2026-02-05-m5-extraction-engine.md`](plans/2026-02-05-m5-extraction-engine.md)\n- [`.agents/plans/2026-02-05-m6-rule-evaluation.md`](plans/2026-02-05-m6-rule-evaluation.md)\n\nAlso inspect current docs + repo meta:\n- `README.md`\n- `docs/configuration/index.md` (diagnostic codes + severity config)\n- `docs/configuration/tagspecs.md` (existing \"open an issue\" link)\n- `.mkdocs.yml` (nav placement)\n- `.github/` (existing templates; add if missing)\n\nPlan must include:\n- Where the documentation updates live (which existing pages to update vs adding a new page).\n- Explicit language about static-analysis limits (what's authoritative from inspector vs inferred from\n  AST mining), and what users should expect when custom tags do validation dynamically.\n- A GitHub issue form (YAML) for template-validation mismatches with a concrete repro checklist and\n  copy/paste commands for collecting debug output (versions, config, inspector snapshot).\n- Minimal tests/verification for the docs/template changes (lint/build docs if applicable).\n\nOutput file:\n- `.agents/plans/YYYY-MM-DD-m7-docs-and-issue-template.md`\n```\n\n---\n\n## Documents To Generate (Remaining)\n\nThese are the next \"paperwork\" outputs to keep the program coordinated:\n\n1. `.agents/plans/YYYY-MM-DD-m7-docs-and-issue-template.md`\n\nOptional (only if we feel lost again):\n\n- `.agents/rfcs/YYYY-MM-DD-rfc-milestone-decomposition.md` (turns milestones into a dependency graph with exact \"touch points\" per crate)\n\n---\n\n## Execution Workflow (How We Implement Without Chaos)\n\n- Implement one milestone per PR (or a tightly-coupled pair if unavoidable).\n- Every milestone must have:\n    - automated tests for any new code paths\n    - a deterministic story for ordering (completions, maps) to avoid flakiness\n    - clear \"inspector healthy vs unavailable\" behavior when it affects diagnostics\n- Run tests after major changes:\n    - crate-local while iterating (e.g. `cargo test -p djls-project`, `cargo test -p djls-ide`)\n    - broader `cargo test` before landing\n\n---\n\n## Open Decisions / Inputs Needed (Tracked)\n\nFrom [`.agents/rfcs/2026-02-05-rfc-extraction-placement.md`](rfcs/2026-02-05-rfc-extraction-placement.md):\n\n- Which Ruff SHA to pin initially.\n- Refresh triggers: user command vs timer vs watchers (what calls `db.refresh_inspector()`).\n- Eager vs lazy extraction: extract everything at refresh vs on-demand per module, with caching.\n- Durability levels for the \"big inputs\" (config/extracted rules likely HIGH; inventory likely MEDIUM/LOW).\n"}],"isError":false,"timestamp":1770329167342}}
{"type":"message","id":"fa549e59","parentId":"3f5ea5be","timestamp":"2026-02-05T22:06:07.345Z","message":{"role":"toolResult","toolCallId":"toolu_012P72t121bbiqs85G18NcCG","toolName":"read","content":[{"type":"text","text":"# Template Validation Port Charter\n\n**Date:** 2026-02-05 **Status:** Draft **Scope:** Porting `template_linter/` capabilities to Rust (`django-language-server`)\n\n---\n\n## 1. Desired End State\n\nWhen \"done,\" djls provides **runtime-aware, load-scoped template validation** derived from actual Python source—not hand-authored specs.\n\n### 1.1 Runtime-Aware Tag/Filter Inventory\n\n- **Tags and filters discovered from Django/third-party source**, not hardcoded in `builtins.rs`\n- **Correct identifiers**: library load-name (e.g., `i18n`) vs module path (e.g., `django.templatetags.i18n`)\n- **Filter inventory exists**: djls validates filter usage and argument counts (currently missing entirely)\n\n**Separation of concerns:**\n\n| Component               | Responsibility                                                                                                                                                                                      |\n| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Python inspector**    | **Inventory** - authoritative runtime truth: which tags/filters exist, which library they belong to, builtins vs `{% load %}` required. Django is the authority on what's registered.               |\n| **Rust AST extraction** | **Rules/validation** - enriches inventory with validation semantics: TemplateSyntaxError constraints, block structure, expression grammar, filter arity (as best-effort enrichment, not inventory). |\n\n**Inspector payload preserves Django's registry structure:**\n\n- `engine.libraries` mapping (`{load_name: module_path}`) with keys preserved\n- Ordered builtin module paths (from `engine.template_builtins` / configured `OPTIONS[\"builtins\"]`)\n- Tag/filter inventory grouped by library load-name (for `{% load %}` libraries) and by builtin module (for builtins)\n- Environment/path info to resolve module paths to source files\n- Django's \"later wins\" collision semantics are derivable from this data\n\n**Inventory item data model:** Each tag/filter in the inventory must carry:\n\n- `name` — the tag/filter name as used in templates\n- `provenance` — **exactly one of**:\n    - `Library { load_name, module }` — requires `{% load X %}`, e.g., `Library { load_name: \"i18n\", module: \"django.templatetags.i18n\" }`\n    - `Builtin { module }` — always available, e.g., `Builtin { module: \"django.template.defaulttags\" }`\n- `defining_module` — the module where the function is defined (`tag_func.__module__`); needed for docs/jump-to-def\n\nThe `provenance` field is mutually exclusive (either library or builtin, never both). For both variants, the `module` field indicates where registration happens (needed for rule extraction). This prevents reintroducing the \"module path == library name\" bug and makes downstream Rust types simpler (enum).\n\n**Clarification on Django's \"builtins\" concepts:**\n\n| Django Concept                          | Type             | What It Is                       |\n| --------------------------------------- | ---------------- | -------------------------------- |\n| `engine.libraries`                      | `dict[str, str]` | Load-name → module path mapping  |\n| `engine.template_builtins`              | `list[Library]`  | Runtime Library objects, ordered |\n| `TEMPLATES[...][\"OPTIONS\"][\"builtins\"]` | `list[str]`      | Configured builtin module paths  |\n\nWhat we need to transport: **ordered builtin module paths** (ordering = semantics for \"later wins\") plus the **libraries mapping with keys intact**.\n\n### 1.2 `{% load %}` Scoping Correctness\n\n- **Diagnostics respect load scope**: A tag/filter from library `foo` produces an error if `{% load foo %}` hasn't preceded it\n- **Completions respect load scope**: Tag/filter completions only show symbols available at cursor position (builtins + loaded libraries)\n- **`{% load X from Y %}` handled**: Selective imports correctly scope only the named symbols\n- **Builtin vs library distinction preserved**: Tags from ordered builtins (from `template_builtins` + configured builtins) available without `{% load %}`\n\n**Unknown tag/filter behavior:**\n\n- **Pre-M3 (current)**: Unknown tags pass silently; no scoping validation\n- **Post-M3 (inspector healthy)**: Unknown tags/filters produce diagnostics **by default** (not behind a flag)\n- **Inspector unavailable/Django init fails**: Downgrade unknown diagnostics to warning/info severity or suppress entirely to avoid noisy false positives\n- **Truly unknown**: A tag/filter not in the inspector inventory at all is an error: \"Unknown tag `{% xyz %}`\" / \"Unknown filter `|xyz`\"\n\n**Collision handling:**\n\n- **With inspector**: No ambiguity at runtime—Django resolves `{% load foo %}` to a single module via `engine.libraries[foo]`. If Django detected a collision (W003-style warning), djls may surface that as a warning, but still treats the resolved `engine.libraries[foo]` mapping as authoritative for validation/completions.\n- **Without inspector (corpus/filesystem-scan mode)**: When multiple libraries define the same name and no registry ordering is available, djls emits a warning (\"Cannot resolve `foo`: defined in multiple libraries\") and skips validation for that symbol rather than guessing.\n\n### 1.3 Semantic Validation from Python Source\n\n- **Tag validation rules extracted from AST**, not hand-authored:\n    - Argument count/position constraints from `do_xxx()` functions\n    - Keyword requirements (e.g., `bits[2] != \"as\"`)\n    - Option validation (known options, duplicates, required args)\n    - `parse_bits` signatures for `simple_tag`/`inclusion_tag`\n- **Block structure extracted from AST**:\n    - End tags and intermediate tags from `parser.parse((...))`\n    - Dynamic patterns like `f\"end{tag_name}\"` handled\n    - Opaque blocks (verbatim/comment-like) honored\n- **Filter specs extracted from AST**: Argument counts from `@register.filter` signatures\n- **Expression validation for `{% if %}`/`{% elif %}`**: Operator/operand syntax checking\n\n### 1.4 Salsa/Caching Correctness\n\n- **No stale diagnostics**: When extracted rules, runtime registry, or config changes, validation results invalidate\n- **TagSpecs as Salsa input**: Changes to specs trigger recomputation of dependent queries\n- **Registry changes propagate**: Inspector refresh (e.g., new Django version, new libraries installed) invalidates affected caches\n\n---\n\n## 2. Explicit Non-Goals\n\n| Non-Goal                                    | Rationale                                                             |\n| ------------------------------------------- | --------------------------------------------------------------------- |\n| **Runtime template execution**              | Static analysis only; never render templates                          |\n| **Import/execute tag/filter code**          | All extraction from AST; no Python evaluation of tag logic            |\n| **Variable type checking**                  | Requires runtime context (request, db, template context)              |\n| **Render-time error detection**             | Type coercion, format strings, missing partials—all runtime           |\n| **Template inheritance resolution**         | `{% extends %}` / `{% include %}` resolution is future work           |\n| **Full Python semantic analysis**           | Extract what's statically provable; don't build a Python type checker |\n| **Cross-template state**                    | `cycle` names, `partialdef` tracking deferred to later phase          |\n| **Parity with Python prototype test suite** | Rust tests should verify behavior; don't port Python test code        |\n\n---\n\n## 3. Milestones (Vertical Slices)\n\nEach milestone delivers user-visible value and can be shipped independently.\n\n**Ordering rationale:** Salsa invalidation (M2) comes early because load scoping (M3) and filters (M4) depend on inspector data and evolving rule sources. Building on top of broken caching amplifies bugs. Filters (M4) come after scoping because they reuse the same infrastructure. Extraction (M5+) comes last because it's the largest lift and benefits from stable foundations.\n\n### M1: Payload Shape + Library Name Fix\n\n**User-visible outcome:**\n\n- `{% load %}` completions show correct library names (`i18n`, `static`) instead of module paths\n- Inspector returns builtins vs libraries distinction\n- Tag inventory comes from Django (authoritative runtime truth)\n\n**Main system boundary touched:**\n\n- Inspector payload: expand `templatetags` to preserve library-name keys + ordered builtins (don't drop keys when iterating `engine.libraries`)\n- Inspector reports tag inventory per library (Django is authoritative on what's registered)\n- Rust types: ensure `TemplateTag` carries library load-name\n- Completions: use library name, not module path\n\n**How we verify:**\n\n- Unit test: Library name available as distinct field, not derived from module path\n- Integration test: LSP completion request for `{% load |` returns library names\n- Manual test: Completions in editor show correct identifiers\n\n---\n\n### M2: Salsa Invalidation Plumbing\n\n**User-visible outcome:**\n\n- Changing config triggers revalidation without reopening files\n- Inspector refresh (e.g., after `pip install`) updates diagnostics\n- Future: extracted rule changes propagate correctly\n\n**Main system boundary touched:**\n\n- `crates/djls-server/src/db.rs` — fix untracked dependencies on `tag_specs()`/`tag_index()`\n- Options: explicit Salsa input for specs, OR bump file revisions on config change (coarser but simpler)\n- Goal: establish the invalidation contract before building features that depend on it\n\n**Invalidation must cover all rule/registry sources:**\n\n1. Settings/config (djls.toml, pyproject.toml)\n2. Inspector registry payload (libraries mapping, ordered builtins)\n3. Extracted bundle/ruleset (once extraction exists)\n\n**How we verify:**\n\n- Test: Change config → file's cached validation invalidated\n- Test: Simulate inspector refresh → diagnostics recompute\n- Test: (Future) Extracted rules change → validation recomputes\n- No regression: Performance benchmark shows acceptable overhead\n\n**Why this comes early:** Load scoping, filters, and extraction will add new data sources. If invalidation is broken, those features build on a lie.\n\n---\n\n### M3: Load Scoping Infrastructure\n\n**User-visible outcome:**\n\n- Diagnostic: \"Tag `{% trans %}` requires `{% load i18n %}`\"\n- Completions for tags respect which libraries are loaded at cursor position\n- Builtins available without `{% load %}`\n\n**Main system boundary touched:**\n\n- New module: `crates/djls-semantic/src/load_resolution.rs`\n- Per-template library tracking in semantic analysis\n- Position-aware tag availability in completions\n\n**How we verify:**\n\n- Unit test: Tag before `{% load %}` → diagnostic; after → no diagnostic\n- Unit test: `{% load trans from i18n %}` scopes only `trans`, not all i18n tags\n- Integration test: Completions at position before load differ from after load\n\n---\n\n### M4: Filters Pipeline\n\n**User-visible outcome:**\n\n- Filter completions appear in `{{ var|` context\n- Basic filter validation (unknown filter = diagnostic)\n- Filter scoping respects `{% load %}`\n\n**Main system boundary touched:**\n\n- Inspector payload: add filter inventory (name, library, module) — Django is authoritative on what's registered\n- `crates/djls-templates/src/parser.rs` — parse filters into structured representation (name, arg, span)\n- `crates/djls-semantic/` — filter scoping plumbed through load resolution\n\n**Note on filter inventory vs filter signatures:** The inspector reports the authoritative runtime inventory of filters (per library load-name + builtins), as Django has registered them. Rust then optionally enriches those items by statically extracting signatures/arity from source via Ruff AST (in M5); when enrichment is ambiguous, djls stays conservative (skip arg-validation rather than guess).\n\n**Core breakpoint:** Parser/nodelist filter representation change touches many layers. Plan as explicit breakpoint with compatibility strategy (update all callers in one PR, or add adapter layer).\n\n**How we verify:**\n\n- Unit test: Filter parsing produces structured representation with spans\n- Completion test: `{{ x|` context detection works\n- Scoping test: Filter from unloaded library → diagnostic\n- Integration test: Inspector returns filter inventory per library\n\n**Why this comes after M2/M3:** Parser churn amplifies caching bugs; invalidation should be solid first. Filters reuse load scoping infrastructure from M3.\n\n---\n\n### M5: Extraction Engine (Rules/Validation Enrichment)\n\n**User-visible outcome:**\n\n- Tag validation rules populated from Django source, not `builtins.rs`\n- Third-party library tags validated with extracted rules\n- Filter arity/signatures extracted as enrichment\n\n**Main system boundary touched:**\n\n- New crate: `djls-extraction` (depends on `ruff_python_parser`)\n- Extraction outputs: `TagValidation`, `ParseBitsSpec`, `BlockTagSpec`, filter signatures\n- Enriches inspector inventory with validation semantics\n- Replaces hardcoded `builtins.rs` validation logic\n\n**Note:** This is about **rules/validation**, not inventory. The inspector (M1/M4) provides the authoritative inventory of what tags/filters exist. This milestone extracts _how to validate them_ by mining TemplateSyntaxError paths, parse_bits signatures, block structure, etc.\n\n**How we verify:**\n\n- Golden test: Extract Django 5.2 tag rules → compare to baseline JSON\n- Parity test: Extracted rules match template_linter's extraction\n- Unit tests: Specific patterns (registration styles, block specs, opaque blocks)\n- Integration: Rules applied to tags from inspector inventory\n\n---\n\n### M6: Rule Evaluation + Expression Validation\n\n**User-visible outcome:**\n\n- Rich argument validation: \"Missing required argument `as`\", \"Unknown option `foo`\"\n- Block structure validation: \"Unclosed `{% if %}`\", \"Unexpected `{% else %}` outside block\"\n- Filter argument validation: \"Filter `date` expects 0-1 arguments, got 2\"\n- Expression validation: `{% if and x %}` → \"Expected operand, found operator 'and'\"\n\n**Main system boundary touched:**\n\n- `crates/djls-semantic/src/arguments.rs` — handle extracted `ContextualRule` preconditions\n- `crates/djls-semantic/src/blocks/builder.rs` — use extracted `BlockTagSpec`\n- Expression parsing for `{% if %}`/`{% elif %}` (folds into rule evaluation)\n\n**How we verify:**\n\n- Snapshot tests: Various error cases produce expected diagnostics\n- Corpus test: Run against Django admin templates with strict unknowns\n- Regression: No new false positives vs template_linter on same corpus\n- Expression tests: Each operator, valid/invalid expressions\n\n---\n\n## 4. Decision Inventory\n\nThese decisions must be made before or during implementation. Each has trade-offs.\n\n### D1: Extraction Data Format\n\n| Option                                          | Pros                                                              | Cons                                            |\n| ----------------------------------------------- | ----------------------------------------------------------------- | ----------------------------------------------- |\n| **Runtime JSON** (load at startup)              | Hot-reload rules without rebuild; third-party rules as data files | Startup cost; schema versioning                 |\n| **Code generation** (build-time)                | Zero runtime cost; type-safe; IDE support                         | Rebuild for new rules; harder third-party story |\n| **Hybrid** (codegen builtins, JSON third-party) | Fast for common case; flexible for extensions                     | Two code paths                                  |\n\n**Recommendation:** Start with **Runtime JSON**. Enables rapid iteration during port, supports third-party libraries naturally, and can be optimized later if startup cost matters.\n\n### D2: Rust Python Parser\n\n| Option                 | Pros                                                     | Cons                                       |\n| ---------------------- | -------------------------------------------------------- | ------------------------------------------ |\n| **ruff_python_parser** | Actively maintained; fast; Python 3.13+; used by Ruff/ty | Git dependency; no stability guarantees    |\n| **rustpython-parser**  | On crates.io; stable API                                 | Stale (18mo); may lack Python 3.12+ syntax |\n| **tree-sitter-python** | Incremental; error-tolerant                              | CST not AST; wrong abstraction             |\n\n**Recommendation:** Use **ruff_python_parser** via git with SHA pinning. It's the only actively maintained Python AST parser in Rust and powers all Astral tooling. Pin to a known-good SHA and update deliberately.\n\n### D3: Salsa Invalidation Model\n\n| Option                                   | Pros                          | Cons                                            |\n| ---------------------------------------- | ----------------------------- | ----------------------------------------------- |\n| **TagSpecs as Salsa input**              | Precise invalidation; correct | Adds parameter to many functions; complexity    |\n| **Bump file revisions on config change** | Simple; minimal code changes  | Over-invalidates (all files, not just affected) |\n| **Hash specs into file identity**        | Automatic invalidation        | Hacky; conflates file identity with config      |\n\n**Recommendation:** Start with **bump file revisions** for simplicity. If profiling shows it's too expensive, migrate to explicit Salsa input.\n\n### D4: Filter Scoping Semantics\n\n| Option                                            | Pros                              | Cons                                                   |\n| ------------------------------------------------- | --------------------------------- | ------------------------------------------------------ |\n| **\"Final filter set\"** (template_linter behavior) | Simple; matches current prototype | Position before `{% load %}` incorrectly allows filter |\n| **Position-aware** (correct semantics)            | Accurate load scoping             | Requires filter tokens to carry positions              |\n\n**Recommendation:** Implement **position-aware** from the start. The Rust tokenizer already has spans; don't regress from correct semantics.\n\n### D5: Collision Resolution Without Registry\n\n| Option                           | Pros                    | Cons                          |\n| -------------------------------- | ----------------------- | ----------------------------- |\n| **Conservative: omit ambiguous** | No false positives      | May miss real errors          |\n| **Best-effort: pick first**      | More coverage           | May produce wrong diagnostics |\n| **Warn about ambiguity**         | User learns about issue | Noisy if many collisions      |\n\n**Recommendation:** **Conservative (omit ambiguous)** for validation; **warn about ambiguity** for completions. User can provide runtime registry for accuracy.\n\n### D6: Hardcodes/Overrides Location\n\n| Option                                      | Pros                      | Cons                     |\n| ------------------------------------------- | ------------------------- | ------------------------ |\n| **Single Rust module** (`overrides.rs`)     | Centralized; auditable    | Rust rebuild for changes |\n| **Config file** (TOML/JSON)                 | User-editable; hot-reload | Schema complexity        |\n| **Both** (Rust defaults + config overrides) | Flexibility               | Two sources of truth     |\n\n**Recommendation:** **Single Rust module** initially, with config override capability as future enhancement.\n\n---\n\n## 5. Architecture Options\n\n**Decided direction:**\n\n| Concern                                | Owner                       | Why                                                                                                                            |\n| -------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| **Inventory** (what exists)            | Python inspector            | Django is authoritative on what tags/filters are registered, which libraries exist, app ordering effects, dynamic registration |\n| **Rules/validation** (how to validate) | Rust + `ruff_python_parser` | Fast, safe, testable; mines TemplateSyntaxError paths, block structure, expression grammar                                     |\n\nThe Python inspector provides:\n\n- `engine.libraries` mapping (load-name → module path) with keys preserved\n- Ordered builtin module paths\n- Tag/filter inventory per library (names, which library they belong to)\n\nRust extraction enriches the inventory with validation semantics by parsing source files.\n\nThe remaining question is **where extraction lives within the Rust codebase**.\n\n### Option A: Expand `djls-semantic` (No New Crates)\n\nAdd extraction and new validation logic to existing crate.\n\n```\ndjls-semantic/\n├── src/\n│   ├── extraction/        # NEW: Python AST → rules\n│   │   ├── mod.rs\n│   │   ├── tags.rs\n│   │   ├── filters.rs\n│   │   ├── structural.rs\n│   │   └── opaque.rs\n│   ├── load_resolution.rs # NEW: {% load %} scoping\n│   ├── filters.rs         # NEW: filter validation\n│   ├── if_expression.rs   # NEW: expression validation\n│   ├── arguments.rs       # EXTEND: use extracted rules\n│   └── blocks/            # EXTEND: use extracted BlockTagSpec\n```\n\n**Pros:**\n\n- No new crate boundaries to manage\n- Shared types don't need pub export juggling\n- Simpler dependency graph\n\n**Cons:**\n\n- `djls-semantic` grows large\n- Extraction depends on `ruff_python_parser`; semantic analysis doesn't\n- Harder to test extraction in isolation\n\n### Option B: New `djls-extraction` Crate\n\nSeparate crate for Python AST parsing and rule extraction.\n\n```\ndjls-extraction/           # NEW CRATE\n├── Cargo.toml             # Depends on ruff_python_parser\n└── src/\n    ├── lib.rs\n    ├── registry.rs        # Registration discovery\n    ├── rules.rs           # TemplateSyntaxError → rules\n    ├── structural.rs      # Block specs\n    ├── filters.rs         # Filter specs\n    └── types.rs           # TagValidation, BlockTagSpec, etc.\n\ndjls-semantic/\n├── src/\n│   ├── load_resolution.rs # Uses extraction output\n│   ├── filters.rs\n│   └── ...                # Uses extraction output\n```\n\n**Pros:**\n\n- Clean separation: extraction (Python AST) vs validation (templates)\n- Extraction crate testable in isolation\n- `ruff_python_parser` dependency confined to one crate\n\n**Cons:**\n\n- Adds crate boundary\n- Types must be pub-exported across crates\n- Slightly more complex build graph\n\n### Option C: New `djls-rules` Crate (Types Only)\n\nSeparate crate for rule types; extraction stays ad-hoc.\n\n```\ndjls-rules/                # NEW CRATE: types only\n├── src/\n│   └── lib.rs             # TagValidation, BlockTagSpec, FilterSpec, etc.\n\ndjls-semantic/\n├── src/\n│   ├── extraction/        # Uses djls-rules types\n│   └── ...                # Uses djls-rules types\n```\n\n**Pros:**\n\n- Rule types shareable without extraction logic\n- Minimal new crate\n\n**Cons:**\n\n- Doesn't solve the extraction isolation problem\n- `ruff_python_parser` still in semantic\n\n### Comparison Matrix\n\n| Criterion            | A (semantic) | B (crate) | C (types) |\n| -------------------- | ------------ | --------- | --------- |\n| Dependency isolation | ❌           | ✅        | ❌        |\n| Test in isolation    | ❌           | ✅        | ❌        |\n| Conceptual clarity   | ⚠️           | ✅        | ⚠️        |\n| Build complexity     | ✅           | ⚠️        | ✅        |\n| Future flexibility   | ⚠️           | ✅        | ⚠️        |\n\n### Recommendation: Option B (`djls-extraction` Crate)\n\n**Rationale:**\n\n1. **Dependency isolation**: `ruff_python_parser` (git dep) confined to one crate\n2. **Testability**: Extraction testable against golden fixtures without template parsing\n3. **Conceptual clarity**: \"Python source analysis\" vs \"template semantic analysis\" are distinct concerns\n4. **Safety**: Changes to extraction don't risk breaking template validation\n\nThe crate boundary cost is low; the isolation benefit is high given the git-dep nature of `ruff_python_parser`.\n\n---\n\n## 6. Risk Register\n\n### R1: Tokenization Drift\n\n| Aspect         | Detail                                                                                        |\n| -------------- | --------------------------------------------------------------------------------------------- |\n| **Risk**       | Rust template tokenizer produces different token boundaries than Django's lexer               |\n| **Impact**     | Validation misses errors or produces false positives                                          |\n| **Likelihood** | Medium (djls already has a tokenizer; may have subtle differences)                            |\n| **Mitigation** | Tokenization parity fixtures from template_linter; regression tests on Django admin templates |\n| **Monitoring** | Corpus test: any new diagnostics vs baseline = investigation                                  |\n\n### R2: AST Pattern Ambiguity\n\n| Aspect         | Detail                                                                                               |\n| -------------- | ---------------------------------------------------------------------------------------------------- |\n| **Risk**       | Python AST patterns for extraction are more varied than template_linter handles                      |\n| **Impact**     | Missing rules for some tags; over-extraction (false rules)                                           |\n| **Likelihood** | Medium (template_linter corpus proves patterns, but Rust port may interpret differently)             |\n| **Mitigation** | Golden tests: extracted rules match template_linter output; conservative extraction (skip ambiguous) |\n| **Monitoring** | Per-library inventory test: tag/filter count matches expected                                        |\n\n### R3: ruff_python_parser Instability\n\n| Aspect         | Detail                                                                                                        |\n| -------------- | ------------------------------------------------------------------------------------------------------------- |\n| **Risk**       | Breaking changes in ruff_python_parser AST types                                                              |\n| **Impact**     | Extraction code breaks; requires port updates                                                                 |\n| **Likelihood** | Low-Medium (internal crate, but Astral is careful)                                                            |\n| **Mitigation** | Pin to SHA; don't update without testing; wrapper types if needed; monitor Ruff releases for breaking changes |\n| **Monitoring** | CI build failure on parser update = review changes; watch Ruff changelog                                      |\n\n### R4: Load Scoping Edge Cases\n\n| Aspect         | Detail                                                                                  |\n| -------------- | --------------------------------------------------------------------------------------- |\n| **Risk**       | Complex `{% load %}` scenarios (extends/include, conditional loads) break scoping       |\n| **Impact**     | Incorrect diagnostics; user confusion                                                   |\n| **Likelihood** | Medium (extends/include are common)                                                     |\n| **Mitigation** | Document limitations; conservative default (assume unknown tags valid in complex cases) |\n| **Monitoring** | Real-world project testing; user feedback                                               |\n\n### R5: Performance Regression\n\n| Aspect         | Detail                                                       |\n| -------------- | ------------------------------------------------------------ |\n| **Risk**       | Extracted rules are larger/slower than handcoded specs       |\n| **Impact**     | Slow LSP response; poor UX                                   |\n| **Likelihood** | Low (Salsa caching; rules loaded once)                       |\n| **Mitigation** | Profile before/after; optimize rule representation if needed |\n| **Monitoring** | Benchmark: diagnostics latency on large template             |\n\n### R6: Collision Without Registry\n\n| Aspect         | Detail                                                                                          |\n| -------------- | ----------------------------------------------------------------------------------------------- |\n| **Risk**       | Projects with multiple templatetags dirs have collisions; static analysis can't resolve         |\n| **Impact**     | Missing validation for colliding tags; user must provide registry                               |\n| **Likelihood** | High (common in Django projects)                                                                |\n| **Mitigation** | Clear diagnostic: \"Cannot resolve `foo`: multiple libraries define it\"; document registry setup |\n| **Monitoring** | Track user reports of collision issues                                                          |\n\n### R7: Filter Argument Parsing Complexity\n\n| Aspect         | Detail                                                                |\n| -------------- | --------------------------------------------------------------------- | -------------------------------------------- |\n| **Risk**       | Django's filter argument syntax (`                                    | filter:\"arg\"`) has quote handling edge cases |\n| **Impact**     | Filter validation false positives/negatives                           |\n| **Likelihood** | Medium (template_linter has `_parse_filter_chain`; port may diverge)  |\n| **Mitigation** | Port filter parsing logic carefully; dedicated test suite for quoting |\n| **Monitoring** | Filter-specific corpus tests                                          |\n\n### R8: Parser Filter Representation Change (M4 Breakpoint)\n\n| Aspect         | Detail                                                                                                                                                |\n| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Risk**       | Changing `filters: Vec<String>` → structured representation touches many layers                                                                       |\n| **Impact**     | Wide-ranging PR; potential for subtle regressions; merge conflicts                                                                                    |\n| **Likelihood** | High (this is a known \"touch many layers\" change)                                                                                                     |\n| **Mitigation** | Plan as explicit breakpoint: update all callers in one PR, or add adapter layer; do after invalidation (M2) is solid to avoid amplifying caching bugs |\n| **Monitoring** | Comprehensive snapshot tests before/after; no intermediate broken states                                                                              |\n\n---\n\n## 7. Success Criteria\n\nThe port is \"complete\" when:\n\n1. **Inventory parity**: Extracted tag/filter count for Django 5.2 matches template_linter\n2. **Validation parity**: Running against Django admin templates produces equivalent diagnostics (same error codes, same locations ±1 line)\n3. **No regressions**: All existing djls tests pass\n4. **Load scoping works**: Documented test cases for `{% load %}` behavior all pass\n5. **Filter validation exists**: `{{ x|unknown }}` produces diagnostic\n6. **Salsa invalidation works**: Config change triggers revalidation (tested)\n7. **Corpus clean**: Django admin templates validate with zero false positives under strict mode\n\n---\n\n## 8. Open Questions (Captured for Resolution)\n\n| #   | Question                                                                        | Proposed Owner     | Depends On  |\n| --- | ------------------------------------------------------------------------------- | ------------------ | ----------- |\n| Q1  | What SHA of ruff_python_parser to pin initially?                                | Port lead          | M5 kickoff  |\n| Q2  | How to handle `{% extends %}`/`{% include %}` for load scoping?                 | Port lead          | M3 design   |\n| Q3  | What's the performance budget for rule loading at startup?                      | Project maintainer | Profiling   |\n| Q4  | Should third-party library rules be bundled or user-provided?                   | Project maintainer | M5 design   |\n| Q5  | What's the compatibility strategy for parser filter representation change (M4)? | Port lead          | M4 planning |\n\n---\n\n## Appendix A: Key File References\n\n### template_linter (Python Prototype)\n\n| Module                           | Purpose                               |\n| -------------------------------- | ------------------------------------- |\n| `extraction/api.py`              | Entry points for extraction           |\n| `extraction/rules.py`            | AST → validation rules                |\n| `extraction/structural.py`       | Block spec extraction                 |\n| `extraction/filters.py`          | Filter spec extraction                |\n| `resolution/load.py`             | `{% load %}` resolution               |\n| `resolution/runtime_registry.py` | Django Engine state                   |\n| `validation/tags.py`             | Tag rule validation                   |\n| `validation/filters.py`          | Filter validation                     |\n| `validation/if_expression.py`    | Expression parsing                    |\n| `types.py`                       | `TagValidation`, `BlockTagSpec`, etc. |\n\n### django-language-server (Rust)\n\n| Location                                            | Purpose                         |\n| --------------------------------------------------- | ------------------------------- |\n| `crates/djls-semantic/src/templatetags/builtins.rs` | Handcoded TagSpecs (to replace) |\n| `crates/djls-semantic/src/templatetags/specs.rs`    | `TagSpec`, `TagSpecs` types     |\n| `crates/djls-semantic/src/blocks/`                  | Block tree building             |\n| `crates/djls-semantic/src/arguments.rs`             | Argument validation             |\n| `crates/djls-project/inspector/queries.py`          | Python introspection            |\n| `crates/djls-project/src/django.rs`                 | `TemplateTag` types             |\n| `crates/djls-ide/src/completions.rs`                | LSP completions                 |\n| `crates/djls-server/src/db.rs`                      | Salsa database, settings        |\n\n---\n\n## Appendix B: Mapping template_linter Types → djls\n\n| template_linter   | djls Current                            | djls Target                        |\n| ----------------- | --------------------------------------- | ---------------------------------- |\n| `TagValidation`   | `TagSpec` (partial)                     | `TagSpec` + validation rules       |\n| `ExtractedRule`   | N/A                                     | Validation logic in `arguments.rs` |\n| `ContextualRule`  | N/A                                     | Preconditioned validation (new)    |\n| `ParseBitsSpec`   | `TagArg`                                | `TagArg` (extended)                |\n| `BlockTagSpec`    | `TagSpec.end_tag` + `intermediate_tags` | Same (populated from extraction)   |\n| `OpaqueBlockSpec` | N/A                                     | New type for verbatim/comment      |\n| `FilterSpec`      | N/A                                     | New type in `djls-semantic`        |\n| `LibraryIndex`    | N/A                                     | New in `load_resolution.rs`        |\n| `RuntimeRegistry` | N/A                                     | New in `djls-project`              |\n"}],"isError":false,"timestamp":1770329167345}}
{"type":"message","id":"5c51dbc6","parentId":"fa549e59","timestamp":"2026-02-05T22:06:11.423Z","message":{"role":"assistant","content":[{"type":"text","text":"Now let me list the milestone plans to understand what exists:"},{"type":"toolCall","id":"toolu_0154PiMSoVrToGFw7eESahTz","name":"bash","arguments":{"command":"ls -la /home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/.agents/plans/"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":1,"output":104,"cacheRead":7206,"cacheWrite":15041,"totalTokens":22352,"cost":{"input":0.000005,"output":0.0026000000000000003,"cacheRead":0.003603,"cacheWrite":0.09400625,"total":0.10021425}},"stopReason":"toolUse","timestamp":1770329167346}}
{"type":"message","id":"ea74e9c1","parentId":"5c51dbc6","timestamp":"2026-02-05T22:06:11.437Z","message":{"role":"toolResult","toolCallId":"toolu_0154PiMSoVrToGFw7eESahTz","toolName":"bash","content":[{"type":"text","text":"total 452\ndrwxr-xr-x 1 josh josh  1962 Feb  5 14:21 .\ndrwxr-xr-x 1 josh josh   100 Feb  5 14:21 ..\n-rw-r--r-- 1 josh josh 25623 Feb  5 14:21 2026-02-05-m1-payload-library-name-fix.md\n-rw-r--r-- 1 josh josh 34219 Feb  5 14:21 2026-02-05-m2-salsa-invalidation-plumbing.md\n-rw-r--r-- 1 josh josh  9379 Feb  5 14:21 2026-02-05-m3.1-load-scoping.md\n-rw-r--r-- 1 josh josh  2829 Feb  5 14:21 2026-02-05-m3.2-load-scoping.md\n-rw-r--r-- 1 josh josh 12725 Feb  5 14:21 2026-02-05-m3.3-load-scoping.md\n-rw-r--r-- 1 josh josh 12096 Feb  5 14:21 2026-02-05-m3.4-load-scoping.md\n-rw-r--r-- 1 josh josh  7882 Feb  5 14:21 2026-02-05-m3.5-load-scoping.md\n-rw-r--r-- 1 josh josh  3427 Feb  5 14:21 2026-02-05-m3.6-load-scoping.md\n-rw-r--r-- 1 josh josh 12818 Feb  5 14:21 2026-02-05-m3-load-scoping.md\n-rw-r--r-- 1 josh josh 16693 Feb  5 14:21 2026-02-05-m4.1-filters-pipeline.md\n-rw-r--r-- 1 josh josh 22105 Feb  5 14:21 2026-02-05-m4.2-filters-pipeline.md\n-rw-r--r-- 1 josh josh  7485 Feb  5 14:21 2026-02-05-m4.3-filters-pipeline.md\n-rw-r--r-- 1 josh josh  9676 Feb  5 14:21 2026-02-05-m4.4-filters-pipeline.md\n-rw-r--r-- 1 josh josh 12828 Feb  5 14:21 2026-02-05-m4-filters-pipeline.md\n-rw-r--r-- 1 josh josh 15239 Feb  5 14:21 2026-02-05-m5.1-extraction-engine.md\n-rw-r--r-- 1 josh josh 11222 Feb  5 14:21 2026-02-05-m5.2-extraction-engine.md\n-rw-r--r-- 1 josh josh  7202 Feb  5 14:21 2026-02-05-m5.3-extraction-engine.md\n-rw-r--r-- 1 josh josh 12295 Feb  5 14:21 2026-02-05-m5.4-extraction-engine.md\n-rw-r--r-- 1 josh josh 27035 Feb  5 14:21 2026-02-05-m5.5-extraction-engine.md\n-rw-r--r-- 1 josh josh  2570 Feb  5 14:21 2026-02-05-m5.6-extraction-engine.md\n-rw-r--r-- 1 josh josh 37897 Feb  5 14:21 2026-02-05-m5.7-extraction-engine.md\n-rw-r--r-- 1 josh josh  3908 Feb  5 14:21 2026-02-05-m5.8-extraction-engine.md\n-rw-r--r-- 1 josh josh 27330 Feb  5 14:21 2026-02-05-m5.9-extraction-engine.md\n-rw-r--r-- 1 josh josh 10834 Feb  5 14:21 2026-02-05-m5-extraction-engine.md\n-rw-r--r-- 1 josh josh  7825 Feb  5 14:21 2026-02-05-m6.1-expression-parser.md\n-rw-r--r-- 1 josh josh 24165 Feb  5 14:21 2026-02-05-m6.2-filter-arity-validation.md\n-rw-r--r-- 1 josh josh  6365 Feb  5 14:21 2026-02-05-m6-rule-evaluation.md\n-rw-r--r-- 1 josh josh 26847 Feb  5 14:21 2026-02-05-m7-docs-and-issue-template.md\n"}],"isError":false,"timestamp":1770329171436}}
{"type":"message","id":"20ce64d7","parentId":"ea74e9c1","timestamp":"2026-02-05T22:06:16.012Z","message":{"role":"assistant","content":[{"type":"text","text":"Good. Now I need to read the M1 plan to create the initial `IMPLEMENTATION_PLAN.md` with stub entries for all milestones, and then expand M1's section with detailed tasks. Per the instructions, I should only read one milestone plan at a time. Let me read M1:"},{"type":"toolCall","id":"toolu_01Vhqxfu2aGz8SnJ3yzQiwez","name":"read","arguments":{"path":"/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/.agents/plans/2026-02-05-m1-payload-library-name-fix.md"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":1,"output":173,"cacheRead":22247,"cacheWrite":1389,"totalTokens":23810,"cost":{"input":0.000005,"output":0.004325,"cacheRead":0.0111235,"cacheWrite":0.00868125,"total":0.024134749999999996}},"stopReason":"toolUse","timestamp":1770329171437}}
{"type":"message","id":"ddf70a3f","parentId":"20ce64d7","timestamp":"2026-02-05T22:06:16.015Z","message":{"role":"toolResult","toolCallId":"toolu_01Vhqxfu2aGz8SnJ3yzQiwez","toolName":"read","content":[{"type":"text","text":"# M1: Payload Shape + Library Name Fix Implementation Plan\n\n## Overview\n\nFix the inspector payload structure to preserve Django library load-names and distinguish builtins from loadable libraries, then fix completions to show correct library names for `{% load %}`.\n\n## Current State Analysis\n\n### Python Inspector (`crates/djls-project/inspector/queries.py`)\n\n- `TemplateTag` dataclass has `name`, `module`, `doc`\n- `get_installed_templatetags()` iterates `engine.libraries.values()`, **losing the library name key**\n- `module` field stores `tag_func.__module__` (defining module), not the library module\n- No distinction between builtins and loadable libraries—all flattened into one list\n\n### Rust Types (`crates/djls-project/src/django.rs`)\n\n- `TemplateTag` struct mirrors Python: `name`, `module`, `doc`\n- `module()` returns the defining module path (e.g., `django.template.defaulttags`)\n- No concept of library load-name or provenance\n\n### Completions (`crates/djls-ide/src/completions.rs`)\n\n- `generate_library_completions()` at line 526 collects `tag.module()` as library names\n- Results in completions like `django.templatetags.static` instead of `static`\n- Cannot filter out builtins (which shouldn't appear in `{% load %}` completions)\n\n## Desired End State\n\nPer charter section 1.1:\n\n1. **Inventory items carry:**\n    - `name` — tag name as used in templates\n    - `provenance` — **exactly one of:**\n        - `Library { load_name, module }` — requires `{% load X %}`\n        - `Builtin { module }` — always available\n    - `defining_module` — where the function is defined (`tag_func.__module__`)\n    - `doc` — optional docstring\n2. **`{% load %}` completions show library load-names** (`static`, `i18n`) not module paths\n3. **Builtins excluded from `{% load %}` completions** (they're always available)\n\n## What We're NOT Doing\n\n- **M3 load scoping**: Unknown tag diagnostics remain silent (pre-M3 behavior)\n- **Filter inventory**: Filter collection is M4 scope\n- **Collision handling**: Per charter, no collision detection in M1\n- **Salsa invalidation fixes**: That's M2 scope\n\n## Implementation Approach\n\nSingle PR with three components:\n\n1. Expand Python inspector payload with new data model\n2. Update Rust types to deserialize new payload\n3. Fix completions to use `load_name` from `Library` provenance\n\n## Phase 1: Python Inspector Payload Changes\n\n### Overview\n\nUpdate the inspector to return library information with proper provenance distinction, plus top-level registry structures for downstream use.\n\n### Changes Required:\n\n#### 1. Update Data Structures\n\n**File**: `crates/djls-project/inspector/queries.py` **Changes**: Add new dataclasses for provenance and top-level registry data\n\n```python\n@dataclass\nclass TemplateTag:\n    name: str\n    provenance: dict  # {\"library\": {\"load_name\": str, \"module\": str}} | {\"builtin\": {\"module\": str}}\n    defining_module: str\n    doc: str | None\n\n\n@dataclass\nclass TemplateTagQueryData:\n    # Top-level registry structures (preserved from Django engine)\n    libraries: dict[str, str]  # load_name → module_path mapping\n    builtins: list[str]  # ordered builtin module paths\n    # Tag inventory\n    templatetags: list[TemplateTag]\n```\n\n**Note**: We use `dict` for provenance (not dataclass) because it serializes naturally with `asdict()` as the externally-tagged union `{\"library\": {...}}` or `{\"builtin\": {...}}` that Rust's serde expects.\n\n#### 2. Update Collection Logic\n\n**File**: `crates/djls-project/inspector/queries.py` **Changes**: Rewrite `get_installed_templatetags()` to preserve library keys and use `engine.builtins` for correct module paths\n\n```python\ndef get_installed_templatetags() -> TemplateTagQueryData:\n    import django\n    from django.apps import apps\n    from django.template.engine import Engine\n    from django.template.library import import_library\n\n    if not apps.ready:\n        django.setup()\n\n    engine = Engine.get_default()\n    templatetags: list[TemplateTag] = []\n\n    # Preserve top-level registry structures\n    # engine.libraries: {load_name: module_path} - the authoritative mapping\n    libraries = dict(engine.libraries)\n    # engine.builtins: ordered list of builtin module paths\n    builtins = list(engine.builtins)\n\n    # Collect builtins with Builtin provenance\n    # Use zip to pair module paths (engine.builtins) with Library objects (engine.template_builtins)\n    # Guard: these should always be the same length, but check to avoid silent data loss\n    if len(engine.builtins) != len(engine.template_builtins):\n        raise RuntimeError(\n            f\"engine.builtins ({len(engine.builtins)}) and \"\n            f\"engine.template_builtins ({len(engine.template_builtins)}) length mismatch\"\n        )\n    for builtin_module, library in zip(engine.builtins, engine.template_builtins):\n        if library.tags:\n            for tag_name, tag_func in library.tags.items():\n                templatetags.append(\n                    TemplateTag(\n                        name=tag_name,\n                        provenance={\"builtin\": {\"module\": builtin_module}},\n                        defining_module=tag_func.__module__,\n                        doc=tag_func.__doc__,\n                    )\n                )\n\n    # Collect libraries with Library provenance, preserving load-name\n    for load_name, lib_module in engine.libraries.items():\n        library = import_library(lib_module)\n        if library and library.tags:\n            for tag_name, tag_func in library.tags.items():\n                templatetags.append(\n                    TemplateTag(\n                        name=tag_name,\n                        provenance={\"library\": {\"load_name\": load_name, \"module\": lib_module}},\n                        defining_module=tag_func.__module__,\n                        doc=tag_func.__doc__,\n                    )\n                )\n\n    return TemplateTagQueryData(\n        libraries=libraries,\n        builtins=builtins,\n        templatetags=templatetags,\n    )\n```\n\n**Key fix**: `engine.builtins` gives us the ordered module paths (e.g., `[\"django.template.defaulttags\", \"django.template.defaultfilters\"]`), while `engine.template_builtins` gives us the corresponding `Library` objects. Using `zip()` pairs them correctly.\n\n### Success Criteria:\n\n#### Automated Verification:\n\n- [ ] Rust build passes (which exercises inspector via tests): `cargo build`\n- [ ] Inspector integration test passes: `cargo test -p djls-project`\n- [ ] Manual inspector test: `echo '{\"query\":\"templatetags\"}' | python crates/djls-project/inspector/__main__.py`\n\n#### Manual Verification:\n\n- [ ] Verify payload includes top-level `libraries` dict with load-names as keys\n- [ ] Verify payload includes top-level `builtins` list in correct order\n- [ ] Confirm builtin provenance modules are correct (e.g., `django.template.defaulttags`, not `django.template.library`)\n- [ ] Confirm library provenance has both `load_name` and `module` fields\n\n**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the payload structure is correct before proceeding to the next phase.\n\n---\n\n## Phase 2: Rust Type Updates\n\n### Overview\n\nUpdate Rust types to deserialize the new payload structure with `TagProvenance` enum and top-level registry data.\n\n### Changes Required:\n\n#### 1. Add TagProvenance Enum and Update Response\n\n**File**: `crates/djls-project/src/django.rs` **Changes**: Add new enum, update `TemplateTag` struct, and expand response to include registry data\n\n```rust\nuse std::collections::HashMap;\nuse serde::Deserialize;\n\n/// Provenance of a template tag - either from a loadable library or a builtin\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum TagProvenance {\n    /// Tag requires `{% load X %}` to use\n    Library {\n        /// The name used in `{% load X %}` (e.g., \"static\", \"i18n\")\n        load_name: String,\n        /// The Python module path where the library is registered\n        module: String,\n    },\n    /// Tag is always available (builtin)\n    Builtin {\n        /// The Python module path where the builtin is registered\n        module: String,\n    },\n}\n\n#[derive(Deserialize)]\nstruct TemplatetagsResponse {\n    /// Load-name → module path mapping (from engine.libraries)\n    libraries: HashMap<String, String>,\n    /// Ordered builtin module paths (from engine.builtins)\n    builtins: Vec<String>,\n    /// Tag inventory\n    templatetags: Vec<TemplateTag>,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize)]\npub struct TemplateTag {\n    name: String,\n    provenance: TagProvenance,\n    defining_module: String,\n    doc: Option<String>,\n}\n```\n\n#### 2. Update TemplateTag Accessors\n\n**File**: `crates/djls-project/src/django.rs` **Changes**: Add clear accessors - avoid confusing `module()` name\n\n```rust\nimpl TemplateTag {\n    pub fn name(&self) -> &String {\n        &self.name\n    }\n\n    pub fn provenance(&self) -> &TagProvenance {\n        &self.provenance\n    }\n\n    /// The Python module where the tag function is defined (tag_func.__module__)\n    /// This is where the actual code lives, useful for docs/jump-to-def.\n    pub fn defining_module(&self) -> &String {\n        &self.defining_module\n    }\n\n    pub fn doc(&self) -> Option<&String> {\n        self.doc.as_ref()\n    }\n\n    /// Returns the library load-name if this is a library tag, None for builtins.\n    /// This is the name used in `{% load X %}`.\n    pub fn library_load_name(&self) -> Option<&str> {\n        match &self.provenance {\n            TagProvenance::Library { load_name, .. } => Some(load_name),\n            TagProvenance::Builtin { .. } => None,\n        }\n    }\n\n    /// Returns true if this tag is a builtin (always available without {% load %})\n    pub fn is_builtin(&self) -> bool {\n        matches!(self.provenance, TagProvenance::Builtin { .. })\n    }\n\n    /// The Python module where this tag is registered (the library/builtin module).\n    /// For libraries, this is the module in engine.libraries.\n    /// For builtins, this is the module in engine.builtins.\n    pub fn registration_module(&self) -> &str {\n        match &self.provenance {\n            TagProvenance::Library { module, .. } => module,\n            TagProvenance::Builtin { module } => module,\n        }\n    }\n}\n```\n\n**Note**: We use `defining_module()` for where the function is defined (the old `module()` behavior) and `registration_module()` for the library/builtin module. This avoids the ambiguity of a bare `module()` accessor.\n\n#### 3. Update TemplateTags to Include Registry Data\n\n**File**: `crates/djls-project/src/django.rs` **Changes**: Expand `TemplateTags` to hold top-level registry structures\n\n```rust\n#[derive(Debug, Default, Clone, PartialEq)]\npub struct TemplateTags {\n    /// Load-name → module path mapping (from engine.libraries)\n    libraries: HashMap<String, String>,\n    /// Ordered builtin module paths (from engine.builtins)\n    builtins: Vec<String>,\n    /// Tag inventory\n    tags: Vec<TemplateTag>,\n}\n\nimpl TemplateTags {\n    /// Create a new TemplateTags (primarily for testing)\n    pub fn new(\n        libraries: HashMap<String, String>,\n        builtins: Vec<String>,\n        tags: Vec<TemplateTag>,\n    ) -> Self {\n        Self { libraries, builtins, tags }\n    }\n\n    /// Get the tag list\n    pub fn tags(&self) -> &[TemplateTag] {\n        &self.tags\n    }\n\n    /// Get the libraries mapping (load_name → module_path)\n    pub fn libraries(&self) -> &HashMap<String, String> {\n        &self.libraries\n    }\n\n    /// Get the ordered builtin module paths\n    pub fn builtins(&self) -> &[String] {\n        &self.builtins\n    }\n\n    /// Iterate over tags (convenience method)\n    pub fn iter(&self) -> impl Iterator<Item = &TemplateTag> {\n        self.tags.iter()\n    }\n\n    /// Number of tags\n    pub fn len(&self) -> usize {\n        self.tags.len()\n    }\n\n    /// Check if empty\n    pub fn is_empty(&self) -> bool {\n        self.tags.is_empty()\n    }\n}\n\nimpl TemplateTag {\n    /// Create a library tag (for testing)\n    pub fn new_library(name: &str, load_name: &str, module: &str, doc: Option<&str>) -> Self {\n        Self {\n            name: name.to_string(),\n            provenance: TagProvenance::Library {\n                load_name: load_name.to_string(),\n                module: module.to_string(),\n            },\n            defining_module: module.to_string(),\n            doc: doc.map(String::from),\n        }\n    }\n\n    /// Create a builtin tag (for testing)\n    pub fn new_builtin(name: &str, module: &str, doc: Option<&str>) -> Self {\n        Self {\n            name: name.to_string(),\n            provenance: TagProvenance::Builtin {\n                module: module.to_string(),\n            },\n            defining_module: module.to_string(),\n            doc: doc.map(String::from),\n        }\n    }\n}\n```\n\n#### 4. Update the Salsa Query\n\n**File**: `crates/djls-project/src/django.rs` **Changes**: Convert response to new TemplateTags structure\n\n```rust\n#[salsa::tracked]\npub fn templatetags(db: &dyn ProjectDb, _project: Project) -> Option<TemplateTags> {\n    let response = inspector::query(db, &TemplatetagsRequest)?;\n    let tag_count = response.templatetags.len();\n    tracing::debug!(\"Retrieved {} templatetags from inspector\", tag_count);\n    Some(TemplateTags {\n        libraries: response.libraries,\n        builtins: response.builtins,\n        tags: response.templatetags,\n    })\n}\n```\n\n#### 5. Update lib.rs Exports\n\n**File**: `crates/djls-project/src/lib.rs` **Changes**: Export the new enum\n\n```rust\npub use django::TagProvenance;\n```\n\n#### 6. Update Tests\n\n**File**: `crates/djls-project/src/django.rs` **Changes**: Update existing tests and add new ones for provenance\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_template_tag_library_provenance() {\n        let tag = TemplateTag {\n            name: \"static\".to_string(),\n            provenance: TagProvenance::Library {\n                load_name: \"static\".to_string(),\n                module: \"django.templatetags.static\".to_string(),\n            },\n            defining_module: \"django.templatetags.static\".to_string(),\n            doc: Some(\"Display static file URL\".to_string()),\n        };\n        assert_eq!(tag.name(), \"static\");\n        assert_eq!(tag.library_load_name(), Some(\"static\"));\n        assert!(!tag.is_builtin());\n        assert_eq!(tag.registration_module(), \"django.templatetags.static\");\n        assert_eq!(tag.defining_module(), \"django.templatetags.static\");\n    }\n\n    #[test]\n    fn test_template_tag_builtin_provenance() {\n        let tag = TemplateTag {\n            name: \"if\".to_string(),\n            provenance: TagProvenance::Builtin {\n                module: \"django.template.defaulttags\".to_string(),\n            },\n            defining_module: \"django.template.defaulttags\".to_string(),\n            doc: Some(\"Conditional block\".to_string()),\n        };\n        assert_eq!(tag.name(), \"if\");\n        assert_eq!(tag.library_load_name(), None);\n        assert!(tag.is_builtin());\n        assert_eq!(tag.registration_module(), \"django.template.defaulttags\");\n    }\n\n    #[test]\n    fn test_template_tag_deserialization() {\n        let json = r#\"{\n            \"name\": \"trans\",\n            \"provenance\": {\"library\": {\"load_name\": \"i18n\", \"module\": \"django.templatetags.i18n\"}},\n            \"defining_module\": \"django.templatetags.i18n\",\n            \"doc\": \"Translate text\"\n        }\"#;\n        let tag: TemplateTag = serde_json::from_str(json).expect(\"Should deserialize\");\n        assert_eq!(tag.name(), \"trans\");\n        assert_eq!(tag.library_load_name(), Some(\"i18n\"));\n    }\n\n    #[test]\n    fn test_template_tags_registry_data() {\n        let mut libraries = HashMap::new();\n        libraries.insert(\"static\".to_string(), \"django.templatetags.static\".to_string());\n        libraries.insert(\"i18n\".to_string(), \"django.templatetags.i18n\".to_string());\n\n        let tags = TemplateTags {\n            libraries,\n            builtins: vec![\n                \"django.template.defaulttags\".to_string(),\n                \"django.template.defaultfilters\".to_string(),\n            ],\n            tags: vec![\n                TemplateTag {\n                    name: \"if\".to_string(),\n                    provenance: TagProvenance::Builtin {\n                        module: \"django.template.defaulttags\".to_string(),\n                    },\n                    defining_module: \"django.template.defaulttags\".to_string(),\n                    doc: None,\n                },\n                TemplateTag {\n                    name: \"static\".to_string(),\n                    provenance: TagProvenance::Library {\n                        load_name: \"static\".to_string(),\n                        module: \"django.templatetags.static\".to_string(),\n                    },\n                    defining_module: \"django.templatetags.static\".to_string(),\n                    doc: None,\n                },\n            ],\n        };\n\n        assert_eq!(tags.len(), 2);\n        assert_eq!(tags.libraries().len(), 2);\n        assert_eq!(tags.builtins().len(), 2);\n        assert!(tags.iter().next().unwrap().is_builtin());\n    }\n}\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n\n- [ ] Rust compiles: `cargo build -p djls-project`\n- [ ] Clippy passes: `cargo clippy -p djls-project --all-targets -- -D warnings`\n- [ ] Unit tests pass: `cargo test -p djls-project`\n- [ ] Deserialization test passes with mock JSON\n\n#### Manual Verification:\n\n- [ ] Confirm `TagProvenance` enum is ergonomic to use in downstream code\n\n**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the Rust types are correct before proceeding to the next phase.\n\n---\n\n## Phase 3: Completions Fix\n\n### Overview\n\nUpdate completions to use library load-name and exclude builtins from `{% load %}` completions.\n\n### Changes Required:\n\n#### 1. Update Library Completions\n\n**File**: `crates/djls-ide/src/completions.rs` **Changes**: Fix `generate_library_completions()` to use library keys directly, with deterministic ordering\n\n```rust\n/// Generate completions for library names (for {% load %} tag)\nfn generate_library_completions(\n    partial: &str,\n    closing: &ClosingBrace,\n    template_tags: Option<&TemplateTags>,\n) -> Vec<ls_types::CompletionItem> {\n    let Some(tags) = template_tags else {\n        return Vec::new();\n    };\n\n    // Collect and sort library names for deterministic ordering\n    let mut library_entries: Vec<_> = tags.libraries()\n        .iter()\n        .filter(|(load_name, _)| load_name.starts_with(partial))\n        .collect();\n    library_entries.sort_by_key(|(load_name, _)| load_name.as_str());\n\n    let mut completions = Vec::new();\n\n    for (load_name, module_path) in library_entries {\n        let mut insert_text = load_name.clone();\n\n        // Add closing if needed\n        match closing {\n            ClosingBrace::None => insert_text.push_str(\" %}\"),\n            ClosingBrace::PartialClose => insert_text.push_str(\" %\"),\n            ClosingBrace::FullClose => {} // No closing needed\n        }\n\n        completions.push(ls_types::CompletionItem {\n            label: load_name.clone(),\n            kind: Some(ls_types::CompletionItemKind::MODULE),\n            detail: Some(format!(\"Django template library ({})\", module_path)),\n            insert_text: Some(insert_text),\n            insert_text_format: Some(ls_types::InsertTextFormat::PLAIN_TEXT),\n            filter_text: Some(load_name.clone()),\n            ..Default::default()\n        });\n    }\n\n    completions\n}\n```\n\n**Note**: We sort library names alphabetically for deterministic completion ordering. HashMap iteration order is nondeterministic, which would cause flaky tests and inconsistent UX.\n\n#### 2. Update Tag Name Completion Detail\n\n**File**: `crates/djls-ide/src/completions.rs` **Changes**: Update detail to show more useful info in `generate_tag_name_completions()`\n\nFind the line (around line 488):\n\n```rust\ndetail: Some(format!(\"from {}\", tag.module())),\n```\n\nChange to show library info when available:\n\n```rust\ndetail: Some(if let Some(lib) = tag.library_load_name() {\n    format!(\"from {} ({{% load {} %}})\", tag.defining_module(), lib)\n} else {\n    format!(\"builtin from {}\", tag.defining_module())\n}),\n```\n\n#### 3. Update Tag Iteration\n\n**File**: `crates/djls-ide/src/completions.rs` **Changes**: Since `TemplateTags` no longer implements `Deref`, update iteration\n\nFind uses of `tags.iter()` in `generate_tag_name_completions()` and ensure they still work (the `iter()` method is still available on `TemplateTags`).\n\n### Success Criteria:\n\n#### Automated Verification:\n\n- [ ] Rust compiles: `cargo build -p djls-ide`\n- [ ] Clippy passes: `cargo clippy -p djls-ide --all-targets -- -D warnings`\n- [ ] Unit tests pass: `cargo test -p djls-ide`\n- [ ] Full build passes: `cargo build`\n- [ ] All tests pass: `cargo test`\n\n#### Manual Verification:\n\n- [ ] Open a Django project in editor with djls\n- [ ] Type `{% load ` and verify completions show `static`, `i18n`, `cache` etc.\n- [ ] Verify completions do NOT show module paths like `django.templatetags.static`\n- [ ] Verify builtin tag completions show \"builtin from ...\" in detail\n- [ ] Verify library tag completions show \"from ... ({% load X %})\" in detail\n\n**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that completions work correctly in the editor.\n\n---\n\n## Testing Strategy\n\n### Unit Tests (Automated):\n\n#### In `crates/djls-project/src/django.rs`:\n\n1. **Rust deserialization** - verify `TagProvenance` enum deserializes correctly from JSON\n2. **Accessor methods** - verify `library_load_name()`, `is_builtin()`, `defining_module()`, `registration_module()` work correctly\n3. **Registry data accessors** - verify `libraries()`, `builtins()` return expected data\n\n#### In `crates/djls-ide/src/completions.rs`:\n\nAdd a new test for library completions:\n\n```rust\n#[test]\nfn test_generate_library_completions() {\n    use std::collections::HashMap;\n    use djls_project::{TemplateTags, TemplateTag, TagProvenance};\n\n    let mut libraries = HashMap::new();\n    libraries.insert(\"static\".to_string(), \"django.templatetags.static\".to_string());\n    libraries.insert(\"i18n\".to_string(), \"django.templatetags.i18n\".to_string());\n    libraries.insert(\"cache\".to_string(), \"django.templatetags.cache\".to_string());\n\n    let tags = TemplateTags::new(\n        libraries,\n        vec![\"django.template.defaulttags\".to_string()],\n        vec![\n            TemplateTag::new_builtin(\"if\", \"django.template.defaulttags\", None),\n            TemplateTag::new_library(\"static\", \"static\", \"django.templatetags.static\", None),\n        ],\n    );\n\n    let completions = generate_library_completions(\"\", &ClosingBrace::None, Some(&tags));\n\n    // Should return library names, not module paths\n    let labels: Vec<_> = completions.iter().map(|c| c.label.as_str()).collect();\n    assert!(labels.contains(&\"static\"));\n    assert!(labels.contains(&\"i18n\"));\n    assert!(labels.contains(&\"cache\"));\n\n    // Should NOT contain module paths\n    assert!(!labels.iter().any(|l| l.contains(\"django.\")));\n\n    // Should be deterministically ordered (alphabetical)\n    assert_eq!(labels, vec![\"cache\", \"i18n\", \"static\"]);\n}\n\n#[test]\nfn test_generate_library_completions_partial() {\n    // ... similar test with partial = \"st\" expecting only \"static\"\n}\n```\n\n**Note**: This requires adding constructor methods to `TemplateTags`/`TemplateTag` for test convenience, or making fields pub(crate).\n\n### Manual Testing Steps:\n\n1. Start djls in a Django project\n2. Open a template file\n3. Type `{% load ` and trigger completion\n4. Verify library names appear (not module paths)\n5. Verify completions are in alphabetical order\n6. Select a completion and verify it inserts correctly\n7. Type `{% if` and trigger completion\n8. Verify detail shows \"builtin from django.template.defaulttags\"\n\n## Performance Considerations\n\n- Payload size slightly increases due to nested provenance structure\n- No performance impact on completion generation (still O(n) iteration)\n- HashSet deduplication is the same algorithmic complexity\n\n## Migration Notes\n\nThis is a **breaking change** to the inspector payload format:\n\n**Old payload:**\n\n```json\n{\n    \"templatetags\": [{ \"name\": \"static\", \"module\": \"django.templatetags.static\", \"doc\": \"...\" }]\n}\n```\n\n**New payload:**\n\n```json\n{\n    \"libraries\": { \"static\": \"django.templatetags.static\", \"i18n\": \"django.templatetags.i18n\" },\n    \"builtins\": [\"django.template.defaulttags\", \"django.template.defaultfilters\"],\n    \"templatetags\": [\n        {\n            \"name\": \"static\",\n            \"provenance\": {\n                \"library\": { \"load_name\": \"static\", \"module\": \"django.templatetags.static\" }\n            },\n            \"defining_module\": \"django.templatetags.static\",\n            \"doc\": \"...\"\n        },\n        {\n            \"name\": \"if\",\n            \"provenance\": { \"builtin\": { \"module\": \"django.template.defaulttags\" } },\n            \"defining_module\": \"django.template.defaulttags\",\n            \"doc\": \"...\"\n        }\n    ]\n}\n```\n\nNo data migration needed—this is runtime data from Django introspection.\n\n## References\n\n- Charter: [`.agents/charter/2026-02-05-template-validation-port-charter.md`](../charter/2026-02-05-template-validation-port-charter.md)\n- Current inspector: `crates/djls-project/inspector/queries.py`\n- Current Rust types: `crates/djls-project/src/django.rs`\n- Current completions: `crates/djls-ide/src/completions.rs`\n"}],"isError":false,"timestamp":1770329176015}}
{"type":"message","id":"cd80d09f","parentId":"ddf70a3f","timestamp":"2026-02-05T22:06:41.104Z","message":{"role":"assistant","content":[{"type":"text","text":"Now I have a thorough understanding of all milestones and the detailed M1 plan. Let me create the `IMPLEMENTATION_PLAN.md` with stub entries for all milestones and expanded tasks for M1."},{"type":"toolCall","id":"toolu_01UgE4Z9nffj1BVjiScK9PfC","name":"write","arguments":{"path":"/home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/IMPLEMENTATION_PLAN.md","content":"# Implementation Plan: Template Validation Port\n\n**Program:** Port `template_linter/` capabilities to Rust (`django-language-server`)\n**Charter:** `.agents/charter/2026-02-05-template-validation-port-charter.md`\n**Roadmap:** `.agents/ROADMAP.md`\n\n---\n\n## M1 - Payload Shape + Library Name Fix\n\n**Status:** in progress\n**Plan:** `.agents/plans/2026-02-05-m1-payload-library-name-fix.md`\n\n### Phase 1: Python Inspector Payload Changes\n\n- [ ] Update `TemplateTag` dataclass in `queries.py` to include `provenance` dict and `defining_module` field\n- [ ] Add `TemplateTagQueryData` dataclass with `libraries`, `builtins`, and `templatetags` fields\n- [ ] Rewrite `get_installed_templatetags()` to preserve library load-name keys from `engine.libraries`\n- [ ] Collect builtins using `zip(engine.builtins, engine.template_builtins)` with length guard\n- [ ] Collect library tags preserving `load_name` from `engine.libraries` iteration\n- [ ] Verify inspector payload manually: `libraries` dict, `builtins` list, provenance on each tag\n\n### Phase 2: Rust Type Updates\n\n- [ ] Add `TagProvenance` enum (`Library { load_name, module }` / `Builtin { module }`) in `crates/djls-project/src/django.rs`\n- [ ] Update `TemplateTag` struct: replace `module` with `provenance` + `defining_module`\n- [ ] Add accessors: `library_load_name()`, `is_builtin()`, `registration_module()`, `defining_module()`\n- [ ] Add `TemplatetagsResponse` struct with `libraries`, `builtins`, `templatetags`\n- [ ] Update `TemplateTags` to hold `libraries: HashMap<String, String>`, `builtins: Vec<String>`, `tags: Vec<TemplateTag>`\n- [ ] Add `TemplateTags` accessors: `libraries()`, `builtins()`, `tags()`, `iter()`, `len()`, `is_empty()`\n- [ ] Add test constructors: `TemplateTag::new_library()`, `TemplateTag::new_builtin()`, `TemplateTags::new()`\n- [ ] Update `templatetags()` Salsa query to use new response structure\n- [ ] Export `TagProvenance` from `crates/djls-project/src/lib.rs`\n- [ ] Add unit tests: deserialization, accessors, registry data\n- [ ] Fix all compilation errors in downstream crates (`djls-ide`, `djls-server`, `djls-semantic`)\n\n### Phase 3: Completions Fix\n\n- [ ] Rewrite `generate_library_completions()` to use `tags.libraries()` keys instead of `tag.module()`\n- [ ] Sort library names alphabetically for deterministic completion ordering\n- [ ] Exclude builtins from `{% load %}` completions (they're always available)\n- [ ] Update tag name completion detail to show provenance info (\"builtin from ...\" / \"from ... ({% load X %})\")\n- [ ] Update any remaining `tag.module()` calls to use new accessors\n- [ ] Add completion tests for library name completions\n- [ ] Run full `cargo build`, `cargo clippy`, `cargo test`\n\n---\n\n## M2 - Salsa Invalidation Plumbing\n\n**Status:** backlog\n**Plan:** `.agents/plans/2026-02-05-m2-salsa-invalidation-plumbing.md`\n\n_Tasks to be expanded when M1 is complete._\n\n---\n\n## M3 - `{% load %}` Scoping Infrastructure\n\n**Status:** backlog\n**Plan:** `.agents/plans/2026-02-05-m3-load-scoping.md` (overview), phases in `m3.1` through `m3.6`\n\n_Tasks to be expanded when M2 is complete._\n\n---\n\n## M4 - Filters Pipeline\n\n**Status:** backlog\n**Plan:** `.agents/plans/2026-02-05-m4-filters-pipeline.md` (overview), phases in `m4.1` through `m4.4`\n\n_Tasks to be expanded when M3 is complete._\n\n---\n\n## M5 - Extraction Engine (`djls-extraction`)\n\n**Status:** backlog\n**Plan:** `.agents/plans/2026-02-05-m5-extraction-engine.md` (overview), phases in `m5.1` through `m5.9`\n\n_Tasks to be expanded when M4 is complete._\n\n---\n\n## M6 - Rule Evaluation + Expression Validation\n\n**Status:** backlog\n**Plan:** `.agents/plans/2026-02-05-m6-rule-evaluation.md` (overview), phases in `m6.1` through `m6.2`\n\n_Tasks to be expanded when M5 is complete._\n\n---\n\n## M7 - Documentation + Issue Reporting\n\n**Status:** backlog\n**Plan:** `.agents/plans/2026-02-05-m7-docs-and-issue-template.md`\n\n_Tasks to be expanded when M6 is complete._\n\n---\n\n## Discoveries / Notes\n\n_(Record findings here as implementation progresses)_\n"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":1,"output":1449,"cacheRead":23636,"cacheWrite":7493,"totalTokens":32579,"cost":{"input":0.000005,"output":0.036225,"cacheRead":0.011817999999999999,"cacheWrite":0.046831250000000005,"total":0.09487925}},"stopReason":"toolUse","timestamp":1770329176016}}
{"type":"message","id":"08cc96f9","parentId":"cd80d09f","timestamp":"2026-02-05T22:06:41.107Z","message":{"role":"toolResult","toolCallId":"toolu_01UgE4Z9nffj1BVjiScK9PfC","toolName":"write","content":[{"type":"text","text":"Successfully wrote 4005 bytes to /home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6/IMPLEMENTATION_PLAN.md"}],"isError":false,"timestamp":1770329201107}}
{"type":"message","id":"ae98260f","parentId":"08cc96f9","timestamp":"2026-02-05T22:06:43.986Z","message":{"role":"assistant","content":[{"type":"text","text":"Now let me commit this planning work:"},{"type":"toolCall","id":"toolu_01MPQA1afWx1nDnqjMxqc1dV","name":"bash","arguments":{"command":"cd /home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6 && git add -A && git status"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":1,"output":102,"cacheRead":31129,"cacheWrite":1509,"totalTokens":32741,"cost":{"input":0.000005,"output":0.00255,"cacheRead":0.015564499999999998,"cacheWrite":0.00943125,"total":0.02755075}},"stopReason":"toolUse","timestamp":1770329201107}}
{"type":"message","id":"0da58712","parentId":"ae98260f","timestamp":"2026-02-05T22:06:44.017Z","message":{"role":"toolResult","toolCallId":"toolu_01MPQA1afWx1nDnqjMxqc1dV","toolName":"bash","content":[{"type":"text","text":"On branch eval-detailed-opus-4.6\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   IMPLEMENTATION_PLAN.md\n\n"}],"isError":false,"timestamp":1770329204016}}
{"type":"message","id":"9e4144e0","parentId":"0da58712","timestamp":"2026-02-05T22:06:47.914Z","message":{"role":"assistant","content":[{"type":"toolCall","id":"toolu_01QawdjUTWvSHHdW99W3dzER","name":"bash","arguments":{"command":"cd /home/josh/projects/joshuadavidthomas/django-language-server/worktrees/detailed-opus-4.6 && git commit -m \"Add implementation plan with M1 tasks expanded\n\nCreate IMPLEMENTATION_PLAN.md with:\n- Detailed task breakdown for M1 (Payload Shape + Library Name Fix)\n  across all 3 phases: Python inspector, Rust types, completions fix\n- Stub entries for M2-M7 milestones to be expanded as work progresses\""}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":1,"output":172,"cacheRead":32638,"cacheWrite":162,"totalTokens":32973,"cost":{"input":0.000005,"output":0.0043,"cacheRead":0.016319,"cacheWrite":0.0010125,"total":0.0216365}},"stopReason":"toolUse","timestamp":1770329204017}}
{"type":"message","id":"1767904b","parentId":"9e4144e0","timestamp":"2026-02-05T22:06:48.014Z","message":{"role":"toolResult","toolCallId":"toolu_01QawdjUTWvSHHdW99W3dzER","toolName":"bash","content":[{"type":"text","text":"[eval-detailed-opus-4.6 fa36ae3] Add implementation plan with M1 tasks expanded\n 1 file changed, 105 insertions(+)\n create mode 100644 IMPLEMENTATION_PLAN.md\n"}],"isError":false,"timestamp":1770329208013}}
{"type":"message","id":"5edcbd27","parentId":"1767904b","timestamp":"2026-02-05T22:06:53.248Z","message":{"role":"assistant","content":[{"type":"text","text":"Done. I've created `IMPLEMENTATION_PLAN.md` with:\n\n- **M1 fully expanded** into 3 phases with 20+ concrete tasks covering:\n  - **Phase 1**: Python inspector payload changes (provenance model, `TemplateTagQueryData`, collection logic rewrite)\n  - **Phase 2**: Rust type updates (`TagProvenance` enum, `TemplateTag`/`TemplateTags` restructure, accessors, tests, downstream fixes)\n  - **Phase 3**: Completions fix (library name completions, deterministic ordering, provenance detail display)\n- **M2–M7 as stubs** to be expanded as each preceding milestone completes"}],"api":"anthropic-messages","provider":"anthropic","model":"claude-opus-4-6","usage":{"input":1,"output":164,"cacheRead":32800,"cacheWrite":239,"totalTokens":33204,"cost":{"input":0.000005,"output":0.0041,"cacheRead":0.016399999999999998,"cacheWrite":0.00149375,"total":0.021998749999999997}},"stopReason":"stop","timestamp":1770329208014}}
